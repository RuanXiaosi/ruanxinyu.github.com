{"meta":{"title":"RuanXinYu's Blog","subtitle":"路漫漫其修远兮，吾将上下而求索","description":"阮新宇的成长记录","author":"阮新宇","url":"http://ruanxinyu.github.io"},"pages":[{"title":"","date":"un00fin00","updated":"un00fin00","comments":false,"path":"categories/index.html","permalink":"http://ruanxinyu.github.io/categories/index.html","excerpt":"","keywords":"","text":"","raw":"---\nlayout: categories\ncomments: false\n---\n","content":""},{"title":"","date":"un00fin00","updated":"un00fin00","comments":false,"path":"tags/index.html","permalink":"http://ruanxinyu.github.io/tags/index.html","excerpt":"","keywords":"","text":"","raw":"---\nlayout: tags\ncomments: false\n---\n","content":""},{"title":"bookmarks","date":"un00fin00","updated":"un00fin00","comments":true,"path":"pages/bookmarks/index.html","permalink":"http://ruanxinyu.github.io/pages/bookmarks/index.html","excerpt":"","keywords":"","text":"fffff h","raw":"---\ntitle: bookmarks\nlayout: bookmarks\ndate: 2018-10-14 09:29:21\n---\n\n## fffff  h","content":"<h2 id=\"fffff-h\"><a href=\"#fffff-h\" class=\"headerlink\" title=\"fffff  h\"></a>fffff  h</h2>"},{"title":"questions","date":"un00fin00","updated":"un00fin00","comments":true,"path":"pages/questions/index.html","permalink":"http://ruanxinyu.github.io/pages/questions/index.html","excerpt":"","keywords":"","text":"","raw":"---\ntitle: questions\nlayout: questions\ndate: 2018-10-14 11:10:12\n---\n","content":""}],"posts":[{"title":"下一步计划","slug":"下一步计划","date":"un00fin00","updated":"un00fin00","comments":true,"path":"posts/下一步计划/","link":"","permalink":"http://ruanxinyu.github.io/posts/下一步计划/","excerpt":"","keywords":"","text":"博客主题 增加搜索功能 增加直接截取文章标题到问题速查列表中 增加加密的功能 增加百度推送的功能 技术博客 完善Nginx-HAProxy-KeepAlived-Tomcat-MySQL等搭建高可用系统 增加使用Jenkins搭建可持续交付流水线 读书笔记 整理香帅的北大金融学课","raw":"---\ntitle: 下一步计划\ntags: Java\ncategories: 技术分享\ndate: 2018-10-14 12:05:56\n---\n\n# 博客主题\n\n1. 增加搜索功能\n1. 增加直接截取文章标题到问题速查列表中\n1. 增加加密的功能\n1. 增加百度推送的功能\n\n# 技术博客\n\n1. 完善Nginx-HAProxy-KeepAlived-Tomcat-MySQL等搭建高可用系统\n1. 增加使用Jenkins搭建可持续交付流水线\n\n# 读书笔记\n\n1. 整理香帅的北大金融学课","content":"<h1 id=\"博客主题\"><a href=\"#博客主题\" class=\"headerlink\" title=\"博客主题\"></a>博客主题</h1><ol>\n<li>增加搜索功能</li>\n<li>增加直接截取文章标题到问题速查列表中</li>\n<li>增加加密的功能</li>\n<li>增加百度推送的功能</li>\n</ol>\n<h1 id=\"技术博客\"><a href=\"#技术博客\" class=\"headerlink\" title=\"技术博客\"></a>技术博客</h1><ol>\n<li>完善Nginx-HAProxy-KeepAlived-Tomcat-MySQL等搭建高可用系统</li>\n<li>增加使用Jenkins搭建可持续交付流水线</li>\n</ol>\n<h1 id=\"读书笔记\"><a href=\"#读书笔记\" class=\"headerlink\" title=\"读书笔记\"></a>读书笔记</h1><ol>\n<li>整理香帅的北大金融学课</li>\n</ol>\n","categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://ruanxinyu.github.io/categories/技术分享/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://ruanxinyu.github.io/tags/Java/"}]},{"title":"【香帅】010.第2周加餐：深度解析阿里金融帝国","slug":"香帅的北大金融学课/【香帅】010-第2周加餐：深度解析阿里金融帝国","date":"un33fin33","updated":"un33fin33","comments":true,"path":"posts/香帅的北大金融学课/【香帅】010-第2周加餐：深度解析阿里金融帝国/","link":"","permalink":"http://ruanxinyu.github.io/posts/香帅的北大金融学课/【香帅】010-第2周加餐：深度解析阿里金融帝国/","excerpt":"","keywords":"","text":"语句摘录划重点 课后习题 课程原文","raw":"---\ntitle: 【香帅】010.第2周加餐：深度解析阿里金融帝国\ntags:\n  - 经济\n  - 香帅的北大金融学课\ncategories: 读书笔记\ndate: 2018-10-10 21:43:29\n---\n\n# 语句摘录\n\n# 划重点\n\n> \n\n# 课后习题\n\n> \n\n\n# 课程原文\n\n{% asset_img 2018-10-10-21-50-12.png [blog.ruanxinyu.cn] %}","content":"<h1 id=\"语句摘录\"><a href=\"#语句摘录\" class=\"headerlink\" title=\"语句摘录\"></a>语句摘录</h1><h1 id=\"划重点\"><a href=\"#划重点\" class=\"headerlink\" title=\"划重点\"></a>划重点</h1><blockquote>\n</blockquote>\n<h1 id=\"课后习题\"><a href=\"#课后习题\" class=\"headerlink\" title=\"课后习题\"></a>课后习题</h1><blockquote>\n</blockquote>\n<h1 id=\"课程原文\"><a href=\"#课程原文\" class=\"headerlink\" title=\"课程原文\"></a>课程原文</h1><img src=\"/posts/香帅的北大金融学课/【香帅】010-第2周加餐：深度解析阿里金融帝国/2018-10-10-21-50-12.png\" title=\"[blog.ruanxinyu.cn]\">","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ruanxinyu.github.io/categories/读书笔记/"}],"tags":[{"name":"经济","slug":"经济","permalink":"http://ruanxinyu.github.io/tags/经济/"},{"name":"香帅的北大金融学课","slug":"香帅的北大金融学课","permalink":"http://ruanxinyu.github.io/tags/香帅的北大金融学课/"}]},{"title":"【香帅】010.第2周总结：PPT","slug":"香帅的北大金融学课/【香帅】010-第2周总结：PPT","date":"un33fin33","updated":"un44fin44","comments":true,"path":"posts/香帅的北大金融学课/【香帅】010-第2周总结：PPT/","link":"","permalink":"http://ruanxinyu.github.io/posts/香帅的北大金融学课/【香帅】010-第2周总结：PPT/","excerpt":"","keywords":"","text":"","raw":"---\ntitle: 【香帅】010.第2周总结：PPT\ntags:\n  - 经济\n  - 香帅的北大金融学课\ncategories: 读书笔记\ndate: 2018-10-10 21:40:20\n---\n\n{% asset_img 2018-10-10-21-45-53.png [blog.ruanxinyu.cn] %}","content":"<img src=\"/posts/香帅的北大金融学课/【香帅】010-第2周总结：PPT/2018-10-10-21-45-53.png\" title=\"[blog.ruanxinyu.cn]\">","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ruanxinyu.github.io/categories/读书笔记/"}],"tags":[{"name":"经济","slug":"经济","permalink":"http://ruanxinyu.github.io/tags/经济/"},{"name":"香帅的北大金融学课","slug":"香帅的北大金融学课","permalink":"http://ruanxinyu.github.io/tags/香帅的北大金融学课/"}]},{"title":"【香帅】010.第2周问答：如何投资A股市场更明智","slug":"香帅的北大金融学课/【香帅】010-第2周问答：如何投资A股市场更明智","date":"un33fin33","updated":"un33fin33","comments":true,"path":"posts/香帅的北大金融学课/【香帅】010-第2周问答：如何投资A股市场更明智/","link":"","permalink":"http://ruanxinyu.github.io/posts/香帅的北大金融学课/【香帅】010-第2周问答：如何投资A股市场更明智/","excerpt":"","keywords":"","text":"语句摘录美国电商没有带动美国移动支付浪潮是因为美国的支付体系和信用体系已经很完善，不需要新的支付工具，这也是有历史根源。 中国储蓄高，从投资角度看，高储蓄意味着高投资，现在财富积累变多，逐步进入中产+消费的时候，理财需求将会日益增长。 不如说财富贬值以及投资可能带来的高收入的诱惑造成理财需求的日益增长呢 课程原文","raw":"---\ntitle: 【香帅】010.第2周问答：如何投资A股市场更明智\ntags:\n  - 经济\n  - 香帅的北大金融学课\ncategories: 读书笔记\ndate: 2018-10-10 21:07:25\n---\n\n# 语句摘录\n\n美国电商没有带动美国移动支付浪潮是因为美国的支付体系和信用体系已经很完善，不需要新的支付工具，这也是有历史根源。\n\n中国储蓄高，从投资角度看，高储蓄意味着高投资，现在财富积累变多，逐步进入`中产+消费`的时候，理财需求将会日益增长。\n> 不如说财富贬值以及投资可能带来的高收入的诱惑造成理财需求的日益增长呢\n\n# 课程原文\n\n{% asset_img 2018-10-10-21-16-04.png [blog.ruanxinyu.cn] %}","content":"<h1 id=\"语句摘录\"><a href=\"#语句摘录\" class=\"headerlink\" title=\"语句摘录\"></a>语句摘录</h1><p>美国电商没有带动美国移动支付浪潮是因为美国的支付体系和信用体系已经很完善，不需要新的支付工具，这也是有历史根源。</p>\n<p>中国储蓄高，从投资角度看，高储蓄意味着高投资，现在财富积累变多，逐步进入<code>中产+消费</code>的时候，理财需求将会日益增长。</p>\n<blockquote>\n<p>不如说财富贬值以及投资可能带来的高收入的诱惑造成理财需求的日益增长呢</p>\n</blockquote>\n<h1 id=\"课程原文\"><a href=\"#课程原文\" class=\"headerlink\" title=\"课程原文\"></a>课程原文</h1><img src=\"/posts/香帅的北大金融学课/【香帅】010-第2周问答：如何投资A股市场更明智/2018-10-10-21-16-04.png\" title=\"[blog.ruanxinyu.cn]\">","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ruanxinyu.github.io/categories/读书笔记/"}],"tags":[{"name":"经济","slug":"经济","permalink":"http://ruanxinyu.github.io/tags/经济/"},{"name":"香帅的北大金融学课","slug":"香帅的北大金融学课","permalink":"http://ruanxinyu.github.io/tags/香帅的北大金融学课/"}]},{"title":"【香帅】009.个人资产配置的生命周期","slug":"香帅的北大金融学课/【香帅】009-个人资产配置的生命周期","date":"un33fin33","updated":"un33fin33","comments":true,"path":"posts/香帅的北大金融学课/【香帅】009-个人资产配置的生命周期/","link":"","permalink":"http://ruanxinyu.github.io/posts/香帅的北大金融学课/【香帅】009-个人资产配置的生命周期/","excerpt":"","keywords":"","text":"语句摘录实物资产是对抗资产贬值一个特别好多途径。 你赚钱能力越来越强了，也意味着这个时候是你风险承受能力最强的时候。 如果你赚的钱都用来还贷和消费了，那么其实你并没有什么风险承受能力的，这也就是为什么很多房奴不敢冒险的原因。 划重点 在青年的时候，我们应该加大实物资产的配置。 在壮年的时候要加大风险资产的配置，进行资产的多元化配置。 在老年的时候，要加大安全资产的配置，同时加大流动性资产的配置。 课后习题 你在资产配置上曾经走过什么弯路，然后掉入过什么坑，做过什么傻事？ 最大的弯路就是入门太晚，就是工作后存钱太少，没有学习理财，在大学也没有想过怎么去赚钱 课程原文","raw":"---\ntitle: 【香帅】009.个人资产配置的生命周期\ntags:\n  - 经济\n  - 香帅的北大金融学课\ncategories: 读书笔记\ndate: 2018-10-10 20:55:20\n---\n\n# 语句摘录\n\n实物资产是对抗资产贬值一个特别好多途径。\n\n你赚钱能力越来越强了，也意味着这个时候是你风险承受能力最强的时候。\n> 如果你赚的钱都用来还贷和消费了，那么其实你并没有什么风险承受能力的，这也就是为什么很多房奴不敢冒险的原因。\n\n{% asset_img 2018-10-10-20-57-42.png [blog.ruanxinyu.cn] %}\n\n# 划重点\n\n> 1. 在青年的时候，我们应该加大实物资产的配置。\n1. 在壮年的时候要加大风险资产的配置，进行资产的多元化配置。\n1. 在老年的时候，要加大安全资产的配置，同时加大流动性资产的配置。\n\n# 课后习题\n\n> 你在资产配置上曾经走过什么弯路，然后掉入过什么坑，做过什么傻事？\n\n最大的弯路就是入门太晚，就是工作后存钱太少，没有学习理财，在大学也没有想过怎么去赚钱\n\n# 课程原文\n\n{% asset_img 2018-10-10-20-56-17.png [blog.ruanxinyu.cn] %}","content":"<h1 id=\"语句摘录\"><a href=\"#语句摘录\" class=\"headerlink\" title=\"语句摘录\"></a>语句摘录</h1><p>实物资产是对抗资产贬值一个特别好多途径。</p>\n<p>你赚钱能力越来越强了，也意味着这个时候是你风险承受能力最强的时候。</p>\n<blockquote>\n<p>如果你赚的钱都用来还贷和消费了，那么其实你并没有什么风险承受能力的，这也就是为什么很多房奴不敢冒险的原因。</p>\n</blockquote>\n<img src=\"/posts/香帅的北大金融学课/【香帅】009-个人资产配置的生命周期/2018-10-10-20-57-42.png\" title=\"[blog.ruanxinyu.cn]\">\n<h1 id=\"划重点\"><a href=\"#划重点\" class=\"headerlink\" title=\"划重点\"></a>划重点</h1><blockquote>\n<ol>\n<li>在青年的时候，我们应该加大实物资产的配置。</li>\n<li>在壮年的时候要加大风险资产的配置，进行资产的多元化配置。</li>\n<li>在老年的时候，要加大安全资产的配置，同时加大流动性资产的配置。</li>\n</ol>\n</blockquote>\n<h1 id=\"课后习题\"><a href=\"#课后习题\" class=\"headerlink\" title=\"课后习题\"></a>课后习题</h1><blockquote>\n<p>你在资产配置上曾经走过什么弯路，然后掉入过什么坑，做过什么傻事？</p>\n</blockquote>\n<p>最大的弯路就是入门太晚，就是工作后存钱太少，没有学习理财，在大学也没有想过怎么去赚钱</p>\n<h1 id=\"课程原文\"><a href=\"#课程原文\" class=\"headerlink\" title=\"课程原文\"></a>课程原文</h1><img src=\"/posts/香帅的北大金融学课/【香帅】009-个人资产配置的生命周期/2018-10-10-20-56-17.png\" title=\"[blog.ruanxinyu.cn]\">","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ruanxinyu.github.io/categories/读书笔记/"}],"tags":[{"name":"经济","slug":"经济","permalink":"http://ruanxinyu.github.io/tags/经济/"},{"name":"香帅的北大金融学课","slug":"香帅的北大金融学课","permalink":"http://ruanxinyu.github.io/tags/香帅的北大金融学课/"}]},{"title":"【香帅】008.金融市场上的二道贩子们","slug":"香帅的北大金融学课/【香帅】008-金融市场上的二道贩子们","date":"un33fin33","updated":"un33fin33","comments":true,"path":"posts/香帅的北大金融学课/【香帅】008-金融市场上的二道贩子们/","link":"","permalink":"http://ruanxinyu.github.io/posts/香帅的北大金融学课/【香帅】008-金融市场上的二道贩子们/","excerpt":"","keywords":"","text":"语句摘录“信息不对称”正是金融市场上最核心的特征，因为金融做的是信用的交易，换句话说，金融市场上交易的是很难看得见、摸得着的东西。 我们中国叫“券商”，国外叫“投资银行”。投资银行或者券商在降低信息不对称，撮合金融市场交易的过程中间发挥的巨大作用。 说得好听点叫降低信息不对称促进市场交易，说得不好听点就是利用信息不对称赚钱 没有金融中介机构，金融市场是没有办法运行的，在金融市场这么一个天生具有信息不对称的地方，高度中介化是必然的趋势。 划重点 信息不对称是金融市场最重要的特征，因为金融市场交易的是看不见、摸不着的“未来”，是虚拟经济，所以消除信息不对称的“中介机构”非常重要。 2. 市场上有很多很多的金融中介机构、信息评级机构，还有银行、投资银行，这一切都是金融中介机构，它是我们金融市场上最重要的组成部分，因为它们降低了市场上的信息不对称，维持了我们这个市场的运行。 课后习题 现在很多人在说互联网技术改变了金融本质，比如 P2P, 就是 peer to peer (个人到个人)的借贷方。由于有了互联网技术，未来金融市场上完全可以“去中介化”，你认同这个说法吗？为什么？ 信息不对称是客观事实，所以永远无法去中介化，只是说中介变为了互联网公司而已，而互联网公司到底能不能做好信息的核查就是一个问题，因此存在较高的金融风险，这也是国家限制的原因吧。支付宝闪贷也是有大家平时的消费信用做担保的。 中介可以提高社会的协作效率，术业有专攻。 课程原文","raw":"---\ntitle: 【香帅】008.金融市场上的二道贩子们\ntags:\n  - 经济\n  - 香帅的北大金融学课\ncategories: 读书笔记\ndate: 2018-10-10 20:22:13\n---\n\n# 语句摘录\n\n“`信息不对称`”正是金融市场上最核心的特征，因为金融做的是信用的交易，换句话说，金融市场上交易的是很难看得见、摸得着的东西。\n\n我们中国叫“券商”，国外叫“投资银行”。投资银行或者券商在降低信息不对称，撮合金融市场交易的过程中间发挥的巨大作用。\n> 说得好听点叫降低信息不对称促进市场交易，说得不好听点就是利用信息不对称赚钱\n\n没有金融中介机构，金融市场是没有办法运行的，在金融市场这么一个天生具有信息不对称的地方，高度中介化是必然的趋势。\n\n# 划重点\n\n> 1. 信息不对称是金融市场最重要的特征，因为金融市场交易的是看不见、摸不着的“未来”，是虚拟经济，所以消除信息不对称的“中介机构”非常重要。 2. 市场上有很多很多的金融中介机构、信息评级机构，还有银行、投资银行，这一切都是金融中介机构，它是我们金融市场上最重要的组成部分，因为它们降低了市场上的信息不对称，维持了我们这个市场的运行。\n\n# 课后习题\n\n> 现在很多人在说互联网技术改变了金融本质，比如 P2P, 就是 peer to peer (个人到个人)的借贷方。由于有了互联网技术，未来金融市场上完全可以“去中介化”，你认同这个说法吗？为什么？\n\n信息不对称是客观事实，所以永远无法去中介化，只是说中介变为了互联网公司而已，而互联网公司到底能不能做好信息的核查就是一个问题，因此存在较高的金融风险，这也是国家限制的原因吧。支付宝闪贷也是有大家平时的消费信用做担保的。\n\n中介可以提高社会的协作效率，术业有专攻。\n\n# 课程原文\n\n{% asset_img 2018-10-10-20-23-14.png [blog.ruanxinyu.cn] %}","content":"<h1 id=\"语句摘录\"><a href=\"#语句摘录\" class=\"headerlink\" title=\"语句摘录\"></a>语句摘录</h1><p>“<code>信息不对称</code>”正是金融市场上最核心的特征，因为金融做的是信用的交易，换句话说，金融市场上交易的是很难看得见、摸得着的东西。</p>\n<p>我们中国叫“券商”，国外叫“投资银行”。投资银行或者券商在降低信息不对称，撮合金融市场交易的过程中间发挥的巨大作用。</p>\n<blockquote>\n<p>说得好听点叫降低信息不对称促进市场交易，说得不好听点就是利用信息不对称赚钱</p>\n</blockquote>\n<p>没有金融中介机构，金融市场是没有办法运行的，在金融市场这么一个天生具有信息不对称的地方，高度中介化是必然的趋势。</p>\n<h1 id=\"划重点\"><a href=\"#划重点\" class=\"headerlink\" title=\"划重点\"></a>划重点</h1><blockquote>\n<ol>\n<li>信息不对称是金融市场最重要的特征，因为金融市场交易的是看不见、摸不着的“未来”，是虚拟经济，所以消除信息不对称的“中介机构”非常重要。 2. 市场上有很多很多的金融中介机构、信息评级机构，还有银行、投资银行，这一切都是金融中介机构，它是我们金融市场上最重要的组成部分，因为它们降低了市场上的信息不对称，维持了我们这个市场的运行。</li>\n</ol>\n</blockquote>\n<h1 id=\"课后习题\"><a href=\"#课后习题\" class=\"headerlink\" title=\"课后习题\"></a>课后习题</h1><blockquote>\n<p>现在很多人在说互联网技术改变了金融本质，比如 P2P, 就是 peer to peer (个人到个人)的借贷方。由于有了互联网技术，未来金融市场上完全可以“去中介化”，你认同这个说法吗？为什么？</p>\n</blockquote>\n<p>信息不对称是客观事实，所以永远无法去中介化，只是说中介变为了互联网公司而已，而互联网公司到底能不能做好信息的核查就是一个问题，因此存在较高的金融风险，这也是国家限制的原因吧。支付宝闪贷也是有大家平时的消费信用做担保的。</p>\n<p>中介可以提高社会的协作效率，术业有专攻。</p>\n<h1 id=\"课程原文\"><a href=\"#课程原文\" class=\"headerlink\" title=\"课程原文\"></a>课程原文</h1><img src=\"/posts/香帅的北大金融学课/【香帅】008-金融市场上的二道贩子们/2018-10-10-20-23-14.png\" title=\"[blog.ruanxinyu.cn]\">","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ruanxinyu.github.io/categories/读书笔记/"}],"tags":[{"name":"经济","slug":"经济","permalink":"http://ruanxinyu.github.io/tags/经济/"},{"name":"香帅的北大金融学课","slug":"香帅的北大金融学课","permalink":"http://ruanxinyu.github.io/tags/香帅的北大金融学课/"}]},{"title":"【香帅】007.分权制衡：银行货币信用体系","slug":"香帅的北大金融学课/【香帅】007-分权制衡：银行货币信用体系","date":"un33fin33","updated":"un33fin33","comments":true,"path":"posts/香帅的北大金融学课/【香帅】007-分权制衡：银行货币信用体系/","link":"","permalink":"http://ruanxinyu.github.io/posts/香帅的北大金融学课/【香帅】007-分权制衡：银行货币信用体系/","excerpt":"","keywords":"","text":"语句摘录中世纪，朝圣者需要一个异地托管财物的体系，因为当时小国林立无法建立跨国异地财务托管体系，因此圣殿骑士团承担起这个指责，扮演着“银行”的角色，而且扮演了一个欧洲金融启蒙者的角色。 因为小国林立，相互制约，造成统治阶层也不敢违约，所以才建立起全民信用关系网络。之后一系列的金融业务，都延续了圣殿骑士团的金融遗产，在这个基础上，欧洲就逐渐形成了以“银行为中心”的、“分权制衡”下的信用体系，我把它称为欧洲的“银行货币信用体系”。 美国初期13个殖民地相互制约，经过南北战争后统一了市场和货币，结合了中华帝国“集中”和欧洲大陆“分权”的优越性。 欧美信用社会的形成，是由于欧洲分权制衡的形态所决定的。 划重点 中世纪之后的“圣殿骑士团”，从事财务托管、货币兑换、储蓄理财业务，扮演着银行的角色，奠定了欧洲的金融基础。 2. 骑士团衰落后，意大利银行业、荷兰证券业、英法银行业等其他信用机构兴起，逐渐形成以银行为中心的，分权制衡下的信用体系。 3. 美国具有与欧洲相似的政治分权制衡的性质，延续了欧洲的金融传统，所以成为世界上最发达的金融市场。 课后习题 大家都知道，中国现在的互联网支付行业特别发达，支付宝、微信简直有横扫全球的趋势。但是我们都知道，互联网支付是依赖于金融体系的，也依赖于互联网的一个技术，为什么在一个互联网落后，金融也不发达的地方，反而“长”出了全球最牛的互联网支付体系呢？ 社会逐步走向中产和消费，理财需求被压抑，并且现在法律逐步健全，因而支付宝等弥补了民间的信用缺失，同时银行存在一定的跨地域问题，纸币交易麻烦，刷卡支付不健全，而移动互联的普及大大增加了支付的便利性。 课程原文","raw":"---\ntitle: 【香帅】007.分权制衡：银行货币信用体系\ntags:\n  - 经济\n  - 香帅的北大金融学课\ncategories: 读书笔记\ndate: 2018-10-10 18:31:02\n---\n\n# 语句摘录\n\n中世纪，朝圣者需要一个异地托管财物的体系，因为当时小国林立无法建立跨国异地财务托管体系，因此圣殿骑士团承担起这个指责，扮演着“银行”的角色，而且扮演了一个欧洲金融启蒙者的角色。\n\n因为小国林立，相互制约，造成统治阶层也不敢违约，所以才建立起全民信用关系网络。之后一系列的金融业务，都延续了圣殿骑士团的金融遗产，在这个基础上，欧洲就逐渐形成了以“`银行为中心”的、“分权制衡`”下的信用体系，我把它称为欧洲的“`银行货币信用体系`”。\n\n美国初期13个殖民地相互制约，经过南北战争后统一了市场和货币，结合了中华帝国“集中”和欧洲大陆“分权”的优越性。\n\n欧美信用社会的形成，是由于欧洲分权制衡的形态所决定的。\n\n# 划重点\n\n> 1. 中世纪之后的“圣殿骑士团”，从事财务托管、货币兑换、储蓄理财业务，扮演着银行的角色，奠定了欧洲的金融基础。   2. 骑士团衰落后，意大利银行业、荷兰证券业、英法银行业等其他信用机构兴起，逐渐形成以银行为中心的，分权制衡下的信用体系。   3. 美国具有与欧洲相似的政治分权制衡的性质，延续了欧洲的金融传统，所以成为世界上最发达的金融市场。\n\n# 课后习题\n\n> 大家都知道，中国现在的互联网支付行业特别发达，支付宝、微信简直有横扫全球的趋势。但是我们都知道，互联网支付是依赖于金融体系的，也依赖于互联网的一个技术，为什么在一个互联网落后，金融也不发达的地方，反而“长”出了全球最牛的互联网支付体系呢？\n\n社会逐步走向中产和消费，理财需求被压抑，并且现在法律逐步健全，因而支付宝等弥补了民间的信用缺失，同时银行存在一定的跨地域问题，纸币交易麻烦，刷卡支付不健全，而移动互联的普及大大增加了支付的便利性。\n\n# 课程原文\n\n{% asset_img 2018-10-10-18-32-14.png [blog.ruanxinyu.cn] %}","content":"<h1 id=\"语句摘录\"><a href=\"#语句摘录\" class=\"headerlink\" title=\"语句摘录\"></a>语句摘录</h1><p>中世纪，朝圣者需要一个异地托管财物的体系，因为当时小国林立无法建立跨国异地财务托管体系，因此圣殿骑士团承担起这个指责，扮演着“银行”的角色，而且扮演了一个欧洲金融启蒙者的角色。</p>\n<p>因为小国林立，相互制约，造成统治阶层也不敢违约，所以才建立起全民信用关系网络。之后一系列的金融业务，都延续了圣殿骑士团的金融遗产，在这个基础上，欧洲就逐渐形成了以“<code>银行为中心”的、“分权制衡</code>”下的信用体系，我把它称为欧洲的“<code>银行货币信用体系</code>”。</p>\n<p>美国初期13个殖民地相互制约，经过南北战争后统一了市场和货币，结合了中华帝国“集中”和欧洲大陆“分权”的优越性。</p>\n<p>欧美信用社会的形成，是由于欧洲分权制衡的形态所决定的。</p>\n<h1 id=\"划重点\"><a href=\"#划重点\" class=\"headerlink\" title=\"划重点\"></a>划重点</h1><blockquote>\n<ol>\n<li>中世纪之后的“圣殿骑士团”，从事财务托管、货币兑换、储蓄理财业务，扮演着银行的角色，奠定了欧洲的金融基础。   2. 骑士团衰落后，意大利银行业、荷兰证券业、英法银行业等其他信用机构兴起，逐渐形成以银行为中心的，分权制衡下的信用体系。   3. 美国具有与欧洲相似的政治分权制衡的性质，延续了欧洲的金融传统，所以成为世界上最发达的金融市场。</li>\n</ol>\n</blockquote>\n<h1 id=\"课后习题\"><a href=\"#课后习题\" class=\"headerlink\" title=\"课后习题\"></a>课后习题</h1><blockquote>\n<p>大家都知道，中国现在的互联网支付行业特别发达，支付宝、微信简直有横扫全球的趋势。但是我们都知道，互联网支付是依赖于金融体系的，也依赖于互联网的一个技术，为什么在一个互联网落后，金融也不发达的地方，反而“长”出了全球最牛的互联网支付体系呢？</p>\n</blockquote>\n<p>社会逐步走向中产和消费，理财需求被压抑，并且现在法律逐步健全，因而支付宝等弥补了民间的信用缺失，同时银行存在一定的跨地域问题，纸币交易麻烦，刷卡支付不健全，而移动互联的普及大大增加了支付的便利性。</p>\n<h1 id=\"课程原文\"><a href=\"#课程原文\" class=\"headerlink\" title=\"课程原文\"></a>课程原文</h1><img src=\"/posts/香帅的北大金融学课/【香帅】007-分权制衡：银行货币信用体系/2018-10-10-18-32-14.png\" title=\"[blog.ruanxinyu.cn]\">","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ruanxinyu.github.io/categories/读书笔记/"}],"tags":[{"name":"经济","slug":"经济","permalink":"http://ruanxinyu.github.io/tags/经济/"},{"name":"香帅的北大金融学课","slug":"香帅的北大金融学课","permalink":"http://ruanxinyu.github.io/tags/香帅的北大金融学课/"}]},{"title":"【香帅】006.王的信用：中央货币财政体系","slug":"香帅的北大金融学课/【香帅】006-王的信用：中央货币财政体系","date":"un33fin33","updated":"un33fin33","comments":true,"path":"posts/香帅的北大金融学课/【香帅】006-王的信用：中央货币财政体系/","link":"","permalink":"http://ruanxinyu.github.io/posts/香帅的北大金融学课/【香帅】006-王的信用：中央货币财政体系/","excerpt":"","keywords":"","text":"语句摘录欧洲的金融市场产生于一个“小国林立、分封而治”的大背景。而中国的金融市场，是从一个中央集权的帝国内部演化出来的。 秦始皇为统一市场，因而统一了货币制度。汉武帝穷兵黩武，通过国有经济筹集经费和加强集权控制。 中华帝国的金融是围绕着中央财政，自上而下的一个货币经济体系，我们就可以直接把它称为“中央货币财政体系”。这种制度在生产力低下的情况下能够起到强大的动员能力，但是因为完全依赖于国家，民间信用意识很难培养起来。 存在即合理，只是说以前合理的现在不一定合理，所以分析现状也要追溯历史，这样才能看得更清楚 中国现代的金融市场是古代的继承，都是自上而下，为中央财政目标而实施的“顶层设计”。 最初A股市场的设立，它设立的目标是替国有企业解困。 中央控制可以集中资金发展基础建设，但是造成民间信用脆弱，民间理财需求被压抑。 ##留言区摘选** 吴军对行业变革的两点建议：1. 目标要超前，方法和认识要彻底更新；2. 做法上要渐进，反对一切推倒重来 高储蓄意味着高投资 划重点 国家掌控大量的金融资源，经济生活国有化，便于国家“集中力量办大事”。 2. 这种制度的缺点是民间信用脆弱。民间投融资需求得不到满足，所以造成了中国金融市场的很多乱象。 课后习题 中国老百姓特别喜欢储蓄，自古就喜欢把银元存在缸里、埋在地下。爷爷奶奶们都喜欢把钱放在床下，塞进抽屉柜深处。你觉得这种现象是因为中国人特别抠门吗？再想想山西票号最后为什么会受到洋行挤压而衰落，这中间有什么联系吗？ 每个人都会衡量利益关系，既然选择压箱底，那就一定是没有更好的途径，在法律不健全的情况下，产权不明确，予之在君，夺值在君，贫之在君，富之在君，民众缺少民间和官方的金融机构信任感。反过来看，现在钱放在银行里的钱不断在贬值，银行和国家的信任不是也在不断的流失吗？ 课程原文","raw":"---\ntitle: 【香帅】006.王的信用：中央货币财政体系\ntags:\n  - 经济\n  - 香帅的北大金融学课\ncategories: 读书笔记\ndate: 2018-10-10 13:46:04\n---\n\n# 语句摘录\n\n欧洲的金融市场产生于一个“小国林立、分封而治”的大背景。而中国的金融市场，是从一个中央集权的帝国内部演化出来的。\n\n秦始皇为统一市场，因而统一了货币制度。汉武帝穷兵黩武，通过国有经济筹集经费和加强集权控制。\n\n**中华帝国的金融是围绕着中央财政，自上而下的一个货币经济体系，我们就可以直接把它称为“`中央货币财政体系`”。**这种制度在生产力低下的情况下能够起到强大的动员能力，但是因为完全依赖于国家，民间信用意识很难培养起来。\n> 存在即合理，只是说以前合理的现在不一定合理，所以分析现状也要追溯历史，这样才能看得更清楚\n\n中国现代的金融市场是古代的继承，都是自上而下，为中央财政目标而实施的“顶层设计”。\n\n最初`A`股市场的设立，它设立的目标是替国有企业解困。\n\n中央控制可以集中资金发展基础建设，但是造成民间信用脆弱，民间理财需求被压抑。\n\n##留言区摘选**\n\n吴军对行业变革的两点建议：1. 目标要超前，方法和认识要彻底更新；2. 做法上要渐进，反对一切推倒重来\n\n高储蓄意味着高投资\n\n# 划重点\n\n> 1. 国家掌控大量的金融资源，经济生活国有化，便于国家“集中力量办大事”。 2. 这种制度的缺点是民间信用脆弱。民间投融资需求得不到满足，所以造成了中国金融市场的很多乱象。\n\n# 课后习题\n\n> 中国老百姓特别喜欢储蓄，自古就喜欢把银元存在缸里、埋在地下。爷爷奶奶们都喜欢把钱放在床下，塞进抽屉柜深处。你觉得这种现象是因为中国人特别抠门吗？再想想山西票号最后为什么会受到洋行挤压而衰落，这中间有什么联系吗？\n\n每个人都会衡量利益关系，既然选择压箱底，那就一定是没有更好的途径，在法律不健全的情况下，产权不明确，予之在君，夺值在君，贫之在君，富之在君，民众缺少民间和官方的金融机构信任感。反过来看，现在钱放在银行里的钱不断在贬值，银行和国家的信任不是也在不断的流失吗？\n\n# 课程原文\n\n{% asset_img 2018-10-10-13-47-20.png [blog.ruanxinyu.cn] %}","content":"<h1 id=\"语句摘录\"><a href=\"#语句摘录\" class=\"headerlink\" title=\"语句摘录\"></a>语句摘录</h1><p>欧洲的金融市场产生于一个“小国林立、分封而治”的大背景。而中国的金融市场，是从一个中央集权的帝国内部演化出来的。</p>\n<p>秦始皇为统一市场，因而统一了货币制度。汉武帝穷兵黩武，通过国有经济筹集经费和加强集权控制。</p>\n<p><strong>中华帝国的金融是围绕着中央财政，自上而下的一个货币经济体系，我们就可以直接把它称为“<code>中央货币财政体系</code>”。</strong>这种制度在生产力低下的情况下能够起到强大的动员能力，但是因为完全依赖于国家，民间信用意识很难培养起来。</p>\n<blockquote>\n<p>存在即合理，只是说以前合理的现在不一定合理，所以分析现状也要追溯历史，这样才能看得更清楚</p>\n</blockquote>\n<p>中国现代的金融市场是古代的继承，都是自上而下，为中央财政目标而实施的“顶层设计”。</p>\n<p>最初<code>A</code>股市场的设立，它设立的目标是替国有企业解困。</p>\n<p>中央控制可以集中资金发展基础建设，但是造成民间信用脆弱，民间理财需求被压抑。</p>\n<p>##留言区摘选**</p>\n<p>吴军对行业变革的两点建议：1. 目标要超前，方法和认识要彻底更新；2. 做法上要渐进，反对一切推倒重来</p>\n<p>高储蓄意味着高投资</p>\n<h1 id=\"划重点\"><a href=\"#划重点\" class=\"headerlink\" title=\"划重点\"></a>划重点</h1><blockquote>\n<ol>\n<li>国家掌控大量的金融资源，经济生活国有化，便于国家“集中力量办大事”。 2. 这种制度的缺点是民间信用脆弱。民间投融资需求得不到满足，所以造成了中国金融市场的很多乱象。</li>\n</ol>\n</blockquote>\n<h1 id=\"课后习题\"><a href=\"#课后习题\" class=\"headerlink\" title=\"课后习题\"></a>课后习题</h1><blockquote>\n<p>中国老百姓特别喜欢储蓄，自古就喜欢把银元存在缸里、埋在地下。爷爷奶奶们都喜欢把钱放在床下，塞进抽屉柜深处。你觉得这种现象是因为中国人特别抠门吗？再想想山西票号最后为什么会受到洋行挤压而衰落，这中间有什么联系吗？</p>\n</blockquote>\n<p>每个人都会衡量利益关系，既然选择压箱底，那就一定是没有更好的途径，在法律不健全的情况下，产权不明确，予之在君，夺值在君，贫之在君，富之在君，民众缺少民间和官方的金融机构信任感。反过来看，现在钱放在银行里的钱不断在贬值，银行和国家的信任不是也在不断的流失吗？</p>\n<h1 id=\"课程原文\"><a href=\"#课程原文\" class=\"headerlink\" title=\"课程原文\"></a>课程原文</h1><img src=\"/posts/香帅的北大金融学课/【香帅】006-王的信用：中央货币财政体系/2018-10-10-13-47-20.png\" title=\"[blog.ruanxinyu.cn]\">","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ruanxinyu.github.io/categories/读书笔记/"}],"tags":[{"name":"经济","slug":"经济","permalink":"http://ruanxinyu.github.io/tags/经济/"},{"name":"香帅的北大金融学课","slug":"香帅的北大金融学课","permalink":"http://ruanxinyu.github.io/tags/香帅的北大金融学课/"}]},{"title":"【香帅】005.第1周总结：PPT","slug":"香帅的北大金融学课/【香帅】005-第1周总结：PPT","date":"un33fin33","updated":"un44fin44","comments":true,"path":"posts/香帅的北大金融学课/【香帅】005-第1周总结：PPT/","link":"","permalink":"http://ruanxinyu.github.io/posts/香帅的北大金融学课/【香帅】005-第1周总结：PPT/","excerpt":"","keywords":"","text":"","raw":"---\ntitle: 【香帅】005.第1周总结：PPT\ntags:\n  - 经济\n  - 香帅的北大金融学课\ncategories: 读书笔记\ndate: 2018-10-10 13:28:05\n---\n\n{% asset_img 2018-10-10-21-36-51.png [blog.ruanxinyu.cn] %}","content":"<img src=\"/posts/香帅的北大金融学课/【香帅】005-第1周总结：PPT/2018-10-10-21-36-51.png\" title=\"[blog.ruanxinyu.cn]\">","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ruanxinyu.github.io/categories/读书笔记/"}],"tags":[{"name":"经济","slug":"经济","permalink":"http://ruanxinyu.github.io/tags/经济/"},{"name":"香帅的北大金融学课","slug":"香帅的北大金融学课","permalink":"http://ruanxinyu.github.io/tags/香帅的北大金融学课/"}]},{"title":"【香帅】005.第1周问答：不同风险偏好的人该如何投资","slug":"香帅的北大金融学课/【香帅】005-第1周问答：不同风险偏好的人该如何投资","date":"un33fin33","updated":"un33fin33","comments":true,"path":"posts/香帅的北大金融学课/【香帅】005-第1周问答：不同风险偏好的人该如何投资/","link":"","permalink":"http://ruanxinyu.github.io/posts/香帅的北大金融学课/【香帅】005-第1周问答：不同风险偏好的人该如何投资/","excerpt":"","keywords":"","text":"语句摘录最重要的是要建立一个自己的知识框架和思维方式，掌握事情背后的一般性规律，然后因地制宜、因时制宜地来安排你的人生。社会环境在变化，但是人性其实没有变过。你要在理解人性的基础上理解这些宏观环境的变化，才能够把握未来的趋势。 金融是一个风险-收益决策衡量的框架性思维，一个人要具有这种思维能力，才能保证在大的人生决策上，作出对的选择。它是一门对未来做资产配置的学问，它的一切都是基于对未来的计算、预测和分析。 喜欢追涨杀跌，跟着亲戚群里的三手、四手、五手的消息去炒股，吃了不少亏，始终在被市场“割韭菜”。 有些人是风险爱好者，一个典型的判断标准就是：他们从不后悔自己做过什么事，只会为没做什么事后悔。相对而言，他们就可以做一些高风险、高收益的投资。 另外一种人，他们对风险很厌恶，这种人的投资策略就应该是保守一点，应该多选债券、多买指数基金，做保守型、不激进的投资。 课程原文","raw":"---\ntitle: 【香帅】005.第1周问答：不同风险偏好的人该如何投资\ntags:\n  - 经济\n  - 香帅的北大金融学课\ncategories: 读书笔记\ndate: 2018-10-10 13:27:05\n---\n\n# 语句摘录\n\n最重要的是要建立一个自己的知识框架和思维方式，掌握事情背后的一般性规律，然后因地制宜、因时制宜地来安排你的人生。社会环境在变化，但是人性其实没有变过。你要在理解人性的基础上理解这些宏观环境的变化，才能够把握未来的趋势。\n\n金融是一个风险-收益决策衡量的框架性思维，一个人要具有这种思维能力，才能保证在大的人生决策上，作出对的选择。它是一门对未来做资产配置的学问，它的一切都是基于对未来的计算、预测和分析。\n\n喜欢追涨杀跌，跟着亲戚群里的三手、四手、五手的消息去炒股，吃了不少亏，始终在被市场“割韭菜”。\n\n有些人是风险爱好者，一个典型的判断标准就是：他们从不后悔自己做过什么事，只会为没做什么事后悔。相对而言，他们就可以做一些高风险、高收益的投资。\n\n另外一种人，他们对风险很厌恶，这种人的投资策略就应该是保守一点，应该多选债券、多买指数基金，做保守型、不激进的投资。\n\n# 课程原文\n\n{% asset_img 2018-10-10-13-43-51.png [blog.ruanxinyu.cn] %}","content":"<h1 id=\"语句摘录\"><a href=\"#语句摘录\" class=\"headerlink\" title=\"语句摘录\"></a>语句摘录</h1><p>最重要的是要建立一个自己的知识框架和思维方式，掌握事情背后的一般性规律，然后因地制宜、因时制宜地来安排你的人生。社会环境在变化，但是人性其实没有变过。你要在理解人性的基础上理解这些宏观环境的变化，才能够把握未来的趋势。</p>\n<p>金融是一个风险-收益决策衡量的框架性思维，一个人要具有这种思维能力，才能保证在大的人生决策上，作出对的选择。它是一门对未来做资产配置的学问，它的一切都是基于对未来的计算、预测和分析。</p>\n<p>喜欢追涨杀跌，跟着亲戚群里的三手、四手、五手的消息去炒股，吃了不少亏，始终在被市场“割韭菜”。</p>\n<p>有些人是风险爱好者，一个典型的判断标准就是：他们从不后悔自己做过什么事，只会为没做什么事后悔。相对而言，他们就可以做一些高风险、高收益的投资。</p>\n<p>另外一种人，他们对风险很厌恶，这种人的投资策略就应该是保守一点，应该多选债券、多买指数基金，做保守型、不激进的投资。</p>\n<h1 id=\"课程原文\"><a href=\"#课程原文\" class=\"headerlink\" title=\"课程原文\"></a>课程原文</h1><img src=\"/posts/香帅的北大金融学课/【香帅】005-第1周问答：不同风险偏好的人该如何投资/2018-10-10-13-43-51.png\" title=\"[blog.ruanxinyu.cn]\">","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ruanxinyu.github.io/categories/读书笔记/"}],"tags":[{"name":"经济","slug":"经济","permalink":"http://ruanxinyu.github.io/tags/经济/"},{"name":"香帅的北大金融学课","slug":"香帅的北大金融学课","permalink":"http://ruanxinyu.github.io/tags/香帅的北大金融学课/"}]},{"title":"【香帅】004.构建完整的金融世界观","slug":"香帅的北大金融学课/【香帅】004-构建完整的金融世界观","date":"un33fin33","updated":"un33fin33","comments":true,"path":"posts/香帅的北大金融学课/【香帅】004-构建完整的金融世界观/","link":"","permalink":"http://ruanxinyu.github.io/posts/香帅的北大金融学课/【香帅】004-构建完整的金融世界观/","excerpt":"","keywords":"","text":"语句摘录金融的正面效果： 金融能帮我们加工时间，集聚资金和分散风险。这三种能力，被我们称为“金融三大定理”：时间 资金 风险。 金融的负面效果： 金融更容易造成“穷者越穷，富者越富”的马太效应，同时容易利用信息的不对称性来套利存在道德风险。 金融地图： 金融机构： 金融中介机构 银行 投资银行 基金 金融工具： 股票 债券 金融衍生产品 金融交易制度 投资者决策： 资产配置 证券选择 非理性决策的一系列内容 公司决策： 筹资 分红 股权激励 兼并收购压力 金融的监管 创新和危机： 监管 创新 危机 科技金融： 互联网金融 区块链 比特币 数字银行 运用金融思维，你不但应该在投资上做一个价值投资者，更要在人生上做一个价值投资者。 划重点 我们的金融世界观的框架包括两个维度，一方面要认识到金融的能力，另一方面也要认识到金融的破坏力； 2. 构建金融世界观是为了作出正确的金融决策，这就需要我们有扎实的金融基础知识作为支撑，我给出了一张全年的学习地图，你可以按照这张图循序渐进地构筑你的金融世界观大厦。 课后习题 2007—2008年的全球金融危机后，人们对于金融投机客们的痛恨到达顶点，所有的媒体和政客都对金融体系提出了严厉的批评。比如前法国总统萨科奇就说：“金融体系本质上是一个不负责任的，不道德的体系。”前英国首相布莱尔也说：“金融体系偏离了本质，而且它也无法回归本真了。” 结合对这周课程的理解，如果让你点评萨科奇和布莱尔的话，你会怎么说？ 金融是一个工具，没有好坏属性，关键在于如何使用。但是金融知识必须要学，可以怀着一颗不作恶的心，但是也要能知道别人如何思考和运作以保护自己，就像一个优秀的侦探一样。 课程原文","raw":"---\ntitle: 【香帅】004.构建完整的金融世界观\ntags:\n  - 经济\n  - 香帅的北大金融学课\ncategories: 读书笔记\ndate: 2018-10-10 13:03:35\n---\n\n# 语句摘录\n\n**金融的正面效果：** 金融能帮我们加工时间，集聚资金和分散风险。这三种能力，被我们称为“金融三大定理”：`时间 资金 风险`。\n\n**金融的负面效果：** 金融更容易造成“穷者越穷，富者越富”的`马太效应`，同时容易利用信息的不对称性来套利存在`道德风险`。\n\n金融地图：\n\n1. **金融机构：** 金融中介机构 银行 投资银行 基金\n1. **金融工具：** 股票 债券 金融衍生产品 金融交易制度\n1. **投资者决策：** 资产配置 证券选择 非理性决策的一系列内容\n1. **公司决策：** 筹资 分红 股权激励 兼并收购压力\n1. **金融的监管 创新和危机：** 监管 创新 危机\n1. **科技金融：** 互联网金融 区块链 比特币 数字银行\n\n运用金融思维，你不但应该在投资上做一个价值投资者，更要在人生上做一个价值投资者。\n\n# 划重点\n\n> 1. 我们的金融世界观的框架包括两个维度，一方面要认识到金融的能力，另一方面也要认识到金融的破坏力； 2. 构建金融世界观是为了作出正确的金融决策，这就需要我们有扎实的金融基础知识作为支撑，我给出了一张全年的学习地图，你可以按照这张图循序渐进地构筑你的金融世界观大厦。\n\n# 课后习题\n\n> 2007—2008年的全球金融危机后，人们对于金融投机客们的痛恨到达顶点，所有的媒体和政客都对金融体系提出了严厉的批评。比如前法国总统萨科奇就说：“金融体系本质上是一个不负责任的，不道德的体系。”前英国首相布莱尔也说：“金融体系偏离了本质，而且它也无法回归本真了。” 结合对这周课程的理解，如果让你点评萨科奇和布莱尔的话，你会怎么说？\n\n金融是一个工具，没有好坏属性，关键在于如何使用。但是金融知识必须要学，可以怀着一颗不作恶的心，但是也要能知道别人如何思考和运作以保护自己，就像一个优秀的侦探一样。\n\n# 课程原文\n\n{% asset_img 2018-10-10-13-03-50.png [blog.ruanxinyu.cn] %}","content":"<h1 id=\"语句摘录\"><a href=\"#语句摘录\" class=\"headerlink\" title=\"语句摘录\"></a>语句摘录</h1><p><strong>金融的正面效果：</strong> 金融能帮我们加工时间，集聚资金和分散风险。这三种能力，被我们称为“金融三大定理”：<code>时间 资金 风险</code>。</p>\n<p><strong>金融的负面效果：</strong> 金融更容易造成“穷者越穷，富者越富”的<code>马太效应</code>，同时容易利用信息的不对称性来套利存在<code>道德风险</code>。</p>\n<p>金融地图：</p>\n<ol>\n<li><strong>金融机构：</strong> 金融中介机构 银行 投资银行 基金</li>\n<li><strong>金融工具：</strong> 股票 债券 金融衍生产品 金融交易制度</li>\n<li><strong>投资者决策：</strong> 资产配置 证券选择 非理性决策的一系列内容</li>\n<li><strong>公司决策：</strong> 筹资 分红 股权激励 兼并收购压力</li>\n<li><strong>金融的监管 创新和危机：</strong> 监管 创新 危机</li>\n<li><strong>科技金融：</strong> 互联网金融 区块链 比特币 数字银行</li>\n</ol>\n<p>运用金融思维，你不但应该在投资上做一个价值投资者，更要在人生上做一个价值投资者。</p>\n<h1 id=\"划重点\"><a href=\"#划重点\" class=\"headerlink\" title=\"划重点\"></a>划重点</h1><blockquote>\n<ol>\n<li>我们的金融世界观的框架包括两个维度，一方面要认识到金融的能力，另一方面也要认识到金融的破坏力； 2. 构建金融世界观是为了作出正确的金融决策，这就需要我们有扎实的金融基础知识作为支撑，我给出了一张全年的学习地图，你可以按照这张图循序渐进地构筑你的金融世界观大厦。</li>\n</ol>\n</blockquote>\n<h1 id=\"课后习题\"><a href=\"#课后习题\" class=\"headerlink\" title=\"课后习题\"></a>课后习题</h1><blockquote>\n<p>2007—2008年的全球金融危机后，人们对于金融投机客们的痛恨到达顶点，所有的媒体和政客都对金融体系提出了严厉的批评。比如前法国总统萨科奇就说：“金融体系本质上是一个不负责任的，不道德的体系。”前英国首相布莱尔也说：“金融体系偏离了本质，而且它也无法回归本真了。” 结合对这周课程的理解，如果让你点评萨科奇和布莱尔的话，你会怎么说？</p>\n</blockquote>\n<p>金融是一个工具，没有好坏属性，关键在于如何使用。但是金融知识必须要学，可以怀着一颗不作恶的心，但是也要能知道别人如何思考和运作以保护自己，就像一个优秀的侦探一样。</p>\n<h1 id=\"课程原文\"><a href=\"#课程原文\" class=\"headerlink\" title=\"课程原文\"></a>课程原文</h1><img src=\"/posts/香帅的北大金融学课/【香帅】004-构建完整的金融世界观/2018-10-10-13-03-50.png\" title=\"[blog.ruanxinyu.cn]\">","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ruanxinyu.github.io/categories/读书笔记/"}],"tags":[{"name":"经济","slug":"经济","permalink":"http://ruanxinyu.github.io/tags/经济/"},{"name":"香帅的北大金融学课","slug":"香帅的北大金融学课","permalink":"http://ruanxinyu.github.io/tags/香帅的北大金融学课/"}]},{"title":"【香帅】003.现代人如何抵御风险","slug":"香帅的北大金融学课/【香帅】003-现代人如何抵御风险","date":"un22fin22","updated":"un33fin33","comments":true,"path":"posts/香帅的北大金融学课/【香帅】003-现代人如何抵御风险/","link":"","permalink":"http://ruanxinyu.github.io/posts/香帅的北大金融学课/【香帅】003-现代人如何抵御风险/","excerpt":"","keywords":"","text":"语句摘录古代社会主要依赖于家庭、宗族来实现风险共担，首先与血缘和地域。 金融是迄今人类社会能最有效实现跨区域、跨时间、大规模“风险分担”的一个机制: 1．保险能够帮助个体将风险转移、分散到社会群体中间，提高了我们人类的独立性和安全感；1．股票的“利益共享，风险共担”的功能帮助荷兰开辟了强大的海上帝国；1．风投和创投分担了创业创新的风险，拓展了人类经济活动的范围和能力。 课后习题 假设说你现在也想创业，打算开个公司，在融资方式上，你有两种选择，第一种是到处借钱或者拿抵押品到银行贷一笔钱出来，第二种是找几个志同道合的人组成一个合伙公司，去寻求风投和创投的帮助。这两种方法你愿意选哪一个？哪一个对你更加现实？这两种方法对你未来的生产、经营会产生什么样的影响？ 第一种是债权融资，期限短，金额小，还款时压力比较大；第二种时股权融资，没有还款压力。所以需要看创业的内容，所需的资金，规模，借债时长和盈利模式等，没有哪一种模式更好 课程原文","raw":"---\ntitle: 【香帅】003.现代人如何抵御风险\ntags:\n  - 经济\n  - 香帅的北大金融学课\ncategories: 读书笔记\ndate: 2018-10-09 21:59:39\n---\n\n# 语句摘录\n\n古代社会主要依赖于家庭、宗族来实现风险共担，首先与血缘和地域。\n\n金融是迄今人类社会能最有效实现跨区域、跨时间、大规模“风险分担”的一个机制:\n\n1．`保险`能够帮助个体将风险转移、分散到社会群体中间，提高了我们人类的独立性和安全感；\n1．`股票`的“利益共享，风险共担”的功能帮助荷兰开辟了强大的海上帝国；\n1．`风投和创投`分担了创业创新的风险，拓展了人类经济活动的范围和能力。\n\n# 课后习题\n\n> 假设说你现在也想创业，打算开个公司，在融资方式上，你有两种选择，第一种是到处借钱或者拿抵押品到银行贷一笔钱出来，第二种是找几个志同道合的人组成一个合伙公司，去寻求风投和创投的帮助。这两种方法你愿意选哪一个？哪一个对你更加现实？这两种方法对你未来的生产、经营会产生什么样的影响？\n\n第一种是债权融资，期限短，金额小，还款时压力比较大；第二种时股权融资，没有还款压力。所以需要看创业的内容，所需的资金，规模，借债时长和盈利模式等，没有哪一种模式更好\n\n# 课程原文\n\n{% asset_img 2018-10-09-22-00-43.png [blog.ruanxinyu.cn] %}","content":"<h1 id=\"语句摘录\"><a href=\"#语句摘录\" class=\"headerlink\" title=\"语句摘录\"></a>语句摘录</h1><p>古代社会主要依赖于家庭、宗族来实现风险共担，首先与血缘和地域。</p>\n<p>金融是迄今人类社会能最有效实现跨区域、跨时间、大规模“风险分担”的一个机制:</p>\n<p>1．<code>保险</code>能够帮助个体将风险转移、分散到社会群体中间，提高了我们人类的独立性和安全感；<br>1．<code>股票</code>的“利益共享，风险共担”的功能帮助荷兰开辟了强大的海上帝国；<br>1．<code>风投和创投</code>分担了创业创新的风险，拓展了人类经济活动的范围和能力。</p>\n<h1 id=\"课后习题\"><a href=\"#课后习题\" class=\"headerlink\" title=\"课后习题\"></a>课后习题</h1><blockquote>\n<p>假设说你现在也想创业，打算开个公司，在融资方式上，你有两种选择，第一种是到处借钱或者拿抵押品到银行贷一笔钱出来，第二种是找几个志同道合的人组成一个合伙公司，去寻求风投和创投的帮助。这两种方法你愿意选哪一个？哪一个对你更加现实？这两种方法对你未来的生产、经营会产生什么样的影响？</p>\n</blockquote>\n<p>第一种是债权融资，期限短，金额小，还款时压力比较大；第二种时股权融资，没有还款压力。所以需要看创业的内容，所需的资金，规模，借债时长和盈利模式等，没有哪一种模式更好</p>\n<h1 id=\"课程原文\"><a href=\"#课程原文\" class=\"headerlink\" title=\"课程原文\"></a>课程原文</h1><img src=\"/posts/香帅的北大金融学课/【香帅】003-现代人如何抵御风险/2018-10-09-22-00-43.png\" title=\"[blog.ruanxinyu.cn]\">","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ruanxinyu.github.io/categories/读书笔记/"}],"tags":[{"name":"经济","slug":"经济","permalink":"http://ruanxinyu.github.io/tags/经济/"},{"name":"香帅的北大金融学课","slug":"香帅的北大金融学课","permalink":"http://ruanxinyu.github.io/tags/香帅的北大金融学课/"}]},{"title":"【香帅】002.南北战争中的第二战场","slug":"香帅的北大金融学课/【香帅】002-南北战争中的第二战场","date":"un22fin22","updated":"un33fin33","comments":true,"path":"posts/香帅的北大金融学课/【香帅】002-南北战争中的第二战场/","link":"","permalink":"http://ruanxinyu.github.io/posts/香帅的北大金融学课/【香帅】002-南北战争中的第二战场/","excerpt":"","keywords":"","text":"语句摘录资金的集聚，越是这些伟大的事物，越是要求大资金的快速集聚和有效配置，而这种功能，只有金融能够实现。 南北战争的胜负手居然是“债券发行”，北方买债券是一个“爱国+投资”的双赢举动：一方面你可以享受国债6%的利息，而且利息是免税的，另一方面，只要北方取得胜利，这个债券就会大涨价，你可以分享国家的胜利果实。南方为了筹集战争资金，他们在一年内印刷发行了17亿的钞票，这些钞票“哗”地涌到了南方的市场上，南方物价飞涨，整个南方的经济就迅速地崩溃了。 北方这到底是一个骗局还是一个双赢呢，为何银行家不相信这一套，但是普通大众却相信呢？感觉银行家与普通大众对风险的认识不一样，另外金额也不一样。 国债将国家与民众的利益相关联，但是印钞票却是直接剥夺，民众直观官爵没有任何好处，对政府的信任丢失 纽约繁荣的背后也是金融“资金集聚”的力量，采取分期发债的方式，可以分期得到资金，可以通过收益刺激投资者的热情。 也体现了目标的分解，不要完美主义，非得一口一个胖子 划重点 南北战争中，北方取胜的关键在于资金集聚能力，北方的债券发行功不可没； 2. 纽约的崛起得益于伊利运河，而伊利运河这种大工程是主要靠债券发行集聚的资金； 3. 银行、债券、股票，所有的金融工具都在帮助人类将散落的、点状的资金累积起来，投入到最需要资金的地方。个人、企业、战争、一个城市的兴衰，背后其实都是金融的力量，它帮助我们突破了时间和地域的限制，进行快速有效的资金积聚、从而实现了目标。 课后习题 试着从你身边的朋友里面，找出那个资金聚集能力最强的人，然后总结一下，他利用了哪些金融工具？他具有一些怎样的特征呢？ 膜拜单车等共享单车的押金就是聚集资金的方式，安居客等长租的租房贷款就是另外一种基金聚集的方式 课程原文","raw":"---\ntitle: 【香帅】002.南北战争中的第二战场\ntags:\n  - 经济\n  - 香帅的北大金融学课\ncategories: 读书笔记\ndate: 2018-10-09 21:26:06\n---\n\n# 语句摘录\n\n资金的集聚，越是这些伟大的事物，越是要求大资金的快速集聚和有效配置，而这种功能，只有金融能够实现。\n\n南北战争的胜负手居然是“债券发行”，北方买债券是一个“爱国+投资”的双赢举动：一方面你可以享受国债6%的利息，而且利息是免税的，另一方面，只要北方取得胜利，这个债券就会大涨价，你可以分享国家的胜利果实。南方为了筹集战争资金，他们在一年内印刷发行了17亿的钞票，这些钞票“哗”地涌到了南方的市场上，南方物价飞涨，整个南方的经济就迅速地崩溃了。\n> 北方这到底是一个骗局还是一个双赢呢，为何银行家不相信这一套，但是普通大众却相信呢？感觉银行家与普通大众对风险的认识不一样，另外金额也不一样。\n>\n> 国债将国家与民众的利益相关联，但是印钞票却是直接剥夺，民众直观官爵没有任何好处，对政府的信任丢失\n\n纽约繁荣的背后也是金融“资金集聚”的力量，采取分期发债的方式，可以分期得到资金，可以通过收益刺激投资者的热情。\n> 也体现了目标的分解，不要完美主义，非得一口一个胖子\n\n# 划重点\n\n> 1. 南北战争中，北方取胜的关键在于资金集聚能力，北方的债券发行功不可没； 2. 纽约的崛起得益于伊利运河，而伊利运河这种大工程是主要靠债券发行集聚的资金； 3. 银行、债券、股票，所有的金融工具都在帮助人类将散落的、点状的资金累积起来，投入到最需要资金的地方。个人、企业、战争、一个城市的兴衰，背后其实都是金融的力量，它帮助我们突破了时间和地域的限制，进行快速有效的资金积聚、从而实现了目标。\n\n# 课后习题\n\n> 试着从你身边的朋友里面，找出那个资金聚集能力最强的人，然后总结一下，他利用了哪些金融工具？他具有一些怎样的特征呢？\n\n膜拜单车等共享单车的押金就是聚集资金的方式，安居客等长租的租房贷款就是另外一种基金聚集的方式\n\n# 课程原文\n\n{% asset_img 2018-10-09-21-26-31.png [blog.ruanxinyu.cn] %}","content":"<h1 id=\"语句摘录\"><a href=\"#语句摘录\" class=\"headerlink\" title=\"语句摘录\"></a>语句摘录</h1><p>资金的集聚，越是这些伟大的事物，越是要求大资金的快速集聚和有效配置，而这种功能，只有金融能够实现。</p>\n<p>南北战争的胜负手居然是“债券发行”，北方买债券是一个“爱国+投资”的双赢举动：一方面你可以享受国债6%的利息，而且利息是免税的，另一方面，只要北方取得胜利，这个债券就会大涨价，你可以分享国家的胜利果实。南方为了筹集战争资金，他们在一年内印刷发行了17亿的钞票，这些钞票“哗”地涌到了南方的市场上，南方物价飞涨，整个南方的经济就迅速地崩溃了。</p>\n<blockquote>\n<p>北方这到底是一个骗局还是一个双赢呢，为何银行家不相信这一套，但是普通大众却相信呢？感觉银行家与普通大众对风险的认识不一样，另外金额也不一样。</p>\n<p>国债将国家与民众的利益相关联，但是印钞票却是直接剥夺，民众直观官爵没有任何好处，对政府的信任丢失</p>\n</blockquote>\n<p>纽约繁荣的背后也是金融“资金集聚”的力量，采取分期发债的方式，可以分期得到资金，可以通过收益刺激投资者的热情。</p>\n<blockquote>\n<p>也体现了目标的分解，不要完美主义，非得一口一个胖子</p>\n</blockquote>\n<h1 id=\"划重点\"><a href=\"#划重点\" class=\"headerlink\" title=\"划重点\"></a>划重点</h1><blockquote>\n<ol>\n<li>南北战争中，北方取胜的关键在于资金集聚能力，北方的债券发行功不可没； 2. 纽约的崛起得益于伊利运河，而伊利运河这种大工程是主要靠债券发行集聚的资金； 3. 银行、债券、股票，所有的金融工具都在帮助人类将散落的、点状的资金累积起来，投入到最需要资金的地方。个人、企业、战争、一个城市的兴衰，背后其实都是金融的力量，它帮助我们突破了时间和地域的限制，进行快速有效的资金积聚、从而实现了目标。</li>\n</ol>\n</blockquote>\n<h1 id=\"课后习题\"><a href=\"#课后习题\" class=\"headerlink\" title=\"课后习题\"></a>课后习题</h1><blockquote>\n<p>试着从你身边的朋友里面，找出那个资金聚集能力最强的人，然后总结一下，他利用了哪些金融工具？他具有一些怎样的特征呢？</p>\n</blockquote>\n<p>膜拜单车等共享单车的押金就是聚集资金的方式，安居客等长租的租房贷款就是另外一种基金聚集的方式</p>\n<h1 id=\"课程原文\"><a href=\"#课程原文\" class=\"headerlink\" title=\"课程原文\"></a>课程原文</h1><img src=\"/posts/香帅的北大金融学课/【香帅】002-南北战争中的第二战场/2018-10-09-21-26-31.png\" title=\"[blog.ruanxinyu.cn]\">","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ruanxinyu.github.io/categories/读书笔记/"}],"tags":[{"name":"经济","slug":"经济","permalink":"http://ruanxinyu.github.io/tags/经济/"},{"name":"香帅的北大金融学课","slug":"香帅的北大金融学课","permalink":"http://ruanxinyu.github.io/tags/香帅的北大金融学课/"}]},{"title":"【香帅】001.一万美金赠品里的秘密","slug":"香帅的北大金融学课/【香帅】001-一万美金赠品里的秘密","date":"un11fin11","updated":"un33fin33","comments":true,"path":"posts/香帅的北大金融学课/【香帅】001-一万美金赠品里的秘密/","link":"","permalink":"http://ruanxinyu.github.io/posts/香帅的北大金融学课/【香帅】001-一万美金赠品里的秘密/","excerpt":"","keywords":"","text":"语句摘录买一辆车，送一张面值１万美金的30年期的美国国债。按照90年代中期平均8％左右的国债利率算，折算到30年后，这个面值１万美金的债券只剩下994美金。 复利在金钱的升值和贬值上效果是类似的，通货膨胀会很大程度稀释我们的财富，我们需要防止自身财富的贬值。 货币的时间价值，在金融里，时间就是金钱。货币的时间价值在金融里边是可以度量，计算，和用来支付的。 财富数值的变化，其实是金融工具把我们拥有的相同时间（未来十年）进行了深度的加工，都化成了完完全全不一样的时间价值。 金融不仅是对时间做加工，也是对风险的加工，因为价值在未来存在不确定性，而这种不确定性衍生出很多金融产品。 你可以将“时间”看作一种原料，这些金融工具就干了一件什么事呢？它把这种时间维度里面的风险全部给曝露了出来，然后对这种原料进行加工，做成不同的产品。换一句话说，用金融术语来说，金融就是为时间定价，而我们这些购买金融产品，做出金融决策的人，就是购买了不同的未来价值。 金融技术就像我们建造的时光机器……它拓展了我们想象和计算未来的能力，然后塑造了一个关于可量化、可交易的时间维度，让我们人类越来越变成时间的生物。 划重点 时间是有价值的。 金融工具对我们的时间进行了深度的加工，将我们拥有的未来转化成了完全不一样的价值。 从这个角度上看，金融就是一个一个的时光机器，它帮助我们将时间转化成财富，不同的金融工具、金融决策会改变个体的命运。 课后习题 想一想，在过去的十年里面，你做过什么样的金融决策吗？再回想一下，这些金融决策在过去的十年里面，是不是改变了你的时间价值呢？ 父母10年前在银行存的钱，虽然存在一定的利息收入，但是因为利息太低，远远跟不上通货膨胀，所以造成财富贬值，每每想起来父母辛辛苦苦赚的钱就这样被稀释就很心疼他们。 课程原文","raw":"---\ntitle: 【香帅】001.一万美金赠品里的秘密\ntags:\n  - 经济\n  - 香帅的北大金融学课\ncategories: 读书笔记\ndate: 2018-10-08 13:06:01\n---\n\n# 语句摘录\n\n买一辆车，送一张面值１万美金的30年期的美国国债。按照90年代中期平均8％左右的国债利率算，折算到30年后，这个面值１万美金的债券只剩下994美金。\n> 复利在金钱的升值和贬值上效果是类似的，通货膨胀会很大程度稀释我们的财富，我们需要防止自身财富的贬值。\n\n货币的时间价值，在金融里，时间就是金钱。货币的时间价值在金融里边是可以度量，计算，和用来支付的。\n\n财富数值的变化，其实是金融工具把我们拥有的相同时间（未来十年）进行了深度的加工，都化成了完完全全不一样的时间价值。\n> 金融不仅是对时间做加工，也是对风险的加工，因为价值在未来存在不确定性，而这种不确定性衍生出很多金融产品。\n\n你可以将“时间”看作一种原料，这些金融工具就干了一件什么事呢？它把这种时间维度里面的风险全部给曝露了出来，然后对这种原料进行加工，做成不同的产品。换一句话说，用金融术语来说，`金融就是为时间定价，而我们这些购买金融产品，做出金融决策的人，就是购买了不同的未来价值。`\n\n金融技术就像我们建造的时光机器……它拓展了我们想象和计算未来的能力，然后塑造了一个关于可量化、可交易的时间维度，让我们人类越来越变成时间的生物。\n\n# 划重点\n\n> 时间是有价值的。 金融工具对我们的时间进行了深度的加工，将我们拥有的未来转化成了完全不一样的价值。 从这个角度上看，金融就是一个一个的时光机器，它帮助我们将时间转化成财富，不同的金融工具、金融决策会改变个体的命运。\n\n# 课后习题\n\n> 想一想，在过去的十年里面，你做过什么样的金融决策吗？再回想一下，这些金融决策在过去的十年里面，是不是改变了你的时间价值呢？\n\n父母10年前在银行存的钱，虽然存在一定的利息收入，但是因为利息太低，远远跟不上通货膨胀，所以造成财富贬值，每每想起来父母辛辛苦苦赚的钱就这样被稀释就很心疼他们。\n\n# 课程原文\n\n{% asset_img 2018-10-09-20-26-41.png [blog.ruanxinyu.cn] %}","content":"<h1 id=\"语句摘录\"><a href=\"#语句摘录\" class=\"headerlink\" title=\"语句摘录\"></a>语句摘录</h1><p>买一辆车，送一张面值１万美金的30年期的美国国债。按照90年代中期平均8％左右的国债利率算，折算到30年后，这个面值１万美金的债券只剩下994美金。</p>\n<blockquote>\n<p>复利在金钱的升值和贬值上效果是类似的，通货膨胀会很大程度稀释我们的财富，我们需要防止自身财富的贬值。</p>\n</blockquote>\n<p>货币的时间价值，在金融里，时间就是金钱。货币的时间价值在金融里边是可以度量，计算，和用来支付的。</p>\n<p>财富数值的变化，其实是金融工具把我们拥有的相同时间（未来十年）进行了深度的加工，都化成了完完全全不一样的时间价值。</p>\n<blockquote>\n<p>金融不仅是对时间做加工，也是对风险的加工，因为价值在未来存在不确定性，而这种不确定性衍生出很多金融产品。</p>\n</blockquote>\n<p>你可以将“时间”看作一种原料，这些金融工具就干了一件什么事呢？它把这种时间维度里面的风险全部给曝露了出来，然后对这种原料进行加工，做成不同的产品。换一句话说，用金融术语来说，<code>金融就是为时间定价，而我们这些购买金融产品，做出金融决策的人，就是购买了不同的未来价值。</code></p>\n<p>金融技术就像我们建造的时光机器……它拓展了我们想象和计算未来的能力，然后塑造了一个关于可量化、可交易的时间维度，让我们人类越来越变成时间的生物。</p>\n<h1 id=\"划重点\"><a href=\"#划重点\" class=\"headerlink\" title=\"划重点\"></a>划重点</h1><blockquote>\n<p>时间是有价值的。 金融工具对我们的时间进行了深度的加工，将我们拥有的未来转化成了完全不一样的价值。 从这个角度上看，金融就是一个一个的时光机器，它帮助我们将时间转化成财富，不同的金融工具、金融决策会改变个体的命运。</p>\n</blockquote>\n<h1 id=\"课后习题\"><a href=\"#课后习题\" class=\"headerlink\" title=\"课后习题\"></a>课后习题</h1><blockquote>\n<p>想一想，在过去的十年里面，你做过什么样的金融决策吗？再回想一下，这些金融决策在过去的十年里面，是不是改变了你的时间价值呢？</p>\n</blockquote>\n<p>父母10年前在银行存的钱，虽然存在一定的利息收入，但是因为利息太低，远远跟不上通货膨胀，所以造成财富贬值，每每想起来父母辛辛苦苦赚的钱就这样被稀释就很心疼他们。</p>\n<h1 id=\"课程原文\"><a href=\"#课程原文\" class=\"headerlink\" title=\"课程原文\"></a>课程原文</h1><img src=\"/posts/香帅的北大金融学课/【香帅】001-一万美金赠品里的秘密/2018-10-09-20-26-41.png\" title=\"[blog.ruanxinyu.cn]\">","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ruanxinyu.github.io/categories/读书笔记/"}],"tags":[{"name":"经济","slug":"经济","permalink":"http://ruanxinyu.github.io/tags/经济/"},{"name":"香帅的北大金融学课","slug":"香帅的北大金融学课","permalink":"http://ruanxinyu.github.io/tags/香帅的北大金融学课/"}]},{"title":"AngularJS学习记录-1","slug":"AngularJS学习记录-1","date":"un00fin00","updated":"un00fin00","comments":true,"path":"posts/AngularJS学习记录-1/","link":"","permalink":"http://ruanxinyu.github.io/posts/AngularJS学习记录-1/","excerpt":"","keywords":"","text":"前言AngularJS的学习地址为：https://angular.cns/guide/quickstart ng命令介绍 安装@angular/cli: npm install -g @angular/cli 创建工程： ng new angular-tour-of-heroes 开启调试： ng serve --open 创建组件： ng generate component xxx 创建服务： ng generate service xxx 创建路由：ng generate module xxx --flat --module=app 创建类：ng generate class hero 核心知识架构Angular 的基本构造块是 NgModule，它为组件提供了编译的上下文环境。Angular包含一个根模块，可以包含其他模块，模块的加载是懒加载的。 组件定义视图，同时使用服务。组件和服务都是简单的类，这些类使用装饰器来标出它们的类型，并提供元数据以告知 Angular 该如何使用它们。 模板会把 HTML 和 Angular 的标记（markup）组合起来，这些标记可以在 HTML 元素显示出来之前修改它们。 模板中的指令会提供程序逻辑，而绑定标记会把你应用中的数据和 DOM 连接在一起。包含事件绑定和属性绑定，并且支持双星绑定和管道等功能。 对于与特定视图无关并希望跨组件共享的数据或逻辑，可以创建服务类。 服务类的定义通常紧跟在 “@Injectable” 装饰器之后。该装饰器提供的元数据可以让你的服务作为依赖被注入到客户组件中。 Angular 的 Router 模块提供了一个服务，它可以让你定义在应用的各个不同状态和视图层次结构之间导航时要使用的路径。如果路由器认为当前的应用状态需要某些特定的功能，而定义此功能的模块尚未加载，路由器就会按需惰性加载此模块。 模块NgModule 是一个带有 @NgModule 装饰器的类。@NgModule 装饰器是一个函数，它接受一个元数据对象，该对象的属性用来描述这个模块。其中最重要的属性如下。 declarations（可声明对象表） —— 那些属于本 NgModule 的组件、指令、管道。 exports（导出表） —— 那些能在其它模块的组件模板中使用的可声明对象的子集。 imports（导入表） —— 那些导出了本模块中的组件模板所需的类的其它模块。 providers —— 本模块向全局服务中贡献的那些服务的创建器。 这些服务能被本应用中的任何部分使用。（你也可以在组件级别指定服务提供商，这通常是首选方式。） bootstrap —— 应用的主视图，称为根组件。它是应用中所有其它视图的宿主。只有根模块才应该设置这个 bootstrap 属性。 12345678910import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';@NgModule(&#123; imports: [ BrowserModule ], providers: [ Logger ], declarations: [ AppComponent ], exports: [ AppComponent ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125; 组件组件通过constructor来提供依赖注入，常见的元数据如下： selector：是一个 CSS 选择器，它会告诉 Angular，一旦在模板 HTML 中找到了这个选择器对应的标签，就创建并插入该组件的一个实例。 templateUrl：该组件的 HTML 模板文件相对于这个组件文件的地址。 providers: 是当前组件所需的依赖注入提供商的一个数组 1234567@Component(&#123; selector: 'app-hero-list', templateUrl: './hero-list.component.html', providers: [ HeroService ]&#125;)export class HeroListComponent implements OnInit &#123;&#125; 指令：结构型指令和属性型指令。 服务与依赖注入服务是一个广义的概念，它包括应用所需的任何值、函数或特性。狭义的服务是一个明确定义了用途的类。它应该做一些具体的事，并做好。要把一个类定义为服务，就要用 @Injectable 装饰器来提供元数据，以便让 Angular 可以把它作为依赖注入到组件中。通过构造函数进行注入 Angular 把组件和服务区分开，以提高模块性和复用性。 通过把组件中和视图有关的功能与其他类型的处理分离开，你可以让组件类更加精简、高效。 理想情况下，组件的工作只管用户体验，而不用顾及其它。 它应该提供用于数据绑定的属性和方法，以便作为视图（由模板渲染）和应用逻辑（通常包含一些模型的概念）的中介者。 组件不应该定义任何诸如从服务器获取数据、验证用户输入或直接往控制台中写日志等工作。 而要把这些任务委托给各种服务。通过把各种处理任务定义到可注入的服务类中，你可以让它被任何组件使用。 通过在不同的环境中注入同一种服务的不同提供商，你还可以让你的应用更具适应性。 默认情况下，Angular CLI 的 ng generate service 命令会在 @Injectable 装饰器中提供元数据，把它注册到根注入器中。本教程就用这种方法注册了 HeroService 的提供商 当你使用特定的 NgModule 注册提供商时，该服务的同一个实例将会对该 NgModule 中的所有组件可用。要想在这一层注册，请用 @NgModule 装饰器中的 providers 属性 当你在组件级注册提供商时，你会为该组件的每一个新实例提供该服务的一个新实例。 要在组件级注册，就要在 @Component 元数据的 providers 属性中注册服务提供商 组件与模板显示数据你可以在两种地方存放组件模板。 你可以使用 template 属性把它定义为内联的，或者把模板定义在一个独立的 HTML 文件中， 再通过 @Component 装饰器中的 templateUrl 属性， 在组件元数据中把它链接到组件。 默认情况下，Angular CLI 生成组件时会带有模板文件，你可以通过参数覆盖它：ng generate component hero -it 显示属性。 *ngFor 是 Angular 的“迭代”指令 *ngIf 指令会根据一个布尔条件来显示或移除一个元素 模板语法JavaScript 中那些具有或可能引发副作用的表达式是被禁止的，包括： 赋值 (=, +=, -=, ...) new 运算符 使用 ; 或 , 的链式表达式 自增和自减运算符：++ 和-- 和 JavaScript 语 法的其它显著不同包括： 不支持位运算 | 和 &amp; 具有新的模板表达式运算符，比如 |、?. 和 !。 表达式中的上下文变量是由模板变量、指令的上下文变量（如果有）和组件的成员叠加而成的。 如果你要引用的变量名存在于一个以上的命名空间中，那么，模板变量是最优先的，其次是指令的上下文变量，最后是组件的成员。 模板表达式不能引用全局命名空间中的任何东西，比如 window 或 document。它们也不能调用 console.log 或 Math.max。 它们只能引用表达式上下文中的成员。 模板表达式能成就或毁掉一个应用。请遵循下列指南：没有可见的副作用,执行迅速,非常简单,幂等性 模板语句用来响应由绑定目标（如 HTML 元素、组件或指令）触发的事件。 模板语句将在事件绑定一节看到，它出现在 = 号右侧的引号中，就像这样：(event)=”statement”。 绑定方式： 属性绑定：[target]=&quot;expression&quot; 事件绑定：(target)=&quot;statement&quot; 双向绑定：[(target)]=&quot;expression&quot; css类绑定：[class.special]=&quot;isSpecial&quot; 样式绑定：[style.color]=&quot;isSpecial ? &#39;red&#39; : &#39;green&#39;&quot; 在多数情况下，插值表达式是更方便的备选项。 实际上，在渲染视图之前，Angular 把这些插值表达式翻译成相应的属性绑定。 在新版的 Angular 中不需要那么多指令。 使用更强大、更富有表现力的 Angular 绑定系统，其实可以达到同样的效果。 外部组件应该只能绑定到组件的公共（允许绑定） API 上，Angular 要求你显式声明那些 API。 它让你可以自己决定哪些属性是可以被外部组件绑定的。进行数据绑定的属性都带有 @Input() 和 @Output() 装饰器。 好东西: Angular 的安全导航操作符?. 是一种流畅而便利的方式，用来保护出现在属性路径中 null 和 undefined 值。 下例中，当 currentHero 为空时，保护视图渲染器，让它免于失败。 非空断言操作符! 类型转换函数 $any 生命钩子执行顺序 组件交互https://angular.cn/guide/component-interaction 通过输入型绑定把数据从父组件传到子组件 通过 setter 截听输入属性值的变化 通过ngOnChanges()来截听输入属性值的变化 父组件监听子组件的事件 父组件与子组件通过本地变量互动 父组件调用@ViewChild() 父组件和子组件通过服务来通讯 组件样式 使用 :host 伪类选择器，用来选择组件宿主元素中的元素 使用 :host-context() 伪类选择器。它也以类似 :host() 形式使用。它在当前组件宿主元素的祖先节点中查找 CSS 类， 直到文档的根节点为止 可以在组件的 HTML 模板中写 &lt;link&gt; 标签 可以利用标准的 CSS @import 规则来把其它 CSS 文件导入到 CSS 文件中。 如果使用 CLI 进行构建，那么你可以用 sass、less 或 stylus 来编写样式，并使用相应的扩展名（.scss、.less、.styl）把它们指定到 @Component.styleUrls 元数据中。 表单用户输入https://angular.cn/guide/user-input 绑定到用户输入事件&lt;button (click)=&quot;onClickMe()&quot;&gt;Click me!&lt;/button&gt; 通过 $event 对象取得用户输入&lt;input (keyup)=&quot;onKey($event)&quot;&gt; 从一个模板引用变量中获得用户输入,在标识符前加上井号 (#) 就能声明一个模板引用变量，&lt;input #box (keyup)=&quot;0&quot;&gt; &lt;p&gt;&lt;/p&gt; 按键事件过滤（通过 key.enter）: &lt;input #box (keyup.enter)=&quot;onEnter(box.value)&quot;&gt; &lt;p&gt;&lt;/p&gt;","raw":"---\ntitle: AngularJS学习记录-1\ntags: 学习记录\ncategories: 学习记录\ndate: 2018-10-07 11:50:16\n---\n\n# 前言\n\nAngularJS的学习地址为：[https://angular.cns/guide/quickstart](https://angular.cn/guide/quickstart)\n\n# ng命令介绍\n\n1. 安装@angular/cli: `npm install -g @angular/cli`\n1. 创建工程： `ng new angular-tour-of-heroes`\n1. 开启调试： `ng serve --open`\n1. 创建组件： `ng generate component xxx`\n1. 创建服务： `ng generate service xxx`\n1. 创建路由：`ng generate module xxx --flat --module=app`\n1. 创建类：`ng generate class hero`\n\n\n# 核心知识\n\n##  架构\n\nAngular 的基本构造块是 NgModule，它为组件提供了编译的上下文环境。Angular包含一个根模块，可以包含其他模块，模块的加载是懒加载的。\n\n组件定义视图，同时使用服务。组件和服务都是简单的类，这些类使用装饰器来标出它们的类型，并提供元数据以告知 Angular 该如何使用它们。\n\n模板会把 HTML 和 Angular 的标记（markup）组合起来，这些标记可以在 HTML 元素显示出来之前修改它们。 模板中的指令会提供程序逻辑，而绑定标记会把你应用中的数据和 DOM 连接在一起。包含事件绑定和属性绑定，并且支持双星绑定和管道等功能。\n\n对于与特定视图无关并希望跨组件共享的数据或逻辑，可以创建服务类。 服务类的定义通常紧跟在 “@Injectable” 装饰器之后。该装饰器提供的元数据可以让你的服务作为依赖被注入到客户组件中。\n\nAngular 的 Router 模块提供了一个服务，它可以让你定义在应用的各个不同状态和视图层次结构之间导航时要使用的路径。如果路由器认为当前的应用状态需要某些特定的功能，而定义此功能的模块尚未加载，路由器就会按需惰性加载此模块。\n\n{% asset_img 2018-10-07-20-56-50.png [blog.ruanxinyu.cn] %}\n\n## 模块\n\nNgModule 是一个带有 @NgModule 装饰器的类。@NgModule 装饰器是一个函数，它接受一个元数据对象，该对象的属性用来描述这个模块。其中最重要的属性如下。\n\n+ **declarations（可声明对象表）** —— 那些属于本 NgModule 的组件、指令、管道。\n+ **exports（导出表）** —— 那些能在其它模块的组件模板中使用的可声明对象的子集。\n+ **imports（导入表）** —— 那些导出了本模块中的组件模板所需的类的其它模块。\n+ **providers** —— 本模块向全局服务中贡献的那些服务的创建器。 这些服务能被本应用中的任何部分使用。（你也可以在组件级别指定服务提供商，这通常是首选方式。）\n+ **bootstrap** —— 应用的主视图，称为根组件。它是应用中所有其它视图的宿主。只有根模块才应该设置这个 bootstrap 属性。\n\n```ts\nimport { NgModule }      from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\n@NgModule({\n  imports:      [ BrowserModule ],\n  providers:    [ Logger ],\n  declarations: [ AppComponent ],\n  exports:      [ AppComponent ],\n  bootstrap:    [ AppComponent ]\n})\nexport class AppModule { }\n```\n\n## 组件\n\n组件通过`constructor`来提供依赖注入，常见的元数据如下：\n\n+ **selector：**是一个 CSS 选择器，它会告诉 Angular，一旦在模板 HTML 中找到了这个选择器对应的标签，就创建并插入该组件的一个实例。 \n+ **templateUrl：**该组件的 HTML 模板文件相对于这个组件文件的地址。\n+ **providers:** 是当前组件所需的依赖注入提供商的一个数组\n\n```ts\n@Component({\n  selector:    'app-hero-list',\n  templateUrl: './hero-list.component.html',\n  providers:  [ HeroService ]\n})\nexport class HeroListComponent implements OnInit {\n}\n```\n\n指令：结构型指令和属性型指令。\n\n## 服务与依赖注入\n\n服务是一个广义的概念，它包括应用所需的任何值、函数或特性。狭义的服务是一个明确定义了用途的类。它应该做一些具体的事，并做好。要把一个类定义为服务，就要用 @Injectable 装饰器来提供元数据，以便让 Angular 可以把它作为依赖注入到组件中。通过构造函数进行注入\n\nAngular 把组件和服务区分开，以提高模块性和复用性。\n\n+ 通过把组件中和视图有关的功能与其他类型的处理分离开，你可以让组件类更加精简、高效。 理想情况下，组件的工作只管用户体验，而不用顾及其它。 它应该提供用于数据绑定的属性和方法，以便作为视图（由模板渲染）和应用逻辑（通常包含一些模型的概念）的中介者。\n+ 组件不应该定义任何诸如从服务器获取数据、验证用户输入或直接往控制台中写日志等工作。 而要把这些任务委托给各种服务。通过把各种处理任务定义到可注入的服务类中，你可以让它被任何组件使用。 通过在不同的环境中注入同一种服务的不同提供商，你还可以让你的应用更具适应性。\n\n默认情况下，Angular CLI 的 ng generate service 命令会在 @Injectable 装饰器中提供元数据，把它注册到根注入器中。本教程就用这种方法注册了 HeroService 的提供商\n\n当你使用特定的 NgModule 注册提供商时，该服务的同一个实例将会对该 NgModule 中的所有组件可用。要想在这一层注册，请用 @NgModule 装饰器中的 providers 属性\n\n当你在组件级注册提供商时，你会为该组件的每一个新实例提供该服务的一个新实例。 要在组件级注册，就要在 @Component 元数据的 providers 属性中注册服务提供商\n\n# 组件与模板\n\n## 显示数据\n\n你可以在两种地方存放组件模板。 你可以使用 template 属性把它定义为内联的，或者把模板定义在一个独立的 HTML 文件中， 再通过 @Component 装饰器中的 templateUrl 属性， 在组件元数据中把它链接到组件。\n\n默认情况下，Angular CLI 生成组件时会带有模板文件，你可以通过参数覆盖它：`ng generate component hero -it`\n\n+ `{{myHero}}`显示属性。\n+ `*ngFor` 是 Angular 的“迭代”指令\n+ `*ngIf` 指令会根据一个布尔条件来显示或移除一个元素\n\n## 模板语法\n\nJavaScript 中那些具有或可能引发副作用的表达式是被禁止的，包括：\n\n+ 赋值 `(=, +=, -=, ...)`\n+ `new` 运算符\n+ 使用 `;` 或 `,` 的链式表达式\n+ 自增和自减运算符：`++` 和`--`\n\n和 JavaScript 语 法的其它显著不同包括：\n\n+ 不支持位运算 `|` 和 `&`\n+ 具有新的模板表达式运算符，比如 `|、?. 和 !`。\n\n表达式中的上下文变量是由模板变量、指令的上下文变量（如果有）和组件的成员叠加而成的。 如果你要引用的变量名存在于一个以上的命名空间中，那么，模板变量是最优先的，其次是指令的上下文变量，最后是组件的成员。\n\n模板表达式不能引用全局命名空间中的任何东西，比如 window 或 document。它们也不能调用 console.log 或 Math.max。 它们只能引用表达式上下文中的成员。\n\n模板表达式能成就或毁掉一个应用。请遵循下列指南：`没有可见的副作用`,`执行迅速`,`非常简单`,`幂等性`\n\n模板语句用来响应由绑定目标（如 HTML 元素、组件或指令）触发的事件。 模板语句将在事件绑定一节看到，它出现在 = 号右侧的引号中，就像这样：(event)=\"statement\"。\n\n绑定方式：\n\n1. 属性绑定：`[target]=\"expression\"`\n1. 事件绑定：`(target)=\"statement\"`\n1. 双向绑定：`[(target)]=\"expression\"`\n1. css类绑定：`[class.special]=\"isSpecial\"`\n1. 样式绑定：`[style.color]=\"isSpecial ? 'red' : 'green'\"`\n\n在多数情况下，插值表达式是更方便的备选项。 实际上，在渲染视图之前，Angular 把这些插值表达式翻译成相应的属性绑定。\n\n在新版的 Angular 中不需要那么多指令。 使用更强大、更富有表现力的 Angular 绑定系统，其实可以达到同样的效果。\n\n外部组件应该只能绑定到组件的公共（允许绑定） API 上，Angular 要求你显式声明那些 API。 它让你可以自己决定哪些属性是可以被外部组件绑定的。进行数据绑定的属性都带有 `@Input()` 和 `@Output()` 装饰器。\n\n**好东西:** Angular 的安全导航操作符`?.` 是一种流畅而便利的方式，用来保护出现在属性路径中 null 和 undefined 值。 下例中，当 currentHero 为空时，保护视图渲染器，让它免于失败。`{{nullHero?.name}}`\n\n非空断言操作符`!`\n\n类型转换函数 `$any`\n\n## 生命钩子\n\n执行顺序\n{% asset_img 2018-10-07-21-38-11.png [blog.ruanxinyu.cn] %}\n\n## 组件交互\n\n[https://angular.cn/guide/component-interaction](https://angular.cn/guide/component-interaction)\n\n+ 通过输入型绑定把数据从父组件传到子组件\n+ 通过 setter 截听输入属性值的变化\n+ 通过ngOnChanges()来截听输入属性值的变化\n+ 父组件监听子组件的事件\n+ 父组件与子组件通过本地变量互动\n+ 父组件调用`@ViewChild()`\n+ 父组件和子组件通过服务来通讯\n\n## 组件样式\n\n+ 使用 `:host` 伪类选择器，用来选择组件宿主元素中的元素\n+ 使用 `:host-context()` 伪类选择器。它也以类似 `:host()` 形式使用。它在当前组件宿主元素的祖先节点中查找 CSS 类， 直到文档的根节点为止\n+ 可以在组件的 HTML 模板中写 `<link>` 标签\n+ 可以利用标准的 CSS `@import` 规则来把其它 CSS 文件导入到 CSS 文件中。\n+ 如果使用 CLI 进行构建，那么你可以用 sass、less 或 stylus 来编写样式，并使用相应的扩展名（.scss、.less、.styl）把它们指定到 @Component.styleUrls 元数据中。\n\n# 表单\n\n## 用户输入\n\n[https://angular.cn/guide/user-input](https://angular.cn/guide/user-input)\n\n+ 绑定到用户输入事件`<button (click)=\"onClickMe()\">Click me!</button>`\n+ 通过 `$event` 对象取得用户输入`<input (keyup)=\"onKey($event)\">`\n+ 从一个模板引用变量中获得用户输入,在标识符前加上井号 (#) 就能声明一个模板引用变量，`<input #box (keyup)=\"0\"> <p>{{box.value}}</p>`\n+ 按键事件过滤（通过 `key.enter`）: `<input #box (keyup.enter)=\"onEnter(box.value)\"> <p>{{value}}</p>`","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>AngularJS的学习地址为：<a href=\"https://angular.cn/guide/quickstart\" target=\"_blank\" rel=\"noopener\">https://angular.cns/guide/quickstart</a></p>\n<h1 id=\"ng命令介绍\"><a href=\"#ng命令介绍\" class=\"headerlink\" title=\"ng命令介绍\"></a>ng命令介绍</h1><ol>\n<li>安装@angular/cli: <code>npm install -g @angular/cli</code></li>\n<li>创建工程： <code>ng new angular-tour-of-heroes</code></li>\n<li>开启调试： <code>ng serve --open</code></li>\n<li>创建组件： <code>ng generate component xxx</code></li>\n<li>创建服务： <code>ng generate service xxx</code></li>\n<li>创建路由：<code>ng generate module xxx --flat --module=app</code></li>\n<li>创建类：<code>ng generate class hero</code></li>\n</ol>\n<h1 id=\"核心知识\"><a href=\"#核心知识\" class=\"headerlink\" title=\"核心知识\"></a>核心知识</h1><h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><p>Angular 的基本构造块是 NgModule，它为组件提供了编译的上下文环境。Angular包含一个根模块，可以包含其他模块，模块的加载是懒加载的。</p>\n<p>组件定义视图，同时使用服务。组件和服务都是简单的类，这些类使用装饰器来标出它们的类型，并提供元数据以告知 Angular 该如何使用它们。</p>\n<p>模板会把 HTML 和 Angular 的标记（markup）组合起来，这些标记可以在 HTML 元素显示出来之前修改它们。 模板中的指令会提供程序逻辑，而绑定标记会把你应用中的数据和 DOM 连接在一起。包含事件绑定和属性绑定，并且支持双星绑定和管道等功能。</p>\n<p>对于与特定视图无关并希望跨组件共享的数据或逻辑，可以创建服务类。 服务类的定义通常紧跟在 “@Injectable” 装饰器之后。该装饰器提供的元数据可以让你的服务作为依赖被注入到客户组件中。</p>\n<p>Angular 的 Router 模块提供了一个服务，它可以让你定义在应用的各个不同状态和视图层次结构之间导航时要使用的路径。如果路由器认为当前的应用状态需要某些特定的功能，而定义此功能的模块尚未加载，路由器就会按需惰性加载此模块。</p>\n<img src=\"/posts/AngularJS学习记录-1/2018-10-07-20-56-50.png\" title=\"[blog.ruanxinyu.cn]\">\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>NgModule 是一个带有 @NgModule 装饰器的类。@NgModule 装饰器是一个函数，它接受一个元数据对象，该对象的属性用来描述这个模块。其中最重要的属性如下。</p>\n<ul>\n<li><strong>declarations（可声明对象表）</strong> —— 那些属于本 NgModule 的组件、指令、管道。</li>\n<li><strong>exports（导出表）</strong> —— 那些能在其它模块的组件模板中使用的可声明对象的子集。</li>\n<li><strong>imports（导入表）</strong> —— 那些导出了本模块中的组件模板所需的类的其它模块。</li>\n<li><strong>providers</strong> —— 本模块向全局服务中贡献的那些服务的创建器。 这些服务能被本应用中的任何部分使用。（你也可以在组件级别指定服务提供商，这通常是首选方式。）</li>\n<li><strong>bootstrap</strong> —— 应用的主视图，称为根组件。它是应用中所有其它视图的宿主。只有根模块才应该设置这个 bootstrap 属性。</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; NgModule &#125;      <span class=\"keyword\">from</span> <span class=\"string\">'@angular/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; BrowserModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/platform-browser'</span>;</span><br><span class=\"line\"><span class=\"meta\">@NgModule</span>(&#123;</span><br><span class=\"line\">  imports:      [ BrowserModule ],</span><br><span class=\"line\">  providers:    [ Logger ],</span><br><span class=\"line\">  declarations: [ AppComponent ],</span><br><span class=\"line\">  exports:      [ AppComponent ],</span><br><span class=\"line\">  bootstrap:    [ AppComponent ]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> AppModule &#123; &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><p>组件通过<code>constructor</code>来提供依赖注入，常见的元数据如下：</p>\n<ul>\n<li><strong>selector：</strong>是一个 CSS 选择器，它会告诉 Angular，一旦在模板 HTML 中找到了这个选择器对应的标签，就创建并插入该组件的一个实例。 </li>\n<li><strong>templateUrl：</strong>该组件的 HTML 模板文件相对于这个组件文件的地址。</li>\n<li><strong>providers:</strong> 是当前组件所需的依赖注入提供商的一个数组</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  selector:    <span class=\"string\">'app-hero-list'</span>,</span><br><span class=\"line\">  templateUrl: <span class=\"string\">'./hero-list.component.html'</span>,</span><br><span class=\"line\">  providers:  [ HeroService ]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroListComponent <span class=\"keyword\">implements</span> OnInit &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>指令：结构型指令和属性型指令。</p>\n<h2 id=\"服务与依赖注入\"><a href=\"#服务与依赖注入\" class=\"headerlink\" title=\"服务与依赖注入\"></a>服务与依赖注入</h2><p>服务是一个广义的概念，它包括应用所需的任何值、函数或特性。狭义的服务是一个明确定义了用途的类。它应该做一些具体的事，并做好。要把一个类定义为服务，就要用 @Injectable 装饰器来提供元数据，以便让 Angular 可以把它作为依赖注入到组件中。通过构造函数进行注入</p>\n<p>Angular 把组件和服务区分开，以提高模块性和复用性。</p>\n<ul>\n<li>通过把组件中和视图有关的功能与其他类型的处理分离开，你可以让组件类更加精简、高效。 理想情况下，组件的工作只管用户体验，而不用顾及其它。 它应该提供用于数据绑定的属性和方法，以便作为视图（由模板渲染）和应用逻辑（通常包含一些模型的概念）的中介者。</li>\n<li>组件不应该定义任何诸如从服务器获取数据、验证用户输入或直接往控制台中写日志等工作。 而要把这些任务委托给各种服务。通过把各种处理任务定义到可注入的服务类中，你可以让它被任何组件使用。 通过在不同的环境中注入同一种服务的不同提供商，你还可以让你的应用更具适应性。</li>\n</ul>\n<p>默认情况下，Angular CLI 的 ng generate service 命令会在 @Injectable 装饰器中提供元数据，把它注册到根注入器中。本教程就用这种方法注册了 HeroService 的提供商</p>\n<p>当你使用特定的 NgModule 注册提供商时，该服务的同一个实例将会对该 NgModule 中的所有组件可用。要想在这一层注册，请用 @NgModule 装饰器中的 providers 属性</p>\n<p>当你在组件级注册提供商时，你会为该组件的每一个新实例提供该服务的一个新实例。 要在组件级注册，就要在 @Component 元数据的 providers 属性中注册服务提供商</p>\n<h1 id=\"组件与模板\"><a href=\"#组件与模板\" class=\"headerlink\" title=\"组件与模板\"></a>组件与模板</h1><h2 id=\"显示数据\"><a href=\"#显示数据\" class=\"headerlink\" title=\"显示数据\"></a>显示数据</h2><p>你可以在两种地方存放组件模板。 你可以使用 template 属性把它定义为内联的，或者把模板定义在一个独立的 HTML 文件中， 再通过 @Component 装饰器中的 templateUrl 属性， 在组件元数据中把它链接到组件。</p>\n<p>默认情况下，Angular CLI 生成组件时会带有模板文件，你可以通过参数覆盖它：<code>ng generate component hero -it</code></p>\n<ul>\n<li><code></code>显示属性。</li>\n<li><code>*ngFor</code> 是 Angular 的“迭代”指令</li>\n<li><code>*ngIf</code> 指令会根据一个布尔条件来显示或移除一个元素</li>\n</ul>\n<h2 id=\"模板语法\"><a href=\"#模板语法\" class=\"headerlink\" title=\"模板语法\"></a>模板语法</h2><p>JavaScript 中那些具有或可能引发副作用的表达式是被禁止的，包括：</p>\n<ul>\n<li>赋值 <code>(=, +=, -=, ...)</code></li>\n<li><code>new</code> 运算符</li>\n<li>使用 <code>;</code> 或 <code>,</code> 的链式表达式</li>\n<li>自增和自减运算符：<code>++</code> 和<code>--</code></li>\n</ul>\n<p>和 JavaScript 语 法的其它显著不同包括：</p>\n<ul>\n<li>不支持位运算 <code>|</code> 和 <code>&amp;</code></li>\n<li>具有新的模板表达式运算符，比如 <code>|、?. 和 !</code>。</li>\n</ul>\n<p>表达式中的上下文变量是由模板变量、指令的上下文变量（如果有）和组件的成员叠加而成的。 如果你要引用的变量名存在于一个以上的命名空间中，那么，模板变量是最优先的，其次是指令的上下文变量，最后是组件的成员。</p>\n<p>模板表达式不能引用全局命名空间中的任何东西，比如 window 或 document。它们也不能调用 console.log 或 Math.max。 它们只能引用表达式上下文中的成员。</p>\n<p>模板表达式能成就或毁掉一个应用。请遵循下列指南：<code>没有可见的副作用</code>,<code>执行迅速</code>,<code>非常简单</code>,<code>幂等性</code></p>\n<p>模板语句用来响应由绑定目标（如 HTML 元素、组件或指令）触发的事件。 模板语句将在事件绑定一节看到，它出现在 = 号右侧的引号中，就像这样：(event)=”statement”。</p>\n<p>绑定方式：</p>\n<ol>\n<li>属性绑定：<code>[target]=&quot;expression&quot;</code></li>\n<li>事件绑定：<code>(target)=&quot;statement&quot;</code></li>\n<li>双向绑定：<code>[(target)]=&quot;expression&quot;</code></li>\n<li>css类绑定：<code>[class.special]=&quot;isSpecial&quot;</code></li>\n<li>样式绑定：<code>[style.color]=&quot;isSpecial ? &#39;red&#39; : &#39;green&#39;&quot;</code></li>\n</ol>\n<p>在多数情况下，插值表达式是更方便的备选项。 实际上，在渲染视图之前，Angular 把这些插值表达式翻译成相应的属性绑定。</p>\n<p>在新版的 Angular 中不需要那么多指令。 使用更强大、更富有表现力的 Angular 绑定系统，其实可以达到同样的效果。</p>\n<p>外部组件应该只能绑定到组件的公共（允许绑定） API 上，Angular 要求你显式声明那些 API。 它让你可以自己决定哪些属性是可以被外部组件绑定的。进行数据绑定的属性都带有 <code>@Input()</code> 和 <code>@Output()</code> 装饰器。</p>\n<p><strong>好东西:</strong> Angular 的安全导航操作符<code>?.</code> 是一种流畅而便利的方式，用来保护出现在属性路径中 null 和 undefined 值。 下例中，当 currentHero 为空时，保护视图渲染器，让它免于失败。<code></code></p>\n<p>非空断言操作符<code>!</code></p>\n<p>类型转换函数 <code>$any</code></p>\n<h2 id=\"生命钩子\"><a href=\"#生命钩子\" class=\"headerlink\" title=\"生命钩子\"></a>生命钩子</h2><p>执行顺序<br><img src=\"/posts/AngularJS学习记录-1/2018-10-07-21-38-11.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"组件交互\"><a href=\"#组件交互\" class=\"headerlink\" title=\"组件交互\"></a>组件交互</h2><p><a href=\"https://angular.cn/guide/component-interaction\" target=\"_blank\" rel=\"noopener\">https://angular.cn/guide/component-interaction</a></p>\n<ul>\n<li>通过输入型绑定把数据从父组件传到子组件</li>\n<li>通过 setter 截听输入属性值的变化</li>\n<li>通过ngOnChanges()来截听输入属性值的变化</li>\n<li>父组件监听子组件的事件</li>\n<li>父组件与子组件通过本地变量互动</li>\n<li>父组件调用<code>@ViewChild()</code></li>\n<li>父组件和子组件通过服务来通讯</li>\n</ul>\n<h2 id=\"组件样式\"><a href=\"#组件样式\" class=\"headerlink\" title=\"组件样式\"></a>组件样式</h2><ul>\n<li>使用 <code>:host</code> 伪类选择器，用来选择组件宿主元素中的元素</li>\n<li>使用 <code>:host-context()</code> 伪类选择器。它也以类似 <code>:host()</code> 形式使用。它在当前组件宿主元素的祖先节点中查找 CSS 类， 直到文档的根节点为止</li>\n<li>可以在组件的 HTML 模板中写 <code>&lt;link&gt;</code> 标签</li>\n<li>可以利用标准的 CSS <code>@import</code> 规则来把其它 CSS 文件导入到 CSS 文件中。</li>\n<li>如果使用 CLI 进行构建，那么你可以用 sass、less 或 stylus 来编写样式，并使用相应的扩展名（.scss、.less、.styl）把它们指定到 @Component.styleUrls 元数据中。</li>\n</ul>\n<h1 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h1><h2 id=\"用户输入\"><a href=\"#用户输入\" class=\"headerlink\" title=\"用户输入\"></a>用户输入</h2><p><a href=\"https://angular.cn/guide/user-input\" target=\"_blank\" rel=\"noopener\">https://angular.cn/guide/user-input</a></p>\n<ul>\n<li>绑定到用户输入事件<code>&lt;button (click)=&quot;onClickMe()&quot;&gt;Click me!&lt;/button&gt;</code></li>\n<li>通过 <code>$event</code> 对象取得用户输入<code>&lt;input (keyup)=&quot;onKey($event)&quot;&gt;</code></li>\n<li>从一个模板引用变量中获得用户输入,在标识符前加上井号 (#) 就能声明一个模板引用变量，<code>&lt;input #box (keyup)=&quot;0&quot;&gt; &lt;p&gt;&lt;/p&gt;</code></li>\n<li>按键事件过滤（通过 <code>key.enter</code>）: <code>&lt;input #box (keyup.enter)=&quot;onEnter(box.value)&quot;&gt; &lt;p&gt;&lt;/p&gt;</code></li>\n</ul>\n","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://ruanxinyu.github.io/categories/学习记录/"}],"tags":[{"name":"学习记录","slug":"学习记录","permalink":"http://ruanxinyu.github.io/tags/学习记录/"}]},{"title":"基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能","slug":"基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能","date":"un66fin66","updated":"un66fin66","comments":true,"path":"posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/","link":"","permalink":"http://ruanxinyu.github.io/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/","excerpt":"","keywords":"","text":"基础环境说明本教程使用Maven管理依赖，使用IDEA进行开发，在开始之前，请按照下面教程安装好JDK和Mysql: JDK的安装请参考：JDK安装教程 Mysql的安装请参考： Ubuntu下Mysql的安装与验证 本教程的代码地址为：https://github.com/RuanXinyu/springcloud-demo/tree/master/productionservice 初始化数据库首先创建一个数据库和一个用户，并分配相应的权限： 1234567-- 创建数据库create database mall;-- 创建用户并分配权限，8.0版本需要采用该方式create user malluser@'%' identified by 'mall@123';grant all privileges on mall.* to 'malluser'@'%' with grant option;flush privileges; 然后在mall数据库中创建一张表： 1234567CREATE TABLE `mall`.`t_production` ( `uuid` CHAR(32) NOT NULL, `name` VARCHAR(128) NOT NULL, `price` DECIMAL(12) NOT NULL, `description` VARCHAR(4094) NULL, `create_time` DATETIME NOT NULL, PRIMARY KEY (`uuid`)); 通过IDEA生成基础代码选择Spring Initializr来创建工程： 指定maven的GAV参数，我们组件名称叫productionservice，同时选择jar包启动的方式： Spring组件我们仅选择Web下的Web，SQL下的MySQL和Mybatis: 最后生成的代码目录结构如下： 使用MybatisGenerator生成代码pom.xml首先在pom文件中增加mybatis-generator-maven-plugin插件，如下所示: 12345678910&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/mybatis_generator.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt;&lt;/plugin&gt; mybatis_generator.xml在src/main/resources/目录下创建generator文件夹，并创建mybatis_generator.xml文件 写入如下的内容： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt; &lt;classPathEntry location=\"D:\\.m2\\mysql\\mysql-connector-java\\5.1.47\\mysql-connector-java-5.1.47.jar\"/&gt; &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"&gt; &lt;commentGenerator&gt; &lt;property name=\"suppressDate\" value=\"true\"/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://127.0.0.1/mall\" userId=\"malluser\" password=\"mall@123\"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name=\"forceBigDecimals\" value=\"false\"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置--&gt; &lt;javaModelGenerator targetPackage=\"com.ruan.productionservice.model\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;property name=\"trimStrings\" value=\"true\"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage=\"com.ruan.productionservice.mapper\" targetProject=\"src/main/resources\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置--&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.ruan.productionservice.mapper\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;table tableName=\"t_production\" domainObjectName=\"Production\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" selectByExampleQueryId=\"false\"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 做几点说明： &lt;classPathEntry location=&quot;D:\\.m2\\mysql\\mysql-connector-java\\5.1.47\\mysql-connector-java-5.1.47.jar&quot;/&gt;中的路径可以从maven的缓存目录中找到 &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://127.0.0.1/mall&quot; userId=&quot;malluser&quot; password=&quot;mall@123&quot;&gt;需要正确填写数据库的数据库名称，用户名，密码和表名称 targetPackage=要修改为对应的包路径 &lt;table tableName=&quot;t_production&quot; domainObjectName=&quot;Production&quot;需要正确填写和实体类名 mybatis-generator:generate最后双击右侧maven窗口中的plugins-&gt;mybatis-generator:generate即可生成代码。 注意不要多次生成，否则xml中可能会生成重复的内容，从而造成启动报错，可以删除文件再生成 最终生成的代码结构如下： 添加查询数据列表接口从MybatisGenerator生成的代码中可以看出已经生成了增删改查的接口，我们在此基础之上增加一个查询列表的接口ArrayList&lt;Production&gt; selectAll()。 ProductionMapper.xml在文件中增加一个selectAll对应的查询语句： 12345&lt;select id=\"selectAll\" resultMap=\"BaseResultMap\"&gt; select &lt;include refid=\"Base_Column_List\" /&gt; from t_production&lt;/select&gt; 如下所示： ProductionMapper.java在接口中增加ArrayList&lt;Production&gt; selectAll();接口声明 增加@Mapper注解MybatisGenerator自动生成的接口ProductionMapper接口默认是没有注解的，需要我们手动增加@Mapper注解，否则启动时会报错。 注意： 每次重新生成代码后都需要重新手动修改 增加service层代码在com.ruan.productionservice.service下创建ProductionService接口，在com.ruan.productionservice.service.impl下创建ProductionServiceImpl类实现ProductionService，如下所示： ProductionService.java接口中声明5个接口函数： 1234567public interface ProductionService &#123; int delete(String uuid); int save(Production record); Production get(String uuid); int update(Production record); ArrayList&lt;Production&gt; list();&#125; ProductionServiceImpl.java实现类ProductionServiceImpl需要加@Service注解， 在保存记录的接口中自动生成主键和创建时间 123456789101112131415161718192021222324252627282930313233@Servicepublic class ProductionServiceImpl implements ProductionService &#123; @Autowired ProductionMapper mapper; @Override public int delete(String uuid) &#123; return mapper.deleteByPrimaryKey(uuid); &#125; @Override public int save(Production production) &#123; production.setUuid(UUID.randomUUID().toString().replace(\"-\", \"\").toLowerCase()); production.setCreateTime(new Date()); return mapper.insert(production); &#125; @Override public int update(Production production) &#123; return mapper.updateByPrimaryKeySelective(production); &#125; @Override public Production get(String uuid) &#123; return mapper.selectByPrimaryKey(uuid); &#125; @Override public ArrayList&lt;Production&gt; list() &#123; return mapper.selectAll(); &#125;&#125; 增加controller层代码ProductionController.java在com.ruan.productionservice.controller下创建ProductionController类，在类上指定@RestController注解，然后实现5个Restful接口，代码如下： 12345678910111213141516171819202122232425262728293031323334353637@RestController@RequestMapping(value = \"/mall/production\")public class ProductionController &#123; @Autowired ProductionService productionService; @ResponseBody @RequestMapping(value = \"/save\", method = RequestMethod.POST) public int save(Production production)&#123; return productionService.save(production); &#125; @ResponseBody @RequestMapping(value = \"/update\", method = RequestMethod.POST) public int update(Production production)&#123; return productionService.update(production); &#125; @ResponseBody @RequestMapping(value = \"/delete/&#123;id&#125;\", method = RequestMethod.POST) public int delete(@PathVariable(\"id\") String id)&#123; return productionService.delete(id); &#125; @ResponseBody @RequestMapping(value = \"/get/&#123;id&#125;\", method = RequestMethod.GET) public Production get(@PathVariable(\"id\") String id)&#123; return productionService.get(id); &#125; @ResponseBody @RequestMapping(value = \"/list\", method = RequestMethod.GET) public ArrayList&lt;Production&gt; list()&#123; return productionService.list(); &#125;&#125; 配置application.propertiesapplication.properties中包含应用的配置信息，我们只需要配置JDBC的内容即可，如下所示： 1234spring.datasource.url=jdbc:mysql://localhost:3306/mallspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.username=malluserspring.datasource.password=mall@123 启动应用程序在IDEA中进去到ProductionserviceApplication类中，然后就可以启动程序，如下所示： PostMan验证接口启动后，我们通过PostMan进行接口的验证。 /mall/production/save创建一条数据，返回1，表示插入数据库成功。 /mall/production/list通过list接口可以看到插入的内容，并且可以看到对应数据的uuid，用来调用其他接口 /mall/production/update通过上面获取到的uuid修改数据，如下，返回1表示数据库修改成功。 /mall/production/get/{id}通过上面获取到的uuid获取数据详情，此时uuid是在网址中，发现price已经修改为35。 /mall/production/delete/{id}最后通过delete接口删除数据 可能遇到的问题启动时提示自动加载ProductionMapper失败如果在启动过程中提示No qualifying bean of type &#39;com.ruan.productionservice.mapper.ProductionMapper&#39; available: expected at least 1 bean which qualifies as autowire candidate.，则说明ProductionMapper没有添加@Mapper注解，该文件是Mybatis Generator自动生成的，需要手动添加该注解。 启动时提示Result Maps错误启动报错提示java.lang.IllegalArgumentException: Result Maps collection already contains value for com.ruan.productionservice.mapper.ProductionMapper.BaseResultMap，是因为多次使用Mybatis Generator生成代码，造成ProductionMapper.xml文件中存在重复的内容，删除掉该文件重新生成即可。","raw":"---\ntitle: 基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能\ntags: Java\ncategories: 技术分享\ndate: 2018-10-06 15:29:04\n---\n\n# 基础环境说明\n\n本教程使用Maven管理依赖，使用IDEA进行开发，在开始之前，请按照下面教程安装好JDK和Mysql:\n\n+ JDK的安装请参考：{% post_link JDK安装教程 %}\n+ Mysql的安装请参考： {% post_link Ubuntu下Mysql的安装与验证 %}\n\n本教程的代码地址为：[https://github.com/RuanXinyu/springcloud-demo/tree/master/productionservice](https://github.com/RuanXinyu/springcloud-demo/tree/master/productionservice)\n\n# 初始化数据库\n\n首先创建一个数据库和一个用户，并分配相应的权限：\n\n```sql\n-- 创建数据库\ncreate database mall;\n\n-- 创建用户并分配权限，8.0版本需要采用该方式\ncreate user malluser@'%' identified by 'mall@123';\ngrant all privileges on mall.* to 'malluser'@'%' with grant option;\nflush privileges;\n```\n\n然后在`mall`数据库中创建一张表：\n\n```sql\nCREATE TABLE `mall`.`t_production` (\n  `uuid` CHAR(32) NOT NULL,\n  `name` VARCHAR(128) NOT NULL,\n  `price` DECIMAL(12) NOT NULL,\n  `description` VARCHAR(4094) NULL,\n  `create_time` DATETIME NOT NULL,\n  PRIMARY KEY (`uuid`));\n```\n\n# 通过IDEA生成基础代码\n\n选择`Spring Initializr`来创建工程：\n{% asset_img 2018-10-06-16-37-05.png [blog.ruanxinyu.cn] %}\n\n指定maven的GAV参数，我们组件名称叫`productionservice`，同时选择`jar`包启动的方式：\n{% asset_img 2018-10-06-20-10-48.png [blog.ruanxinyu.cn] %}\n\nSpring组件我们仅选择`Web`下的`Web`，`SQL`下的`MySQL`和`Mybatis`:\n{% asset_img 2018-10-06-16-48-32.png [blog.ruanxinyu.cn] %}\n\n最后生成的代码目录结构如下：\n{% asset_img 2018-10-06-16-43-49.png [blog.ruanxinyu.cn] %}\n\n# 使用MybatisGenerator生成代码\n\n## pom.xml\n\n首先在pom文件中增加`mybatis-generator-maven-plugin`插件，如下所示:\n\n```xml\n<plugin>\n    <groupId>org.mybatis.generator</groupId>\n    <artifactId>mybatis-generator-maven-plugin</artifactId>\n    <version>1.3.7</version>\n    <configuration>\n        <configurationFile>${basedir}/src/main/resources/generator/mybatis_generator.xml</configurationFile>\n        <overwrite>true</overwrite>\n        <verbose>true</verbose>\n    </configuration>\n</plugin>\n```\n\n{% asset_img 2018-10-06-17-17-28.png [blog.ruanxinyu.cn] %}\n\n## mybatis_generator.xml\n\n在`src/main/resources/`目录下创建`generator`文件夹，并创建`mybatis_generator.xml`文件\n{% asset_img 2018-10-06-19-58-44.png [blog.ruanxinyu.cn] %}\n\n写入如下的内容：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE generatorConfiguration\n        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n<generatorConfiguration>\n    <!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包-->\n    <classPathEntry  location=\"D:\\.m2\\mysql\\mysql-connector-java\\5.1.47\\mysql-connector-java-5.1.47.jar\"/>\n    <context id=\"DB2Tables\"  targetRuntime=\"MyBatis3\">\n        <commentGenerator>\n            <property name=\"suppressDate\" value=\"true\"/>\n            <!-- 是否去除自动生成的注释 true：是 ： false:否 -->\n            <property name=\"suppressAllComments\" value=\"true\"/>\n        </commentGenerator>\n        <!--数据库链接URL，用户名、密码 -->\n        <jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://127.0.0.1/mall\" userId=\"malluser\" password=\"mall@123\">\n        </jdbcConnection>\n        <javaTypeResolver>\n            <property name=\"forceBigDecimals\" value=\"false\"/>\n        </javaTypeResolver>\n        <!-- 生成模型的包名和位置-->\n        <javaModelGenerator targetPackage=\"com.ruan.productionservice.model\" targetProject=\"src/main/java\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n            <property name=\"trimStrings\" value=\"true\"/>\n        </javaModelGenerator>\n        <!-- 生成映射文件的包名和位置-->\n        <sqlMapGenerator targetPackage=\"com.ruan.productionservice.mapper\" targetProject=\"src/main/resources\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n        </sqlMapGenerator>\n        <!-- 生成DAO的包名和位置-->\n        <javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.ruan.productionservice.mapper\" targetProject=\"src/main/java\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n        </javaClientGenerator>\n        <!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名-->\n        <table tableName=\"t_production\" domainObjectName=\"Production\"\n               enableCountByExample=\"false\" enableUpdateByExample=\"false\"\n               enableDeleteByExample=\"false\" enableSelectByExample=\"false\" selectByExampleQueryId=\"false\"/>\n    </context>\n</generatorConfiguration>\n```\n\n做几点说明：\n\n1. `<classPathEntry  location=\"D:\\.m2\\mysql\\mysql-connector-java\\5.1.47\\mysql-connector-java-5.1.47.jar\"/>`中的路径可以从maven的缓存目录中找到\n1. `<jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://127.0.0.1/mall\" userId=\"malluser\" password=\"mall@123\">`需要正确填写数据库的数据库名称，用户名，密码和表名称\n1. `targetPackage=`要修改为对应的包路径\n1. `<table tableName=\"t_production\" domainObjectName=\"Production\"`需要正确填写和实体类名\n\n## mybatis-generator:generate\n\n最后双击右侧maven窗口中的`plugins`->`mybatis-generator:generate`即可生成代码。\n> 注意不要多次生成，否则xml中可能会生成重复的内容，从而造成启动报错，可以删除文件再生成\n\n{% asset_img 2018-10-06-20-04-24.png [blog.ruanxinyu.cn] %}\n\n最终生成的代码结构如下：\n{% asset_img 2018-10-06-20-09-48.png [blog.ruanxinyu.cn] %}\n\n# 添加查询数据列表接口\n\n从MybatisGenerator生成的代码中可以看出已经生成了增删改查的接口，我们在此基础之上增加一个查询列表的接口`ArrayList<Production> selectAll()`。\n\n## ProductionMapper.xml\n\n在文件中增加一个`selectAll`对应的查询语句：\n\n```xml\n<select id=\"selectAll\" resultMap=\"BaseResultMap\">\n  select\n  <include refid=\"Base_Column_List\" />\n  from t_production\n</select>\n```\n\n如下所示：\n{% asset_img 2018-10-06-20-18-41.png [blog.ruanxinyu.cn] %}\n\n## ProductionMapper.java\n\n在接口中增加`ArrayList<Production> selectAll();`接口声明\n\n# 增加@Mapper注解\n\nMybatisGenerator自动生成的接口`ProductionMapper`接口默认是没有注解的，需要我们手动增加`@Mapper`注解，否则启动时会报错。\n\n**注意：** 每次重新生成代码后都需要重新手动修改\n\n# 增加service层代码\n\n在`com.ruan.productionservice.service`下创建`ProductionService`接口，在`com.ruan.productionservice.service.impl`下创建`ProductionServiceImpl`类实现`ProductionService`，如下所示：\n{% asset_img 2018-10-06-20-37-04.png [blog.ruanxinyu.cn] %}\n\n## ProductionService.java\n\n接口中声明5个接口函数：\n\n```java\npublic interface ProductionService {\n    int delete(String uuid);\n    int save(Production record);\n    Production get(String uuid);\n    int update(Production record);\n    ArrayList<Production> list();\n}\n```\n\n## ProductionServiceImpl.java\n\n实现类`ProductionServiceImpl`需要加`@Service`注解， 在保存记录的接口中自动生成主键和创建时间\n\n```java\n@Service\npublic class ProductionServiceImpl implements ProductionService {\n\n    @Autowired\n    ProductionMapper mapper;\n\n    @Override\n    public int delete(String uuid) {\n        return mapper.deleteByPrimaryKey(uuid);\n    }\n\n    @Override\n    public int save(Production production) {\n        production.setUuid(UUID.randomUUID().toString().replace(\"-\", \"\").toLowerCase());\n        production.setCreateTime(new Date());\n        return mapper.insert(production);\n    }\n\n    @Override\n    public int update(Production production) {\n        return mapper.updateByPrimaryKeySelective(production);\n    }\n\n    @Override\n    public Production get(String uuid) {\n        return mapper.selectByPrimaryKey(uuid);\n    }\n\n    @Override\n    public ArrayList<Production> list() {\n        return mapper.selectAll();\n    }\n}\n```\n\n# 增加controller层代码\n\n## ProductionController.java\n\n在`com.ruan.productionservice.controller`下创建`ProductionController`类，在类上指定`@RestController`注解，然后实现5个Restful接口，代码如下：\n\n```java\n@RestController\n@RequestMapping(value = \"/mall/production\")\npublic class ProductionController {\n\n    @Autowired\n    ProductionService productionService;\n\n    @ResponseBody\n    @RequestMapping(value = \"/save\", method = RequestMethod.POST)\n    public int save(Production production){\n        return productionService.save(production);\n    }\n\n    @ResponseBody\n    @RequestMapping(value = \"/update\", method = RequestMethod.POST)\n    public int update(Production production){\n        return productionService.update(production);\n    }\n\n    @ResponseBody\n    @RequestMapping(value = \"/delete/{id}\", method = RequestMethod.POST)\n    public int delete(@PathVariable(\"id\") String id){\n        return productionService.delete(id);\n    }\n\n    @ResponseBody\n    @RequestMapping(value = \"/get/{id}\", method = RequestMethod.GET)\n    public Production get(@PathVariable(\"id\") String id){\n        return productionService.get(id);\n    }\n\n    @ResponseBody\n    @RequestMapping(value = \"/list\", method = RequestMethod.GET)\n    public ArrayList<Production> list(){\n        return productionService.list();\n    }\n}\n```\n\n# 配置application.properties\n\n`application.properties`中包含应用的配置信息，我们只需要配置JDBC的内容即可，如下所示：\n\n```bash\nspring.datasource.url=jdbc:mysql://localhost:3306/mall\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.username=malluser\nspring.datasource.password=mall@123\n```\n\n# 启动应用程序\n\n在IDEA中进去到`ProductionserviceApplication`类中，然后就可以启动程序，如下所示：\n{% asset_img 2018-10-06-20-48-41.png [blog.ruanxinyu.cn] %}\n\n# PostMan验证接口\n\n启动后，我们通过PostMan进行接口的验证。\n\n## /mall/production/save\n\n创建一条数据，返回`1`，表示插入数据库成功。\n{% asset_img 2018-10-06-20-55-57.png [blog.ruanxinyu.cn] %}\n\n## /mall/production/list\n\n通过list接口可以看到插入的内容，并且可以看到对应数据的`uuid`，用来调用其他接口\n{% asset_img 2018-10-06-21-00-23.png [blog.ruanxinyu.cn] %}\n\n## /mall/production/update\n\n通过上面获取到的uuid修改数据，如下，返回`1`表示数据库修改成功。\n{% asset_img 2018-10-06-21-02-17.png [blog.ruanxinyu.cn] %}\n\n## /mall/production/get/{id}\n\n通过上面获取到的uuid获取数据详情，此时uuid是在网址中，发现`price`已经修改为`35`。\n{% asset_img 2018-10-06-21-04-18.png [blog.ruanxinyu.cn] %}\n\n## /mall/production/delete/{id}\n\n最后通过delete接口删除数据\n{% asset_img 2018-10-06-21-05-33.png [blog.ruanxinyu.cn] %}\n\n# 可能遇到的问题\n\n## 启动时提示自动加载ProductionMapper失败\n\n如果在启动过程中提示`No qualifying bean of type 'com.ruan.productionservice.mapper.ProductionMapper' available: expected at least 1 bean which qualifies as autowire candidate.`，则说明`ProductionMapper`没有添加`@Mapper`注解，该文件是Mybatis Generator自动生成的，需要手动添加该注解。\n\n## 启动时提示Result Maps错误\n\n启动报错提示`java.lang.IllegalArgumentException: Result Maps collection already contains value for com.ruan.productionservice.mapper.ProductionMapper.BaseResultMap`，是因为多次使用Mybatis Generator生成代码，造成`ProductionMapper.xml`文件中存在重复的内容，删除掉该文件重新生成即可。","content":"<h1 id=\"基础环境说明\"><a href=\"#基础环境说明\" class=\"headerlink\" title=\"基础环境说明\"></a>基础环境说明</h1><p>本教程使用Maven管理依赖，使用IDEA进行开发，在开始之前，请按照下面教程安装好JDK和Mysql:</p>\n<ul>\n<li>JDK的安装请参考：<a href=\"/posts/JDK安装教程/\" title=\"JDK安装教程\">JDK安装教程</a></li>\n<li>Mysql的安装请参考： <a href=\"/posts/Ubuntu下Mysql的安装与验证/\" title=\"Ubuntu下Mysql的安装与验证\">Ubuntu下Mysql的安装与验证</a></li>\n</ul>\n<p>本教程的代码地址为：<a href=\"https://github.com/RuanXinyu/springcloud-demo/tree/master/productionservice\" target=\"_blank\" rel=\"noopener\">https://github.com/RuanXinyu/springcloud-demo/tree/master/productionservice</a></p>\n<h1 id=\"初始化数据库\"><a href=\"#初始化数据库\" class=\"headerlink\" title=\"初始化数据库\"></a>初始化数据库</h1><p>首先创建一个数据库和一个用户，并分配相应的权限：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建数据库</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">database</span> mall;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建用户并分配权限，8.0版本需要采用该方式</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">user</span> malluser@<span class=\"string\">'%'</span> <span class=\"keyword\">identified</span> <span class=\"keyword\">by</span> <span class=\"string\">'mall@123'</span>;</span><br><span class=\"line\"><span class=\"keyword\">grant</span> all <span class=\"keyword\">privileges</span> <span class=\"keyword\">on</span> mall.* <span class=\"keyword\">to</span> <span class=\"string\">'malluser'</span>@<span class=\"string\">'%'</span> <span class=\"keyword\">with</span> <span class=\"keyword\">grant</span> <span class=\"keyword\">option</span>;</span><br><span class=\"line\"><span class=\"keyword\">flush</span> <span class=\"keyword\">privileges</span>;</span><br></pre></td></tr></table></figure>\n<p>然后在<code>mall</code>数据库中创建一张表：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`mall`</span>.<span class=\"string\">`t_production`</span> (</span><br><span class=\"line\">  <span class=\"string\">`uuid`</span> <span class=\"built_in\">CHAR</span>(<span class=\"number\">32</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`name`</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">128</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`price`</span> <span class=\"built_in\">DECIMAL</span>(<span class=\"number\">12</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`description`</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">4094</span>) <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`create_time`</span> DATETIME <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`uuid`</span>));</span><br></pre></td></tr></table></figure>\n<h1 id=\"通过IDEA生成基础代码\"><a href=\"#通过IDEA生成基础代码\" class=\"headerlink\" title=\"通过IDEA生成基础代码\"></a>通过IDEA生成基础代码</h1><p>选择<code>Spring Initializr</code>来创建工程：<br><img src=\"/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/2018-10-06-16-37-05.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>指定maven的GAV参数，我们组件名称叫<code>productionservice</code>，同时选择<code>jar</code>包启动的方式：<br><img src=\"/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/2018-10-06-20-10-48.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>Spring组件我们仅选择<code>Web</code>下的<code>Web</code>，<code>SQL</code>下的<code>MySQL</code>和<code>Mybatis</code>:<br><img src=\"/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/2018-10-06-16-48-32.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>最后生成的代码目录结构如下：<br><img src=\"/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/2018-10-06-16-43-49.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h1 id=\"使用MybatisGenerator生成代码\"><a href=\"#使用MybatisGenerator生成代码\" class=\"headerlink\" title=\"使用MybatisGenerator生成代码\"></a>使用MybatisGenerator生成代码</h1><h2 id=\"pom-xml\"><a href=\"#pom-xml\" class=\"headerlink\" title=\"pom.xml\"></a>pom.xml</h2><p>首先在pom文件中增加<code>mybatis-generator-maven-plugin</code>插件，如下所示:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis.generator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.3.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">configurationFile</span>&gt;</span>$&#123;basedir&#125;/src/main/resources/generator/mybatis_generator.xml<span class=\"tag\">&lt;/<span class=\"name\">configurationFile</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">overwrite</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">overwrite</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">verbose</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">verbose</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<img src=\"/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/2018-10-06-17-17-28.png\" title=\"[blog.ruanxinyu.cn]\">\n<h2 id=\"mybatis-generator-xml\"><a href=\"#mybatis-generator-xml\" class=\"headerlink\" title=\"mybatis_generator.xml\"></a>mybatis_generator.xml</h2><p>在<code>src/main/resources/</code>目录下创建<code>generator</code>文件夹，并创建<code>mybatis_generator.xml</code>文件<br><img src=\"/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/2018-10-06-19-58-44.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>写入如下的内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">generatorConfiguration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">classPathEntry</span>  <span class=\"attr\">location</span>=<span class=\"string\">\"D:\\.m2\\mysql\\mysql-connector-java\\5.1.47\\mysql-connector-java-5.1.47.jar\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context</span> <span class=\"attr\">id</span>=<span class=\"string\">\"DB2Tables\"</span>  <span class=\"attr\">targetRuntime</span>=<span class=\"string\">\"MyBatis3\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">commentGenerator</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suppressDate\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suppressAllComments\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">commentGenerator</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--数据库链接URL，用户名、密码 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">jdbcConnection</span> <span class=\"attr\">driverClass</span>=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span> <span class=\"attr\">connectionURL</span>=<span class=\"string\">\"jdbc:mysql://127.0.0.1/mall\"</span> <span class=\"attr\">userId</span>=<span class=\"string\">\"malluser\"</span> <span class=\"attr\">password</span>=<span class=\"string\">\"mall@123\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">jdbcConnection</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">javaTypeResolver</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"forceBigDecimals\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">javaTypeResolver</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 生成模型的包名和位置--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">javaModelGenerator</span> <span class=\"attr\">targetPackage</span>=<span class=\"string\">\"com.ruan.productionservice.model\"</span> <span class=\"attr\">targetProject</span>=<span class=\"string\">\"src/main/java\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"enableSubPackages\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"trimStrings\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">javaModelGenerator</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 生成映射文件的包名和位置--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">sqlMapGenerator</span> <span class=\"attr\">targetPackage</span>=<span class=\"string\">\"com.ruan.productionservice.mapper\"</span> <span class=\"attr\">targetProject</span>=<span class=\"string\">\"src/main/resources\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"enableSubPackages\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">sqlMapGenerator</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 生成DAO的包名和位置--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">javaClientGenerator</span> <span class=\"attr\">type</span>=<span class=\"string\">\"XMLMAPPER\"</span> <span class=\"attr\">targetPackage</span>=<span class=\"string\">\"com.ruan.productionservice.mapper\"</span> <span class=\"attr\">targetProject</span>=<span class=\"string\">\"src/main/java\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"enableSubPackages\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">javaClientGenerator</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">tableName</span>=<span class=\"string\">\"t_production\"</span> <span class=\"attr\">domainObjectName</span>=<span class=\"string\">\"Production\"</span></span></span><br><span class=\"line\"><span class=\"tag\">               <span class=\"attr\">enableCountByExample</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">enableUpdateByExample</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">               <span class=\"attr\">enableDeleteByExample</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">enableSelectByExample</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">selectByExampleQueryId</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>做几点说明：</p>\n<ol>\n<li><code>&lt;classPathEntry  location=&quot;D:\\.m2\\mysql\\mysql-connector-java\\5.1.47\\mysql-connector-java-5.1.47.jar&quot;/&gt;</code>中的路径可以从maven的缓存目录中找到</li>\n<li><code>&lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://127.0.0.1/mall&quot; userId=&quot;malluser&quot; password=&quot;mall@123&quot;&gt;</code>需要正确填写数据库的数据库名称，用户名，密码和表名称</li>\n<li><code>targetPackage=</code>要修改为对应的包路径</li>\n<li><code>&lt;table tableName=&quot;t_production&quot; domainObjectName=&quot;Production&quot;</code>需要正确填写和实体类名</li>\n</ol>\n<h2 id=\"mybatis-generator-generate\"><a href=\"#mybatis-generator-generate\" class=\"headerlink\" title=\"mybatis-generator:generate\"></a>mybatis-generator:generate</h2><p>最后双击右侧maven窗口中的<code>plugins</code>-&gt;<code>mybatis-generator:generate</code>即可生成代码。</p>\n<blockquote>\n<p>注意不要多次生成，否则xml中可能会生成重复的内容，从而造成启动报错，可以删除文件再生成</p>\n</blockquote>\n<img src=\"/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/2018-10-06-20-04-24.png\" title=\"[blog.ruanxinyu.cn]\">\n<p>最终生成的代码结构如下：<br><img src=\"/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/2018-10-06-20-09-48.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h1 id=\"添加查询数据列表接口\"><a href=\"#添加查询数据列表接口\" class=\"headerlink\" title=\"添加查询数据列表接口\"></a>添加查询数据列表接口</h1><p>从MybatisGenerator生成的代码中可以看出已经生成了增删改查的接口，我们在此基础之上增加一个查询列表的接口<code>ArrayList&lt;Production&gt; selectAll()</code>。</p>\n<h2 id=\"ProductionMapper-xml\"><a href=\"#ProductionMapper-xml\" class=\"headerlink\" title=\"ProductionMapper.xml\"></a>ProductionMapper.xml</h2><p>在文件中增加一个<code>selectAll</code>对应的查询语句：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"selectAll\"</span> <span class=\"attr\">resultMap</span>=<span class=\"string\">\"BaseResultMap\"</span>&gt;</span></span><br><span class=\"line\">  select</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">include</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"Base_Column_List\"</span> /&gt;</span></span><br><span class=\"line\">  from t_production</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如下所示：<br><img src=\"/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/2018-10-06-20-18-41.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"ProductionMapper-java\"><a href=\"#ProductionMapper-java\" class=\"headerlink\" title=\"ProductionMapper.java\"></a>ProductionMapper.java</h2><p>在接口中增加<code>ArrayList&lt;Production&gt; selectAll();</code>接口声明</p>\n<h1 id=\"增加-Mapper注解\"><a href=\"#增加-Mapper注解\" class=\"headerlink\" title=\"增加@Mapper注解\"></a>增加@Mapper注解</h1><p>MybatisGenerator自动生成的接口<code>ProductionMapper</code>接口默认是没有注解的，需要我们手动增加<code>@Mapper</code>注解，否则启动时会报错。</p>\n<p><strong>注意：</strong> 每次重新生成代码后都需要重新手动修改</p>\n<h1 id=\"增加service层代码\"><a href=\"#增加service层代码\" class=\"headerlink\" title=\"增加service层代码\"></a>增加service层代码</h1><p>在<code>com.ruan.productionservice.service</code>下创建<code>ProductionService</code>接口，在<code>com.ruan.productionservice.service.impl</code>下创建<code>ProductionServiceImpl</code>类实现<code>ProductionService</code>，如下所示：<br><img src=\"/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/2018-10-06-20-37-04.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"ProductionService-java\"><a href=\"#ProductionService-java\" class=\"headerlink\" title=\"ProductionService.java\"></a>ProductionService.java</h2><p>接口中声明5个接口函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ProductionService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">delete</span><span class=\"params\">(String uuid)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">save</span><span class=\"params\">(Production record)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Production <span class=\"title\">get</span><span class=\"params\">(String uuid)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">update</span><span class=\"params\">(Production record)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">ArrayList&lt;Production&gt; <span class=\"title\">list</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ProductionServiceImpl-java\"><a href=\"#ProductionServiceImpl-java\" class=\"headerlink\" title=\"ProductionServiceImpl.java\"></a>ProductionServiceImpl.java</h2><p>实现类<code>ProductionServiceImpl</code>需要加<code>@Service</code>注解， 在保存记录的接口中自动生成主键和创建时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductionServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ProductionService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    ProductionMapper mapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">delete</span><span class=\"params\">(String uuid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapper.deleteByPrimaryKey(uuid);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">save</span><span class=\"params\">(Production production)</span> </span>&#123;</span><br><span class=\"line\">        production.setUuid(UUID.randomUUID().toString().replace(<span class=\"string\">\"-\"</span>, <span class=\"string\">\"\"</span>).toLowerCase());</span><br><span class=\"line\">        production.setCreateTime(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapper.insert(production);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">update</span><span class=\"params\">(Production production)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapper.updateByPrimaryKeySelective(production);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Production <span class=\"title\">get</span><span class=\"params\">(String uuid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapper.selectByPrimaryKey(uuid);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ArrayList&lt;Production&gt; <span class=\"title\">list</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapper.selectAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"增加controller层代码\"><a href=\"#增加controller层代码\" class=\"headerlink\" title=\"增加controller层代码\"></a>增加controller层代码</h1><h2 id=\"ProductionController-java\"><a href=\"#ProductionController-java\" class=\"headerlink\" title=\"ProductionController.java\"></a>ProductionController.java</h2><p>在<code>com.ruan.productionservice.controller</code>下创建<code>ProductionController</code>类，在类上指定<code>@RestController</code>注解，然后实现5个Restful接口，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/mall/production\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductionController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    ProductionService productionService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/save\"</span>, method = RequestMethod.POST)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">save</span><span class=\"params\">(Production production)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> productionService.save(production);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/update\"</span>, method = RequestMethod.POST)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">update</span><span class=\"params\">(Production production)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> productionService.update(production);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/delete/&#123;id&#125;\"</span>, method = RequestMethod.POST)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">delete</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> String id)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> productionService.delete(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/get/&#123;id&#125;\"</span>, method = RequestMethod.GET)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Production <span class=\"title\">get</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> String id)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> productionService.get(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/list\"</span>, method = RequestMethod.GET)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ArrayList&lt;Production&gt; <span class=\"title\">list</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> productionService.list();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"配置application-properties\"><a href=\"#配置application-properties\" class=\"headerlink\" title=\"配置application.properties\"></a>配置application.properties</h1><p><code>application.properties</code>中包含应用的配置信息，我们只需要配置JDBC的内容即可，如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.datasource.url=jdbc:mysql://localhost:3306/mall</span><br><span class=\"line\">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class=\"line\">spring.datasource.username=malluser</span><br><span class=\"line\">spring.datasource.password=mall@123</span><br></pre></td></tr></table></figure>\n<h1 id=\"启动应用程序\"><a href=\"#启动应用程序\" class=\"headerlink\" title=\"启动应用程序\"></a>启动应用程序</h1><p>在IDEA中进去到<code>ProductionserviceApplication</code>类中，然后就可以启动程序，如下所示：<br><img src=\"/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/2018-10-06-20-48-41.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h1 id=\"PostMan验证接口\"><a href=\"#PostMan验证接口\" class=\"headerlink\" title=\"PostMan验证接口\"></a>PostMan验证接口</h1><p>启动后，我们通过PostMan进行接口的验证。</p>\n<h2 id=\"mall-production-save\"><a href=\"#mall-production-save\" class=\"headerlink\" title=\"/mall/production/save\"></a>/mall/production/save</h2><p>创建一条数据，返回<code>1</code>，表示插入数据库成功。<br><img src=\"/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/2018-10-06-20-55-57.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"mall-production-list\"><a href=\"#mall-production-list\" class=\"headerlink\" title=\"/mall/production/list\"></a>/mall/production/list</h2><p>通过list接口可以看到插入的内容，并且可以看到对应数据的<code>uuid</code>，用来调用其他接口<br><img src=\"/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/2018-10-06-21-00-23.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"mall-production-update\"><a href=\"#mall-production-update\" class=\"headerlink\" title=\"/mall/production/update\"></a>/mall/production/update</h2><p>通过上面获取到的uuid修改数据，如下，返回<code>1</code>表示数据库修改成功。<br><img src=\"/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/2018-10-06-21-02-17.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"mall-production-get-id\"><a href=\"#mall-production-get-id\" class=\"headerlink\" title=\"/mall/production/get/{id}\"></a>/mall/production/get/{id}</h2><p>通过上面获取到的uuid获取数据详情，此时uuid是在网址中，发现<code>price</code>已经修改为<code>35</code>。<br><img src=\"/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/2018-10-06-21-04-18.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"mall-production-delete-id\"><a href=\"#mall-production-delete-id\" class=\"headerlink\" title=\"/mall/production/delete/{id}\"></a>/mall/production/delete/{id}</h2><p>最后通过delete接口删除数据<br><img src=\"/posts/基于SpringBoot+Mybatis开发Restful接口实现数据表的增删改查功能/2018-10-06-21-05-33.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h1 id=\"可能遇到的问题\"><a href=\"#可能遇到的问题\" class=\"headerlink\" title=\"可能遇到的问题\"></a>可能遇到的问题</h1><h2 id=\"启动时提示自动加载ProductionMapper失败\"><a href=\"#启动时提示自动加载ProductionMapper失败\" class=\"headerlink\" title=\"启动时提示自动加载ProductionMapper失败\"></a>启动时提示自动加载ProductionMapper失败</h2><p>如果在启动过程中提示<code>No qualifying bean of type &#39;com.ruan.productionservice.mapper.ProductionMapper&#39; available: expected at least 1 bean which qualifies as autowire candidate.</code>，则说明<code>ProductionMapper</code>没有添加<code>@Mapper</code>注解，该文件是Mybatis Generator自动生成的，需要手动添加该注解。</p>\n<h2 id=\"启动时提示Result-Maps错误\"><a href=\"#启动时提示Result-Maps错误\" class=\"headerlink\" title=\"启动时提示Result Maps错误\"></a>启动时提示Result Maps错误</h2><p>启动报错提示<code>java.lang.IllegalArgumentException: Result Maps collection already contains value for com.ruan.productionservice.mapper.ProductionMapper.BaseResultMap</code>，是因为多次使用Mybatis Generator生成代码，造成<code>ProductionMapper.xml</code>文件中存在重复的内容，删除掉该文件重新生成即可。</p>\n","categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://ruanxinyu.github.io/categories/技术分享/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://ruanxinyu.github.io/tags/Java/"}]},{"title":"Mysql常见问题操作指导","slug":"Mysql常见问题操作指导","date":"un66fin66","updated":"un00fin00","comments":true,"path":"posts/Mysql常见问题操作指导/","link":"","permalink":"http://ruanxinyu.github.io/posts/Mysql常见问题操作指导/","excerpt":"","keywords":"","text":"快速查询目录 启动windows如何启动mysql执行net start mysql80（需要用管理员权限启动，否则会报拒绝访问错误），或者通过如下方式： windows下mysq的数据和配置文件存放位置默认是在C:\\ProgramData\\MySQL\\目录下 windows启动mysql报拒绝访问错误使用管理员权限启动即可，net start mysql80 windows下mysql的日志位置在C:\\ProgramData\\MySQL\\MySQL Server 8.0\\Data\\下，可以通过C:\\ProgramData\\MySQL\\MySQL Server 8.0\\my.ini看到具体的文件名称： windows下mysql启动失败查看mysql的错误日志发现如下内容TCP/IP, --shared-memory, or --named-pipe should be configured on NT OS。 有两种解决方式，一种是取消注释enable-named-pipe， 二是取消注释shared-memory。这两个参数在my.ini的位置是在一起的，如下所示： 权限如何添加用户权限老版本授权格式：grant 权限 on 数据库.* to 用户名@登录主机 identified by &quot;密码&quot;; 12grant all privileges on mall.* to 'malluser'@'%' identified by 'mall@123';flush privileges; 8.0版本: 创建账户和赋予权限分开，如果采用上面的方式会提示Error Code: 1064. You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;IDENTIFIED BY &#39;mall@1234&#39;&#39;,，因此需要采用下面的方式： 创建账户: create user &#39;用户名&#39;@&#39;访问主机&#39; identified by &#39;密码&#39;; 赋予权限: grant 权限列表 on 数据库 to &#39;用户名&#39;@&#39;访问主机&#39;;（修改权限时在后面加with grant option） 123create user malluser@'%' identified by 'mall@123';grant all privileges on mall.* to 'malluser'@'%' with grant option;flush privileges; 忘记root的密码首先，编辑sudo vim /etc/mysql/my.cnf，在[mysqld]下添加skip-grant-tables，然后重启sudo systemctl restart mysql.service，然后就可以通过mysql -u root进入到mysql的控制台。 执行mysql命令进入到mysql的控制台，执行如下命令修改密码： mysql 5.7.9版本之前 123use mysql;update user set Password = password ( 'new-password' ) where User = 'root';flush privileges; mysql 5.7.9版本之后 1234use mysql;update user set authentication_string='' where user='root';flush privileges;ALTER user 'root'@'localhost' IDENTIFIED BY 'root@123'; 最后，删除skip-grant-tables配置并重启mysql即可完成密码的修改。 修改权限提示–skip-grant-tables下不能执行该操作提示The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement，在执行之前执行一下flush privileges;即可。","raw":"---\ntitle: Mysql常见问题操作指导\ntags: 飞行手册\ncategories: 飞行手册\nquestions: 2\ndate: 2018-10-06 09:39:34\n---\n\n# 快速查询目录\n\n<!-- page_toc -->  \n\n# 启动\n\n## windows如何启动mysql\n\n执行`net start mysql80`（需要用管理员权限启动，否则会报拒绝访问错误），或者通过如下方式：\n\n{% asset_img 2018-10-06-11-16-52.png [blog.ruanxinyu.cn] %}\n\n## windows下mysq的数据和配置文件存放位置\n\n默认是在`C:\\ProgramData\\MySQL\\`目录下\n\n## windows启动mysql报拒绝访问错误\n\n使用管理员权限启动即可，`net start mysql80`\n\n## windows下mysql的日志位置\n\n在`C:\\ProgramData\\MySQL\\MySQL Server 8.0\\Data\\`下，可以通过`C:\\ProgramData\\MySQL\\MySQL Server 8.0\\my.ini`看到具体的文件名称：\n\n{% asset_img 2018-10-06-11-41-08.png [blog.ruanxinyu.cn] %}\n\n## windows下mysql启动失败\n\n查看mysql的错误日志发现如下内容`TCP/IP, --shared-memory, or --named-pipe should be configured on NT OS`。\n\n有两种解决方式，一种是取消注释`enable-named-pipe`， 二是取消注释`shared-memory`。这两个参数在`my.ini`的位置是在一起的，如下所示：\n\n{% asset_img 2018-10-06-11-46-31.png [blog.ruanxinyu.cn] %}\n\n# 权限\n\n## 如何添加用户权限\n\n**老版本**\n授权格式：`grant 权限 on 数据库.* to 用户名@登录主机 identified by \"密码\";`\n\n```sql\ngrant all privileges on mall.* to 'malluser'@'%' identified by 'mall@123';\nflush privileges;\n```\n\n** 8.0版本: **\n创建账户和赋予权限分开，如果采用上面的方式会提示`Error Code: 1064. You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'IDENTIFIED BY 'mall@1234''`,，因此需要采用下面的方式：\n\n创建账户: `create user '用户名'@'访问主机' identified by '密码';`\n\n赋予权限: `grant 权限列表 on 数据库 to '用户名'@'访问主机';`（修改权限时在后面加`with grant option`）\n\n```sql\ncreate user malluser@'%' identified by 'mall@123';\ngrant all privileges on mall.* to 'malluser'@'%' with grant option;\nflush privileges;\n```\n\n## 忘记root的密码\n\n首先，编辑`sudo vim /etc/mysql/my.cnf`，在`[mysqld]`下添加`skip-grant-tables`，然后重启`sudo systemctl restart mysql.service`，然后就可以通过`mysql -u root`进入到mysql的控制台。\n\n执行`mysql`命令进入到mysql的控制台，执行如下命令修改密码：\n\n**mysql 5.7.9版本之前**\n\n```sql\nuse mysql;\nupdate user set Password = password ( 'new-password' ) where User = 'root';\nflush privileges;\n```\n\n**mysql 5.7.9版本之后**\n\n```sql\nuse mysql;\nupdate user set authentication_string='' where user='root';\nflush privileges;\nALTER user 'root'@'localhost' IDENTIFIED BY 'root@123';\n```\n\n最后，删除`skip-grant-tables`配置并重启mysql即可完成密码的修改。\n\n## 修改权限提示--skip-grant-tables下不能执行该操作\n\n提示`The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement`，在执行之前执行一下`flush privileges;`即可。","content":"<h1 id=\"快速查询目录\"><a href=\"#快速查询目录\" class=\"headerlink\" title=\"快速查询目录\"></a>快速查询目录</h1><!-- page_toc -->  \n<h1 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h1><h2 id=\"windows如何启动mysql\"><a href=\"#windows如何启动mysql\" class=\"headerlink\" title=\"windows如何启动mysql\"></a>windows如何启动mysql</h2><p>执行<code>net start mysql80</code>（需要用管理员权限启动，否则会报拒绝访问错误），或者通过如下方式：</p>\n<img src=\"/posts/Mysql常见问题操作指导/2018-10-06-11-16-52.png\" title=\"[blog.ruanxinyu.cn]\">\n<h2 id=\"windows下mysq的数据和配置文件存放位置\"><a href=\"#windows下mysq的数据和配置文件存放位置\" class=\"headerlink\" title=\"windows下mysq的数据和配置文件存放位置\"></a>windows下mysq的数据和配置文件存放位置</h2><p>默认是在<code>C:\\ProgramData\\MySQL\\</code>目录下</p>\n<h2 id=\"windows启动mysql报拒绝访问错误\"><a href=\"#windows启动mysql报拒绝访问错误\" class=\"headerlink\" title=\"windows启动mysql报拒绝访问错误\"></a>windows启动mysql报拒绝访问错误</h2><p>使用管理员权限启动即可，<code>net start mysql80</code></p>\n<h2 id=\"windows下mysql的日志位置\"><a href=\"#windows下mysql的日志位置\" class=\"headerlink\" title=\"windows下mysql的日志位置\"></a>windows下mysql的日志位置</h2><p>在<code>C:\\ProgramData\\MySQL\\MySQL Server 8.0\\Data\\</code>下，可以通过<code>C:\\ProgramData\\MySQL\\MySQL Server 8.0\\my.ini</code>看到具体的文件名称：</p>\n<img src=\"/posts/Mysql常见问题操作指导/2018-10-06-11-41-08.png\" title=\"[blog.ruanxinyu.cn]\">\n<h2 id=\"windows下mysql启动失败\"><a href=\"#windows下mysql启动失败\" class=\"headerlink\" title=\"windows下mysql启动失败\"></a>windows下mysql启动失败</h2><p>查看mysql的错误日志发现如下内容<code>TCP/IP, --shared-memory, or --named-pipe should be configured on NT OS</code>。</p>\n<p>有两种解决方式，一种是取消注释<code>enable-named-pipe</code>， 二是取消注释<code>shared-memory</code>。这两个参数在<code>my.ini</code>的位置是在一起的，如下所示：</p>\n<img src=\"/posts/Mysql常见问题操作指导/2018-10-06-11-46-31.png\" title=\"[blog.ruanxinyu.cn]\">\n<h1 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h1><h2 id=\"如何添加用户权限\"><a href=\"#如何添加用户权限\" class=\"headerlink\" title=\"如何添加用户权限\"></a>如何添加用户权限</h2><p><strong>老版本</strong><br>授权格式：<code>grant 权限 on 数据库.* to 用户名@登录主机 identified by &quot;密码&quot;;</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">grant</span> all <span class=\"keyword\">privileges</span> <span class=\"keyword\">on</span> mall.* <span class=\"keyword\">to</span> <span class=\"string\">'malluser'</span>@<span class=\"string\">'%'</span> <span class=\"keyword\">identified</span> <span class=\"keyword\">by</span> <span class=\"string\">'mall@123'</span>;</span><br><span class=\"line\"><span class=\"keyword\">flush</span> <span class=\"keyword\">privileges</span>;</span><br></pre></td></tr></table></figure>\n<p><strong> 8.0版本: </strong><br>创建账户和赋予权限分开，如果采用上面的方式会提示<code>Error Code: 1064. You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;IDENTIFIED BY &#39;mall@1234&#39;&#39;</code>,，因此需要采用下面的方式：</p>\n<p>创建账户: <code>create user &#39;用户名&#39;@&#39;访问主机&#39; identified by &#39;密码&#39;;</code></p>\n<p>赋予权限: <code>grant 权限列表 on 数据库 to &#39;用户名&#39;@&#39;访问主机&#39;;</code>（修改权限时在后面加<code>with grant option</code>）</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">user</span> malluser@<span class=\"string\">'%'</span> <span class=\"keyword\">identified</span> <span class=\"keyword\">by</span> <span class=\"string\">'mall@123'</span>;</span><br><span class=\"line\"><span class=\"keyword\">grant</span> all <span class=\"keyword\">privileges</span> <span class=\"keyword\">on</span> mall.* <span class=\"keyword\">to</span> <span class=\"string\">'malluser'</span>@<span class=\"string\">'%'</span> <span class=\"keyword\">with</span> <span class=\"keyword\">grant</span> <span class=\"keyword\">option</span>;</span><br><span class=\"line\"><span class=\"keyword\">flush</span> <span class=\"keyword\">privileges</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"忘记root的密码\"><a href=\"#忘记root的密码\" class=\"headerlink\" title=\"忘记root的密码\"></a>忘记root的密码</h2><p>首先，编辑<code>sudo vim /etc/mysql/my.cnf</code>，在<code>[mysqld]</code>下添加<code>skip-grant-tables</code>，然后重启<code>sudo systemctl restart mysql.service</code>，然后就可以通过<code>mysql -u root</code>进入到mysql的控制台。</p>\n<p>执行<code>mysql</code>命令进入到mysql的控制台，执行如下命令修改密码：</p>\n<p><strong>mysql 5.7.9版本之前</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> mysql;</span><br><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">user</span> <span class=\"keyword\">set</span> <span class=\"keyword\">Password</span> = <span class=\"keyword\">password</span> ( <span class=\"string\">'new-password'</span> ) <span class=\"keyword\">where</span> <span class=\"keyword\">User</span> = <span class=\"string\">'root'</span>;</span><br><span class=\"line\"><span class=\"keyword\">flush</span> <span class=\"keyword\">privileges</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>mysql 5.7.9版本之后</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> mysql;</span><br><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">user</span> <span class=\"keyword\">set</span> authentication_string=<span class=\"string\">''</span> <span class=\"keyword\">where</span> <span class=\"keyword\">user</span>=<span class=\"string\">'root'</span>;</span><br><span class=\"line\"><span class=\"keyword\">flush</span> <span class=\"keyword\">privileges</span>;</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">user</span> <span class=\"string\">'root'</span>@<span class=\"string\">'localhost'</span> <span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">BY</span> <span class=\"string\">'root@123'</span>;</span><br></pre></td></tr></table></figure>\n<p>最后，删除<code>skip-grant-tables</code>配置并重启mysql即可完成密码的修改。</p>\n<h2 id=\"修改权限提示–skip-grant-tables下不能执行该操作\"><a href=\"#修改权限提示–skip-grant-tables下不能执行该操作\" class=\"headerlink\" title=\"修改权限提示–skip-grant-tables下不能执行该操作\"></a>修改权限提示–skip-grant-tables下不能执行该操作</h2><p>提示<code>The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement</code>，在执行之前执行一下<code>flush privileges;</code>即可。</p>\n","categories":[{"name":"飞行手册","slug":"飞行手册","permalink":"http://ruanxinyu.github.io/categories/飞行手册/"}],"tags":[{"name":"飞行手册","slug":"飞行手册","permalink":"http://ruanxinyu.github.io/tags/飞行手册/"}]},{"title":"Ubuntu常见问题操作指导","slug":"Ubuntu常见问题操作指导","date":"un44fin44","updated":"un00fin00","comments":true,"path":"posts/Ubuntu常见问题操作指导/","link":"","permalink":"http://ruanxinyu.github.io/posts/Ubuntu常见问题操作指导/","excerpt":"","keywords":"","text":"如何重启网卡重启网卡可以使用ip，ifconfig和service命令，如下所示，推荐使用ip命令。 12345678910# 推荐使用ip命令sudo ip link set enp0s3 downsudo ip link set enp0s3 up# 使用ifconfig命令sudo ifconfig enp0s3 downsudo ifconfig enp0s3 up# 使用service命令，但是不支持最新版的Ubuntusudo service network restart 如何临时添加-修改-删除IP地址可以使用ip和ifconfig命令，如下所示，推荐使用ip命令。 12345678# 推荐使用ip命令sudo ip address add 192.168.1.135/32 dev enp0s3 # 添加sudo ip address change 192.168.1.135/24 dev enp0s3 # 修改sudo ip address del 192.168.1.135/24 dev enp0s3 # 删除# 使用ifconfig命令sudo ifconfig eth0 192.168.1.135 netmask 255.255.255.0 如何设置静态IP地址和DNS 由于Ubuntu从17.10开始改用netplan方式管理，因此在不同版本设置方式不一样。 Ubuntu 17.10版本前，编辑sudo vim /etc/network/interfaces文件，添加如下的内容，然后重启网卡即可。 123456auto enp0s3iface enp0s3 inet staticaddress 192.168.1.132netmask 255.255.255.0gateway 192.168.1.1dns-nameserver 192.168.1.1 Ubuntu 17.10版本后，编辑netplan方式的配置文件sudo vim /etc/netplan/50-cloud-init.yaml，设置如下内容，然后执行sudo netplan apply即可立即生效。 12345678910network: ethernets: enp0s3: # 配置的网卡名称 dhcp4: no # dhcp4关闭 dhcp6: no # dhcp6关闭 addresses: [192.168.1.132/24] # 设置本机IP及掩码 gateway4: 192.168.1.1 # 设置网关 nameservers: addresses: [192.168.1.1] # 设置DNS version: 2 如何查看和设置DNS 修改/etc/resolv.conf文件是无效的，该文件每次重启会被自动覆盖 如果是修改单个网卡的DNS请参见：如何设置静态IP地址和DNS 如果是设置全局DNS，请编辑sudo vim /etc/systemd/resolved.conf，然后重启systemd-resolved服务sudo systemctl restart systemd-resolved.service即可。 查看当前正在使用的DNS可以使用sudo systemd-resolve --status","raw":"---\ntitle: Ubuntu常见问题操作指导\ntags: 飞行手册\ncategories: 飞行手册\nquestions: 1,2\ndate: 2018-10-04 21:27:53\n---\n\n# 如何重启网卡\n\n重启网卡可以使用`ip`，`ifconfig`和`service`命令，如下所示，推荐使用`ip`命令。\n\n```bash\n# 推荐使用ip命令\nsudo ip link set enp0s3 down\nsudo ip link set enp0s3 up\n\n# 使用ifconfig命令\nsudo ifconfig enp0s3 down\nsudo ifconfig enp0s3 up\n\n# 使用service命令，但是不支持最新版的Ubuntu\nsudo service network restart\n```\n\n# 如何临时添加-修改-删除IP地址\n\n可以使用`ip`和`ifconfig`命令，如下所示，推荐使用`ip`命令。\n\n```bash\n\n# 推荐使用ip命令\nsudo ip address add 192.168.1.135/32 dev enp0s3     # 添加\nsudo ip address change 192.168.1.135/24 dev enp0s3  # 修改\nsudo ip address del 192.168.1.135/24 dev enp0s3     # 删除\n\n# 使用ifconfig命令\nsudo ifconfig eth0 192.168.1.135 netmask 255.255.255.0\n```\n\n# 如何设置静态IP地址和DNS\n\n> 由于Ubuntu从`17.10`开始改用`netplan`方式管理，因此在不同版本设置方式不一样。\n\n**Ubuntu 17.10版本前**，编辑`sudo vim /etc/network/interfaces`文件，添加如下的内容，然后重启网卡即可。\n\n```bash\nauto enp0s3\niface enp0s3 inet static\naddress 192.168.1.132\nnetmask 255.255.255.0\ngateway 192.168.1.1\ndns-nameserver 192.168.1.1\n```\n\n** Ubuntu 17.10版本后**，编辑`netplan`方式的配置文件`sudo vim /etc/netplan/50-cloud-init.yaml`，设置如下内容，然后执行`sudo netplan apply`即可立即生效。\n\n```yml\nnetwork:\n    ethernets:\n        enp0s3:   # 配置的网卡名称\n            dhcp4: no    # dhcp4关闭\n            dhcp6: no    # dhcp6关闭\n            addresses: [192.168.1.132/24]   # 设置本机IP及掩码\n            gateway4: 192.168.1.1      # 设置网关\n            nameservers:\n            addresses: [192.168.1.1]   # 设置DNS\n    version: 2\n```\n\n# 如何查看和设置DNS\n\n> 修改`/etc/resolv.conf`文件是无效的，该文件每次重启会被自动覆盖\n\n如果是修改单个网卡的DNS请参见：[如何设置静态IP地址和DNS](#如何设置静态IP地址和DNS)\n\n如果是设置全局DNS，请编辑`sudo vim /etc/systemd/resolved.conf`，然后重启`systemd-resolved`服务`sudo systemctl restart systemd-resolved.service`即可。\n\n查看当前正在使用的DNS可以使用`sudo systemd-resolve --status`\n","content":"<h1 id=\"如何重启网卡\"><a href=\"#如何重启网卡\" class=\"headerlink\" title=\"如何重启网卡\"></a>如何重启网卡</h1><p>重启网卡可以使用<code>ip</code>，<code>ifconfig</code>和<code>service</code>命令，如下所示，推荐使用<code>ip</code>命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 推荐使用ip命令</span></span><br><span class=\"line\">sudo ip link <span class=\"built_in\">set</span> enp0s3 down</span><br><span class=\"line\">sudo ip link <span class=\"built_in\">set</span> enp0s3 up</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用ifconfig命令</span></span><br><span class=\"line\">sudo ifconfig enp0s3 down</span><br><span class=\"line\">sudo ifconfig enp0s3 up</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用service命令，但是不支持最新版的Ubuntu</span></span><br><span class=\"line\">sudo service network restart</span><br></pre></td></tr></table></figure>\n<h1 id=\"如何临时添加-修改-删除IP地址\"><a href=\"#如何临时添加-修改-删除IP地址\" class=\"headerlink\" title=\"如何临时添加-修改-删除IP地址\"></a>如何临时添加-修改-删除IP地址</h1><p>可以使用<code>ip</code>和<code>ifconfig</code>命令，如下所示，推荐使用<code>ip</code>命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 推荐使用ip命令</span></span><br><span class=\"line\">sudo ip address add 192.168.1.135/32 dev enp0s3     <span class=\"comment\"># 添加</span></span><br><span class=\"line\">sudo ip address change 192.168.1.135/24 dev enp0s3  <span class=\"comment\"># 修改</span></span><br><span class=\"line\">sudo ip address del 192.168.1.135/24 dev enp0s3     <span class=\"comment\"># 删除</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用ifconfig命令</span></span><br><span class=\"line\">sudo ifconfig eth0 192.168.1.135 netmask 255.255.255.0</span><br></pre></td></tr></table></figure>\n<h1 id=\"如何设置静态IP地址和DNS\"><a href=\"#如何设置静态IP地址和DNS\" class=\"headerlink\" title=\"如何设置静态IP地址和DNS\"></a>如何设置静态IP地址和DNS</h1><blockquote>\n<p>由于Ubuntu从<code>17.10</code>开始改用<code>netplan</code>方式管理，因此在不同版本设置方式不一样。</p>\n</blockquote>\n<p><strong>Ubuntu 17.10版本前</strong>，编辑<code>sudo vim /etc/network/interfaces</code>文件，添加如下的内容，然后重启网卡即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto enp0s3</span><br><span class=\"line\">iface enp0s3 inet static</span><br><span class=\"line\">address 192.168.1.132</span><br><span class=\"line\">netmask 255.255.255.0</span><br><span class=\"line\">gateway 192.168.1.1</span><br><span class=\"line\">dns-nameserver 192.168.1.1</span><br></pre></td></tr></table></figure>\n<p><strong> Ubuntu 17.10版本后</strong>，编辑<code>netplan</code>方式的配置文件<code>sudo vim /etc/netplan/50-cloud-init.yaml</code>，设置如下内容，然后执行<code>sudo netplan apply</code>即可立即生效。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">network:</span></span><br><span class=\"line\"><span class=\"attr\">    ethernets:</span></span><br><span class=\"line\"><span class=\"attr\">        enp0s3:</span>   <span class=\"comment\"># 配置的网卡名称</span></span><br><span class=\"line\"><span class=\"attr\">            dhcp4:</span> <span class=\"literal\">no</span>    <span class=\"comment\"># dhcp4关闭</span></span><br><span class=\"line\"><span class=\"attr\">            dhcp6:</span> <span class=\"literal\">no</span>    <span class=\"comment\"># dhcp6关闭</span></span><br><span class=\"line\"><span class=\"attr\">            addresses:</span> <span class=\"string\">[192.168.1.132/24]</span>   <span class=\"comment\"># 设置本机IP及掩码</span></span><br><span class=\"line\"><span class=\"attr\">            gateway4:</span> <span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"number\">.1</span>      <span class=\"comment\"># 设置网关</span></span><br><span class=\"line\"><span class=\"attr\">            nameservers:</span></span><br><span class=\"line\"><span class=\"attr\">            addresses:</span> <span class=\"string\">[192.168.1.1]</span>   <span class=\"comment\"># 设置DNS</span></span><br><span class=\"line\"><span class=\"attr\">    version:</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"如何查看和设置DNS\"><a href=\"#如何查看和设置DNS\" class=\"headerlink\" title=\"如何查看和设置DNS\"></a>如何查看和设置DNS</h1><blockquote>\n<p>修改<code>/etc/resolv.conf</code>文件是无效的，该文件每次重启会被自动覆盖</p>\n</blockquote>\n<p>如果是修改单个网卡的DNS请参见：<a href=\"#如何设置静态IP地址和DNS\">如何设置静态IP地址和DNS</a></p>\n<p>如果是设置全局DNS，请编辑<code>sudo vim /etc/systemd/resolved.conf</code>，然后重启<code>systemd-resolved</code>服务<code>sudo systemctl restart systemd-resolved.service</code>即可。</p>\n<p>查看当前正在使用的DNS可以使用<code>sudo systemd-resolve --status</code></p>\n","categories":[{"name":"飞行手册","slug":"飞行手册","permalink":"http://ruanxinyu.github.io/categories/飞行手册/"}],"tags":[{"name":"飞行手册","slug":"飞行手册","permalink":"http://ruanxinyu.github.io/tags/飞行手册/"}]},{"title":"Ubuntu下Mysql的安装与验证","slug":"Ubuntu下Mysql的安装与验证","date":"un44fin44","updated":"un55fin55","comments":true,"path":"posts/Ubuntu下Mysql的安装与验证/","link":"","permalink":"http://ruanxinyu.github.io/posts/Ubuntu下Mysql的安装与验证/","excerpt":"","keywords":"","text":"apt方式安装 Ubuntu 18.04.1版本下，如果直接使用sudo apt-get install mysql-server安装的是5.9版本，我们要安装最新的8.0版本。 首先进去到https://dev.mysql.com/downloads/repo/apt/页面，下载deb包 点击下载按钮后，我们也可以页面中获取下载地址，然后通过wget下载： 通过wget下载后通过执行dpkg命令安装deb包，并且在弹出的框中我们选择8.0版本： 12wget https://dev.mysql.com/get/mysql-apt-config_0.8.10-1_all.debsudo dpkg -i mysql-apt-config_0.8.10-1_all.deb # 在弹出的框中我们选择8.0版本 由于安装过程中需要使用到libmecab2包，所以也需要提前安装好，否则会提示Depends: mysql-community-server (= 8.0.12-1ubuntu18.04) but it is not going to be installed。 12wget http://security.ubuntu.com/ubuntu/pool/universe/m/mecab/libmecab2_0.996-5_amd64.debsudo dpkg -i libmecab2_0.996-5_amd64.deb 安装好libmecab2后就可以安装mysql-server了。 12sudo apt-get updatesudo apt-get install mysql-server 安装过程中会提示用户选择密码的加密方式，由于Mysql 8.0开始支持更加安全的基于SHA256的加密方式，但是老的驱动是不支持该加密方式，所以如果已经有其他程序使用该Mysql，需要保持兼容，则选择兼容模式，否则推荐使用最一种模式。 启动与开机启动安装完成后mysql自动已经起来，可以通过systemctl命令启动，停止和查看mysql，并且加入到开机启动。 1234sudo systemctl stop mysql.servicesudo systemctl start mysql.servicesudo systemctl status mysql.servicesudo systemctl enable mysql.service mysql的相关目录及文件位置说明： 用户配置文件位置：/etc/mysql/my.cnf pid文件位置：/var/run/mysqld/mysqld.pid socket文件位置：/var/run/mysqld/mysqld.sock 数据目录： /var/lib/mysql 错误日志文件： /var/log/mysql/error.log 在控制台执行mysql -u root -p，输入密码就可以进入","raw":"---\ntitle: Ubuntu下Mysql的安装与验证\ntags: 环境搭建\ncategories: 环境搭建\ndate: 2018-10-04 21:21:18\n---\n\n# apt方式安装\n\n> Ubuntu 18.04.1版本下，如果直接使用`sudo apt-get install mysql-server`安装的是`5.9`版本，我们要安装最新的`8.0`版本。\n\n首先进去到[https://dev.mysql.com/downloads/repo/apt/](https://dev.mysql.com/downloads/repo/apt/)页面，下载deb包\n\n{% asset_img 2018-10-05-16-32-48.png [blog.ruanxinyu.cn] %}\n\n点击下载按钮后，我们也可以页面中获取下载地址，然后通过wget下载：\n\n{% asset_img 2018-10-05-16-35-06.png [blog.ruanxinyu.cn] %}\n\n通过wget下载后通过执行`dpkg`命令安装deb包，并且在弹出的框中我们选择8.0版本：\n\n```bash\nwget https://dev.mysql.com/get/mysql-apt-config_0.8.10-1_all.deb\nsudo dpkg -i mysql-apt-config_0.8.10-1_all.deb # 在弹出的框中我们选择8.0版本\n```\n\n{% asset_img 2018-10-05-16-38-20.png [blog.ruanxinyu.cn] %}\n\n由于安装过程中需要使用到`libmecab2`包，所以也需要提前安装好，否则会提示`Depends: mysql-community-server (= 8.0.12-1ubuntu18.04) but it is not going to be installed`。\n\n```bash\nwget http://security.ubuntu.com/ubuntu/pool/universe/m/mecab/libmecab2_0.996-5_amd64.deb\nsudo dpkg -i libmecab2_0.996-5_amd64.deb\n```\n\n安装好`libmecab2`后就可以安装`mysql-server`了。\n\n```bash\nsudo apt-get update\nsudo apt-get install mysql-server\n```\n\n安装过程中会提示用户选择密码的加密方式，由于`Mysql 8.0`开始支持更加安全的基于SHA256的加密方式，但是老的驱动是不支持该加密方式，所以如果已经有其他程序使用该Mysql，需要保持兼容，则选择兼容模式，否则推荐使用最一种模式。\n\n{% asset_img 2018-10-05-17-05-49.png [blog.ruanxinyu.cn] %}\n\n# 启动与开机启动\n\n安装完成后mysql自动已经起来，可以通过`systemctl`命令启动，停止和查看mysql，并且加入到开机启动。\n\n```bash\nsudo systemctl stop mysql.service\nsudo systemctl start mysql.service\nsudo systemctl status mysql.service\nsudo systemctl enable mysql.service\n```\n\nmysql的相关目录及文件位置说明：\n\n1. 用户配置文件位置：`/etc/mysql/my.cnf`\n1. pid文件位置：`/var/run/mysqld/mysqld.pid`\n1. socket文件位置：`/var/run/mysqld/mysqld.sock`\n1. 数据目录： `/var/lib/mysql`\n1. 错误日志文件： `/var/log/mysql/error.log`\n\n在控制台执行`mysql -u root -p`，输入密码就可以进入\n{% asset_img 2018-10-05-18-58-08.png [blog.ruanxinyu.cn] %}\n","content":"<h1 id=\"apt方式安装\"><a href=\"#apt方式安装\" class=\"headerlink\" title=\"apt方式安装\"></a>apt方式安装</h1><blockquote>\n<p>Ubuntu 18.04.1版本下，如果直接使用<code>sudo apt-get install mysql-server</code>安装的是<code>5.9</code>版本，我们要安装最新的<code>8.0</code>版本。</p>\n</blockquote>\n<p>首先进去到<a href=\"https://dev.mysql.com/downloads/repo/apt/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/downloads/repo/apt/</a>页面，下载deb包</p>\n<img src=\"/posts/Ubuntu下Mysql的安装与验证/2018-10-05-16-32-48.png\" title=\"[blog.ruanxinyu.cn]\">\n<p>点击下载按钮后，我们也可以页面中获取下载地址，然后通过wget下载：</p>\n<img src=\"/posts/Ubuntu下Mysql的安装与验证/2018-10-05-16-35-06.png\" title=\"[blog.ruanxinyu.cn]\">\n<p>通过wget下载后通过执行<code>dpkg</code>命令安装deb包，并且在弹出的框中我们选择8.0版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://dev.mysql.com/get/mysql-apt-config_0.8.10-1_all.deb</span><br><span class=\"line\">sudo dpkg -i mysql-apt-config_0.8.10-1_all.deb <span class=\"comment\"># 在弹出的框中我们选择8.0版本</span></span><br></pre></td></tr></table></figure>\n<img src=\"/posts/Ubuntu下Mysql的安装与验证/2018-10-05-16-38-20.png\" title=\"[blog.ruanxinyu.cn]\">\n<p>由于安装过程中需要使用到<code>libmecab2</code>包，所以也需要提前安装好，否则会提示<code>Depends: mysql-community-server (= 8.0.12-1ubuntu18.04) but it is not going to be installed</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://security.ubuntu.com/ubuntu/pool/universe/m/mecab/libmecab2_0.996-5_amd64.deb</span><br><span class=\"line\">sudo dpkg -i libmecab2_0.996-5_amd64.deb</span><br></pre></td></tr></table></figure>\n<p>安装好<code>libmecab2</code>后就可以安装<code>mysql-server</code>了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure>\n<p>安装过程中会提示用户选择密码的加密方式，由于<code>Mysql 8.0</code>开始支持更加安全的基于SHA256的加密方式，但是老的驱动是不支持该加密方式，所以如果已经有其他程序使用该Mysql，需要保持兼容，则选择兼容模式，否则推荐使用最一种模式。</p>\n<img src=\"/posts/Ubuntu下Mysql的安装与验证/2018-10-05-17-05-49.png\" title=\"[blog.ruanxinyu.cn]\">\n<h1 id=\"启动与开机启动\"><a href=\"#启动与开机启动\" class=\"headerlink\" title=\"启动与开机启动\"></a>启动与开机启动</h1><p>安装完成后mysql自动已经起来，可以通过<code>systemctl</code>命令启动，停止和查看mysql，并且加入到开机启动。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl stop mysql.service</span><br><span class=\"line\">sudo systemctl start mysql.service</span><br><span class=\"line\">sudo systemctl status mysql.service</span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">enable</span> mysql.service</span><br></pre></td></tr></table></figure>\n<p>mysql的相关目录及文件位置说明：</p>\n<ol>\n<li>用户配置文件位置：<code>/etc/mysql/my.cnf</code></li>\n<li>pid文件位置：<code>/var/run/mysqld/mysqld.pid</code></li>\n<li>socket文件位置：<code>/var/run/mysqld/mysqld.sock</code></li>\n<li>数据目录： <code>/var/lib/mysql</code></li>\n<li>错误日志文件： <code>/var/log/mysql/error.log</code></li>\n</ol>\n<p>在控制台执行<code>mysql -u root -p</code>，输入密码就可以进入<br><img src=\"/posts/Ubuntu下Mysql的安装与验证/2018-10-05-18-58-08.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/categories/环境搭建/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/tags/环境搭建/"}]},{"title":"Git常见问题操作指导","slug":"Git常见问题操作指导","date":"un44fin44","updated":"un00fin00","comments":true,"path":"posts/Git常见问题操作指导/","link":"","permalink":"http://ruanxinyu.github.io/posts/Git常见问题操作指导/","excerpt":"","keywords":"","text":"图形化客户端强烈推荐：SmartGit， 本文是基于Git飞行规则上做的修改与补充。 快速查询目录 为了清楚的表述，这篇文档里的所有例子使用了自定义的bash 提示，以便指示当前分支和是否有暂存的变化(changes)。分支名用小括号括起来，分支名后面跟的*表示暂存的变化(changes)。 编辑提交(editting commits)刚才提交了什么如果你用 git commit -a 提交了一次变化(changes)，而你又不确定到底这次提交了哪些内容。 你就可以用下面的命令显示当前HEAD上的最近一次的提交(commit): 1(master)$ git show 或者 1$ git log -n1 -p 提交信息写错了如果你的提交信息(commit message)写错了且这次提交(commit)还没有推(push), 你可以通过下面的方法来修改提交信息(commit message): 1$ git commit --amend 这会打开你的默认编辑器, 在这里你可以编辑信息. 另一方面, 你也可以用一条命令一次完成: 1$ git commit --amend -m 'xxxxxxx' 如果你已经推(push)了这次提交(commit), 你可以修改这次提交(commit)然后强推(force push), 但是不推荐这么做。 提交里的用户名和邮箱不对如果这只是单个提交(commit)，修改它： 1$ git commit --amend --author \"New Authorname &lt;authoremail@mydomain.com&gt;\" 如果你需要修改所有历史, 参考 ‘git filter-branch’的指南页. 想从一个提交里移除一个文件通过下面的方法，从一个提交(commit)里移除一个文件: 123$ git checkout HEAD^ myfile$ git add -A$ git commit --amend 这将非常有用，当你有一个开放的补丁(open patch)，你往上面提交了一个不必要的文件，你需要强推(force push)去更新这个远程补丁。 想删除最后一次提交如果你需要删除推了的提交(pushed commits)，你可以使用下面的方法。可是，这会不可逆的改变你的历史，也会搞乱那些已经从该仓库拉取(pulled)了的人的历史。简而言之，如果你不是很确定，千万不要这么做。 12$ git reset HEAD^ --hard$ git push -f [remote] [branch] 如果你还没有推到远程, 把Git重置(reset)到你最后一次提交前的状态就可以了(同时保存暂存的变化): 1(my-branch*)$ git reset --soft HEAD@&#123;1&#125; 这只能在没有推送之前有用. 如果你已经推了, 唯一安全能做的是 git revert SHAofBadCommit， 那会创建一个新的提交(commit)用于撤消前一个提交的所有变化(changes)； 或者, 如果你推的这个分支是rebase-safe的 (例如： 其它开发者不会从这个分支拉), 只需要使用 git push -f； 更多, 请参考 the above section。 删除任意提交同样的警告：不到万不得已的时候不要这么做. 12$ git rebase --onto SHA1_OF_BAD_COMMIT^ SHA1_OF_BAD_COMMIT$ git push -f [remote] [branch] 或者做一个 交互式rebase 删除那些你想要删除的提交(commit)里所对应的行。 尝试推一个修正后的提交到远程，但是报错：1234567To https://github.com/yourusername/repo.git! [rejected] mybranch -&gt; mybranch (non-fast-forward)error: failed to push some refs to 'https://github.com/tanay1337/webmaker.org.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 注意, rebasing(见下面)和修正(amending)会用一个新的提交(commit)代替旧的, 所以如果之前你已经往远程仓库上推过一次修正前的提交(commit)，那你现在就必须强推(force push) (-f)。 注意 &ndash; 总是 确保你指明一个分支! 1(my-branch)$ git push origin mybranch -f 一般来说, 要避免强推. 最好是创建和推(push)一个新的提交(commit)，而不是强推一个修正后的提交。后者会使那些与该分支或该分支的子分支工作的开发者，在源历史中产生冲突。 意外的做了一次硬重置，想找回内容如果你意外的做了 git reset --hard, 你通常能找回你的提交(commit), 因为Git对每件事都会有日志，且都会保存几天。 1(master)$ git reflog 你将会看到一个你过去提交(commit)的列表, 和一个重置的提交。 选择你想要回到的提交(commit)的SHA，再重置一次: 1(master)$ git reset --hard SHA1234 这样就完成了。 暂存(Staging)需要把暂存的内容添加到上一次的提交1(my-branch*)$ git commit --amend 想要暂存一个新文件的一部分，而不是这个文件的全部一般来说, 如果你想暂存一个文件的一部分, 你可这样做: 1$ git add --patch filename.x -p 简写。这会打开交互模式， 你将能够用 s 选项来分隔提交(commit)； 然而, 如果这个文件是新的, 会没有这个选择， 添加一个新文件时, 这样做: 1$ git add -N filename.x 然后, 你需要用 e 选项来手动选择需要添加的行，执行 git diff --cached 将会显示哪些行暂存了哪些行只是保存在本地了。 想把在一个文件里的变化加到两个提交里git add 会把整个文件加入到一个提交. git add -p 允许交互式的选择你想要提交的部分. 想把暂存的内容变成未暂存，把未暂存的内容暂存起来这个有点困难， 我能想到的最好的方法是先stash未暂存的内容， 然后重置(reset)，再pop第一步stashed的内容, 最后再add它们。 1234$ git stash -k$ git reset --hard$ git stash pop$ git add -A 未暂存(Unstaged)的内容想把未暂存的内容移动到一个新分支1$ git checkout -b my-branch 想把未暂存的内容移动到另一个已存在的分支123$ git stash$ git checkout my-branch$ git stash pop 想丢弃本地未提交的变化如果你只是想重置源(origin)和你本地(local)之间的一些提交(commit)，你可以： 12345678# one commit(my-branch)$ git reset --hard HEAD^# two commits(my-branch)$ git reset --hard HEAD^^# four commits(my-branch)$ git reset --hard HEAD~4# or(master)$ git checkout -f 重置某个特殊的文件, 你可以用文件名做为参数: 1$ git reset filename 想丢弃某些未暂存的内容如果你想丢弃工作拷贝中的一部分内容，而不是全部。 签出(checkout)不需要的内容，保留需要的。 12$ git checkout -p# Answer y to all of the snippets you want to drop 另外一个方法是使用 stash， Stash所有要保留下的内容, 重置工作拷贝, 重新应用保留的部分。 1234$ git stash -p# Select all of the snippets you want to save$ git reset --hard$ git stash pop 或者, stash 你不需要的部分, 然后stash drop。 123$ git stash -p# Select all of the snippets you don't want to save$ git stash drop 分支(Branches)从错误的分支拉取了内容，或把内容拉取到了错误的分支这是另外一种使用 git reflog 情况，找到在这次错误拉(pull) 之前HEAD的指向。 123(master)$ git reflogab7555f HEAD@&#123;0&#125;: pull origin wrong-branch: Fast-forwardc5bc55a HEAD@&#123;1&#125;: checkout: checkout message goes here 重置分支到你所需的提交(desired commit): 1$ git reset --hard c5bc55a 完成。 想扔掉本地的提交，以便我的分支与远程的保持一致先确认你没有推(push)你的内容到远程。 git status 会显示你领先(ahead)源(origin)多少个提交: 12345(my-branch)$ git status# On branch my-branch# Your branch is ahead of 'origin/my-branch' by 2 commits.# (use \"git push\" to publish your local commits)# 一种方法是: 1(master)$ git reset --hard origin/my-branch 需要提交到一个新分支，但错误的提交到了master在master下创建一个新分支，不切换到新分支,仍在master下: 1(master)$ git branch my-branch 把master分支重置到前一个提交: 1(master)$ git reset --hard HEAD^ HEAD^ 是 HEAD^1 的简写，你可以通过指定要设置的HEAD来进一步重置。 或者, 如果你不想使用 HEAD^, 找到你想重置到的提交(commit)的hash(git log 能够完成)， 然后重置到这个hash。 使用git push 同步内容到远程。 例如, master分支想重置到的提交的hash为a13b85e: 12(master)$ git reset --hard a13b85eHEAD is now at a13b85e 签出(checkout)刚才新建的分支继续工作: 1(master)$ git checkout my-branch 想保留来自另外一个ref-ish的整个文件假设你正在做一个原型方案(原文为working spike (see note)), 有成百的内容，每个都工作得很好。现在, 你提交到了一个分支，保存工作内容: 1(solution)$ git add -A &amp;&amp; git commit -m \"Adding all changes from this spike into one big commit.\" 当你想要把它放到一个分支里 (可能是feature, 或者 develop), 你关心是保持整个文件的完整，你想要一个大的提交分隔成比较小。 假设你有: 分支 solution, 拥有原型方案， 领先 develop 分支。 分支 develop, 在这里你应用原型方案的一些内容。 我去可以通过把内容拿到你的分支里，来解决这个问题: 1(develop)$ git checkout solution -- file1.txt 这会把这个文件内容从分支 solution 拿到分支 develop 里来: 123456# On branch develop# Your branch is up-to-date with 'origin/develop'.# Changes to be committed:# (use \"git reset HEAD &lt;file&gt;...\" to unstage)## modified: file1.txt 然后, 正常提交。 Note: Spike solutions are made to analyze or solve the problem. These solutions are used for estimation and discarded once everyone gets clear visualization of the problem. ~ Wikipedia. 把几个提交提交到了同一个分支，而这些提交应该分布在不同的分支里假设你有一个master分支， 执行git log, 你看到你做过两次提交: 12345678910111213141516171819(master)$ git logcommit e3851e817c451cc36f2e6f3049db528415e3c114Author: Alex Lee &lt;alexlee@example.com&gt;Date: Tue Jul 22 15:39:27 2014 -0400 Bug #21 - Added CSRF protectioncommit 5ea51731d150f7ddc4a365437931cd8be3bf3131Author: Alex Lee &lt;alexlee@example.com&gt;Date: Tue Jul 22 15:39:12 2014 -0400 Bug #14 - Fixed spacing on titlecommit a13b85e984171c6e2a1729bb061994525f626d14Author: Aki Rose &lt;akirose@example.com&gt;Date: Tue Jul 21 01:12:48 2014 -0400 First commit 让我们用提交hash(commit hash)标记bug (e3851e8 for #21, 5ea5173 for #14). 首先, 我们把master分支重置到正确的提交(a13b85e): 12(master)$ git reset --hard a13b85eHEAD is now at a13b85e 现在, 我们对 bug #21 创建一个新的分支: 12(master)$ git checkout -b 21(21)$ 接着, 我们用 cherry-pick 把对bug #21的提交放入当前分支。 这意味着我们将应用(apply)这个提交(commit)，仅仅这一个提交(commit)，直接在HEAD上面。 1(21)$ git cherry-pick e3851e8 这时候, 这里可能会产生冲突， 参见交互式 rebasing 章 冲突节 解决冲突. 再者， 我们为bug #14 创建一个新的分支, 也基于master分支 123(21)$ git checkout master(master)$ git checkout -b 14(14)$ 最后, 为 bug #14 执行 cherry-pick: 1(14)$ git cherry-pick 5ea5173 想删除上游分支被删除了的本地分支一旦你在github 上面合并(merge)了一个pull request, 你就可以删除你fork里被合并的分支。 如果你不准备继续在这个分支里工作, 删除这个分支的本地拷贝会更干净，使你不会陷入工作分支和一堆陈旧分支的混乱之中。 1$ git fetch -p 不小心删除了我的分支如果你定期推送到远程, 多数情况下应该是安全的，但有些时候还是可能删除了还没有推到远程的分支。 让我们先创建一个分支和一个新的文件: 12345(master)$ git checkout -b my-branch(my-branch)$ git branch(my-branch)$ touch foo.txt(my-branch)$ lsREADME.md foo.txt 添加文件并做一次提交 123456789101112131415161718(my-branch)$ git add .(my-branch)$ git commit -m 'foo.txt added'(my-branch)$ foo.txt added 1 files changed, 1 insertions(+) create mode 100644 foo.txt(my-branch)$ git logcommit 4e3cd85a670ced7cc17a2b5d8d3d809ac88d5012Author: siemiatj &lt;siemiatj@example.com&gt;Date: Wed Jul 30 00:34:10 2014 +0200 foo.txt addedcommit 69204cdf0acbab201619d95ad8295928e7f411d5Author: Kate Hudson &lt;katehudson@example.com&gt;Date: Tue Jul 29 13:14:46 2014 -0400 Fixes #6: Force pushing after amending commits 现在我们切回到主(master)分支，‘不小心的’删除my-branch分支 1234567(my-branch)$ git checkout masterSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.(master)$ git branch -D my-branchDeleted branch my-branch (was 4e3cd85).(master)$ echo oh noes, deleted my branch!oh noes, deleted my branch! 在这时候你应该想起了reflog, 一个升级版的日志，它存储了仓库(repo)里面所有动作的历史。 1234(master)$ git reflog69204cd HEAD@&#123;0&#125;: checkout: moving from my-branch to master4e3cd85 HEAD@&#123;1&#125;: commit: foo.txt added69204cd HEAD@&#123;2&#125;: checkout: moving from master to my-branch 正如你所见，我们有一个来自删除分支的提交hash(commit hash)，接下来看看是否能恢复删除了的分支。 123456(master)$ git checkout -b my-branch-helpSwitched to a new branch 'my-branch-help'(my-branch-help)$ git reset --hard 4e3cd85HEAD is now at 4e3cd85 foo.txt added(my-branch-help)$ lsREADME.md foo.txt 看! 我们把删除的文件找回来了。 Git的 reflog 在rebasing出错的时候也是同样有用的。 想删除一个分支删除一个远程分支: 1(master)$ git push origin --delete my-branch 你也可以: 1(master)$ git push origin :my-branch 删除一个本地分支: 1(master)$ git branch -D my-branch 想从别人正在工作的远程分支签出一个分支首先, 从远程拉取(fetch) 所有分支: 1(master)$ git fetch --all 假设你想要从远程的daves分支签出到本地的daves 123(master)$ git checkout --track origin/davesBranch daves set up to track remote branch daves from origin.Switched to a new branch 'daves' (--track 是 git checkout -b [branch] [remotename]/[branch] 的简写) 这样就得到了一个daves分支的本地拷贝, 任何推过(pushed)的更新，远程都能看到. Rebasing 和合并(Merging)想撤销rebase/merge你可以合并(merge)或rebase了一个错误的分支, 或者完成不了一个进行中的rebase/merge。 Git 在进行危险操作的时候会把原始的HEAD保存在一个叫ORIG_HEAD的变量里, 所以要把分支恢复到rebase/merge前的状态是很容易的。 1(my-branch)$ git reset --hard ORIG_HEAD 已经rebase过, 但是我不想强推不幸的是，如果你想把这些变化(changes)反应到远程分支上，你就必须得强推(force push)。 是因你快进(Fast forward)了提交，改变了Git历史, 远程分支不会接受变化(changes)，除非强推(force push)。这就是许多人使用 merge 工作流, 而不是 rebasing 工作流的主要原因之一， 开发者的强推(force push)会使大的团队陷入麻烦。使用时需要注意，一种安全使用 rebase 的方法是，不要把你的变化(changes)反映到远程分支上, 而是按下面的做: 1234(master)$ git checkout my-branch(my-branch)$ git rebase -i master(my-branch)$ git checkout master(master)$ git merge --ff-only my-branch 更多, 参见 this SO thread. 需要组合几个提交假设你的工作分支将会做对于 master 的pull-request。 一般情况下你不关心提交(commit)的时间戳，只想组合 所有 提交(commit) 到一个单独的里面, 然后重置(reset)重提交(recommit)。 确保主(master)分支是最新的和你的变化都已经提交了, 然后: 12(my-branch)$ git reset --soft master(my-branch)$ git commit -am \"New awesome feature\" 如果你想要更多的控制, 想要保留时间戳, 你需要做交互式rebase (interactive rebase): 1(my-branch)$ git rebase -i master 如果没有相对的其它分支， 你将不得不相对自己的HEAD 进行 rebase。 例如：你想组合最近的两次提交(commit), 你将相对于HEAD~2 进行rebase， 组合最近3次提交(commit), 相对于HEAD~3, 等等。 1(master)$ git rebase -i HEAD~2 在你执行了交互式 rebase的命令(interactive rebase command)后, 你将在你的编辑器里看到类似下面的内容: 12345678910111213141516171819202122pick a9c8a1d Some refactoringpick 01b2fd8 New awesome featurepick b729ad5 fixuppick e3851e8 another fix# Rebase 8074d12..b729ad5 onto 8074d12## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like \"squash\", but discard this commit's log message# x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 所有以 # 开头的行都是注释, 不会影响 rebase. 然后，你可以用任何上面命令列表的命令替换 pick, 你也可以通过删除对应的行来删除一个提交(commit)。 例如, 如果你想 单独保留最旧(first)的提交(commit),组合所有剩下的到第二个里面, 你就应该编辑第二个提交(commit)后面的每个提交(commit) 前的单词为 f: 1234pick a9c8a1d Some refactoringpick 01b2fd8 New awesome featuref b729ad5 fixupf e3851e8 another fix 如果你想组合这些提交(commit) 并重命名这个提交(commit), 你应该在第二个提交(commit)旁边添加一个r，或者更简单的用s 替代 f: 1234pick a9c8a1d Some refactoringpick 01b2fd8 New awesome features b729ad5 fixups e3851e8 another fix 你可以在接下来弹出的文本提示框里重命名提交(commit)。 12345678910Newer, awesomer features# Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit.# rebase in progress; onto 8074d12# You are currently editing a commit while rebasing branch 'master' on '8074d12'.## Changes to be committed:# modified: README.md# 如果成功了, 你应该看到类似下面的内容: 1(master)$ Successfully rebased and updated refs/heads/master. 安全合并策略--no-commit 执行合并(merge)但不自动提交, 给用户在做提交前检查和修改的机会。 no-ff 会为特性分支(feature branch)的存在过留下证据, 保持项目历史一致。 1(master)$ git merge --no-ff --no-commit my-branch 需要将一个分支合并成一个提交1(master)$ git merge --squash my-branch 只想组合未推的提交有时候，在将数据推向上游之前，你有几个正在进行的工作提交(commit)。这时候不希望把已经推(push)过的组合进来，因为其他人可能已经有提交(commit)引用它们了。 1(master)$ git rebase -i @&#123;u&#125; 这会产生一次交互式的rebase(interactive rebase), 只会列出没有推(push)的提交(commit)， 在这个列表时进行reorder/fix/squash 都是安全的。 检查是否分支上的所有提交都合并过了检查一个分支上的所有提交(commit)是否都已经合并(merge)到了其它分支, 你应该在这些分支的head(或任何 commits)之间做一次diff: 1(master)$ git log --graph --left-right --cherry-pick --oneline HEAD...feature/120-on-scroll 这会告诉你在一个分支里有而另一个分支没有的所有提交(commit), 和分支之间不共享的提交(commit)的列表。 另一个做法可以是: 1(master)$ git log master ^feature/120-on-scroll --no-merges 交互式rebase可能出现的问题这个rebase编辑屏幕出现’noop’如果你看到的是这样:1noop 这意味着你rebase的分支和当前分支在同一个提交(commit)上, 或者 领先(ahead) 当前分支。 你可以尝试: 检查确保主(master)分支没有问题 rebase HEAD~2 或者更早 有冲突的情况如果你不能成功的完成rebase, 你可能必须要解决冲突。 首先执行 git status 找出哪些文件有冲突: 1234567(my-branch)$ git statusOn branch my-branchChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)truemodified: README.md 在这个例子里面, README.md 有冲突。 打开这个文件找到类似下面的内容: 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADsome code=========some code&gt;&gt;&gt;&gt;&gt;&gt;&gt; new-commit 你需要解决新提交的代码(示例里, 从中间==线到new-commit的地方)与HEAD 之间不一样的地方. 有时候这些合并非常复杂，你应该使用可视化的差异编辑器(visual diff editor): 1(master*)$ git mergetool -t opendiff 在你解决完所有冲突和测试过后, git add 变化了的(changed)文件, 然后用git rebase --continue 继续rebase。 12(my-branch)$ git add README.md(my-branch)$ git rebase --continue 如果在解决完所有的冲突过后，得到了与提交前一样的结果, 可以执行git rebase --skip。 任何时候你想结束整个rebase 过程，回来rebase前的分支状态, 你可以做: 1(my-branch)$ git rebase --abort 杂项(Miscellaneous Objects)克隆所有子模块1$ git clone --recursive git://github.com/foo/bar.git 如果已经克隆了: 1$ git submodule update --init --recursive 删除标签12$ git tag -d &lt;tag_name&gt;$ git push &lt;remote&gt; :refs/tags/&lt;tag_name&gt; 恢复已删除标签如果你想恢复一个已删除标签(tag), 可以按照下面的步骤: 首先, 需要找到无法访问的标签(unreachable tag): 1$ git fsck --unreachable | grep tag 记下这个标签(tag)的hash，然后用Git的 update-ref: 1$ git update-ref refs/tags/&lt;tag_name&gt; &lt;hash&gt; 这时你的标签(tag)应该已经恢复了。 已删除补丁如果某人在 GitHub 上给你发了一个pull request, 但是然后他删除了他自己的原始 fork, 你将没法克隆他们的提交(commit)或使用 git am。在这种情况下, 最好手动的查看他们的提交(commit)，并把它们拷贝到一个本地新分支，然后做提交。 做完提交后, 再修改作者，参见变更作者。 然后, 应用变化, 再发起一个新的pull request。 跟踪文件(Tracking Files)只想改变一个文件名字的大小写，而不修改内容1(master)$ git mv --force myfile MyFile 想从Git删除一个文件，但保留该文件1(master)$ git rm --cached log.txt 配置(Configuration)想给一些Git命令添加别名在 OS X 和 Linux 下, 你的 Git的配置文件储存在 部分添加了一些快捷别名(和一些我容易拼写错误的)，如下:12345678910111213141516171819202122```vim[alias] a = add amend = commit --amend c = commit ca = commit --amend ci = commit -a co = checkout d = diff dc = diff --changed ds = diff --staged f = fetch loll = log --graph --decorate --pretty=oneline --abbrev-commit m = merge one = log --pretty=oneline outstanding = rebase -i @&#123;u&#125; s = status unpushed = log @&#123;u&#125; wc = whatchanged wip = rebase -i @&#123;u&#125; zap = fetch -p 想缓存一个仓库的用户名和密码你可能有一个仓库需要授权，这时你可以缓存用户名和密码，而不用每次推/拉(push/pull)的时候都输入，Credential helper能帮你。 12$ git config --global credential.helper cache# Set git to use the credential memory cache 12$ git config --global credential.helper 'cache --timeout=3600'# Set the cache to timeout after 1 hour (setting is in seconds) 不知道我做错了些什么你把事情搞砸了：你 重置(reset) 了一些东西, 或者你合并了错误的分支, 亦或你强推了后找不到你自己的提交(commit)了。有些时候, 你一直都做得很好, 但你想回到以前的某个状态。 这就是 git reflog 的目的， reflog 记录对分支顶端(the tip of a branch)的任何改变, 即使那个顶端没有被任何分支或标签引用。基本上, 每次HEAD的改变, 一条新的记录就会增加到reflog。遗憾的是，这只对本地分支起作用，且它只跟踪动作 (例如，不会跟踪一个没有被记录的文件的任何改变)。 1234(master)$ git reflog0a2e358 HEAD@&#123;0&#125;: reset: moving to HEAD~20254ea7 HEAD@&#123;1&#125;: checkout: moving from 2.2 to masterc10f740 HEAD@&#123;2&#125;: checkout: moving from master to 2.2 上面的reflog展示了从master分支签出(checkout)到2.2 分支，然后再签回。 那里，还有一个硬重置(hard reset)到一个较旧的提交。最新的动作出现在最上面以 HEAD@{0}标识. 如果事实证明你不小心回移(move back)了提交(commit), reflog 会包含你不小心回移前master上指向的提交(0254ea7)。 1$ git reset --hard 0254ea7 然后使用git reset就可以把master改回到之前的commit，这提供了一个在历史被意外更改情况下的安全网。 (摘自). 其它资源(Other Resources)书(Books) Pro Git - Scott Chacon’s excellent git book Git Internals - Scott Chacon’s other excellent git book 教程(Tutorials) Learn Git branching 一个基于网页的交互式 branching/merging/rebasing 教程 Getting solid at Git rebase vs. merge git-workflow - Aaron Meurer的怎么使用Git为开源仓库贡献 GitHub as a workflow - 使用GitHub做为工作流的趣事, 尤其是空PRs 脚本和工具(Scripts and Tools) firstaidgit.io 一个可搜索的最常被问到的Git的问题 git-extra-commands - 一堆有用的额外的Git脚本 git-extras - GIT 工具集 – repo summary, repl, changelog population, author commit percentages and more git-fire - git-fire 是一个 Git 插件，用于帮助在紧急情况下添加所有当前文件, 做提交(committing), 和推(push)到一个新分支(阻止合并冲突)。 git-tips - Git小提示 git-town - 通用，高级Git工作流支持！ http://www.git-town.com GUI客户端(GUI Clients) GitKraken - 豪华的Git客户端 Windows, Mac &amp; Linux git-cola - 另外一个Git客户端 Windows &amp; OS X GitUp - 一个新的Git客户端，在处理Git的复杂性上有自己的特点 gitx-dev - 图形化的Git客户端 OS X Source Tree - 免费的图形化Git客户端 Windows &amp; OS X Tower - 图形化Git客户端 OS X(付费) SmartGit - 推荐，对个人用户免费","raw":"---\ntitle: Git常见问题操作指导\ntags: 飞行手册\ncategories: 飞行手册\nquestions: 2\ndate: 2018-10-04 13:15:35\n---\n\n> 图形化客户端强烈推荐：[SmartGit](https://www.syntevo.com/smartgit/)， 本文是基于[Git飞行规则](https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md)上做的修改与补充。\n\n# 快速查询目录\n \n<!-- page_toc -->  \n\n> 为了清楚的表述，这篇文档里的所有例子使用了自定义的bash 提示，以便指示当前分支和是否有暂存的变化(changes)。分支名用小括号括起来，分支名后面跟的`*`表示暂存的变化(changes)。\n\n# 编辑提交(editting commits)\n\n## 刚才提交了什么\n\n如果你用 `git commit -a` 提交了一次变化(changes)，而你又不确定到底这次提交了哪些内容。 你就可以用下面的命令显示当前`HEAD`上的最近一次的提交(commit):\n\n```sh\n(master)$ git show\n```\n\n或者\n\n```sh\n$ git log -n1 -p\n```\n\n## 提交信息写错了\n\n如果你的提交信息(commit message)写错了且这次提交(commit)还没有推(push), 你可以通过下面的方法来修改提交信息(commit message):\n\n```sh\n$ git commit --amend\n```\n这会打开你的默认编辑器, 在这里你可以编辑信息. 另一方面, 你也可以用一条命令一次完成:\n\n```sh\n$ git commit --amend -m 'xxxxxxx'\n```\n\n如果你已经推(push)了这次提交(commit), 你可以修改这次提交(commit)然后强推(force push), 但是不推荐这么做。\n\n## 提交里的用户名和邮箱不对\n\n如果这只是单个提交(commit)，修改它：\n\n```sh\n$ git commit --amend --author \"New Authorname <authoremail@mydomain.com>\"\n```\n\n如果你需要修改所有历史, 参考 'git filter-branch'的指南页.\n\n## 想从一个提交里移除一个文件\n\n通过下面的方法，从一个提交(commit)里移除一个文件:\n\n```sh\n$ git checkout HEAD^ myfile\n$ git add -A\n$ git commit --amend\n```\n\n这将非常有用，当你有一个开放的补丁(open patch)，你往上面提交了一个不必要的文件，你需要强推(force push)去更新这个远程补丁。\n\n## 想删除最后一次提交\n\n如果你需要删除推了的提交(pushed commits)，你可以使用下面的方法。可是，这会不可逆的改变你的历史，也会搞乱那些已经从该仓库拉取(pulled)了的人的历史。简而言之，如果你不是很确定，千万不要这么做。\n\n```sh\n$ git reset HEAD^ --hard\n$ git push -f [remote] [branch]\n```\n\n如果你还没有推到远程, 把Git重置(reset)到你最后一次提交前的状态就可以了(同时保存暂存的变化):\n\n```\n(my-branch*)$ git reset --soft HEAD@{1}\n\n```\n\n这只能在没有推送之前有用. 如果你已经推了, 唯一安全能做的是 `git revert SHAofBadCommit`， 那会创建一个新的提交(commit)用于撤消前一个提交的所有变化(changes)； 或者, 如果你推的这个分支是rebase-safe的 (例如： 其它开发者不会从这个分支拉), 只需要使用 `git push -f`； 更多, 请参考 [the above section](#deleteremove-last-pushed-commit)。\n\n## 删除任意提交\n\n同样的警告：不到万不得已的时候不要这么做.\n\n```sh\n$ git rebase --onto SHA1_OF_BAD_COMMIT^ SHA1_OF_BAD_COMMIT\n$ git push -f [remote] [branch]\n```\n\n或者做一个 [交互式rebase](#interactive-rebase) 删除那些你想要删除的提交(commit)里所对应的行。\n\n## 尝试推一个修正后的提交到远程，但是报错：\n\n```sh\nTo https://github.com/yourusername/repo.git\n! [rejected]        mybranch -> mybranch (non-fast-forward)\nerror: failed to push some refs to 'https://github.com/tanay1337/webmaker.org.git'\nhint: Updates were rejected because the tip of your current branch is behind\nhint: its remote counterpart. Integrate the remote changes (e.g.\nhint: 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n```\n\n注意, rebasing(见下面)和修正(amending)会用一个**新的提交(commit)代替旧的**, 所以如果之前你已经往远程仓库上推过一次修正前的提交(commit)，那你现在就必须强推(force push) (`-f`)。 注意 &ndash; *总是* 确保你指明一个分支!\n\n```sh\n(my-branch)$ git push origin mybranch -f\n```\n\n一般来说, **要避免强推**. 最好是创建和推(push)一个新的提交(commit)，而不是强推一个修正后的提交。后者会使那些与该分支或该分支的子分支工作的开发者，在源历史中产生冲突。\n\n## 意外的做了一次硬重置，想找回内容\n\n如果你意外的做了 `git reset --hard`, 你通常能找回你的提交(commit), 因为Git对每件事都会有日志，且都会保存几天。\n\n```sh\n(master)$ git reflog\n```\n\n你将会看到一个你过去提交(commit)的列表, 和一个重置的提交。 选择你想要回到的提交(commit)的SHA，再重置一次:\n\n```sh\n(master)$ git reset --hard SHA1234\n```\n\n这样就完成了。\n\n# 暂存(Staging)\n\n## 需要把暂存的内容添加到上一次的提交\n\n```sh\n(my-branch*)$ git commit --amend\n\n```\n\n## 想要暂存一个新文件的一部分，而不是这个文件的全部\n\n一般来说, 如果你想暂存一个文件的一部分, 你可这样做:\n\n```sh\n$ git add --patch filename.x\n```\n\n`-p` 简写。这会打开交互模式， 你将能够用 `s` 选项来分隔提交(commit)； 然而, 如果这个文件是新的, 会没有这个选择， 添加一个新文件时, 这样做:\n\n```sh\n$ git add -N filename.x\n```\n\n然后, 你需要用 `e` 选项来手动选择需要添加的行，执行 `git diff --cached` 将会显示哪些行暂存了哪些行只是保存在本地了。\n\n## 想把在一个文件里的变化加到两个提交里\n\n`git add` 会把整个文件加入到一个提交. `git add -p` 允许交互式的选择你想要提交的部分.\n\n## 想把暂存的内容变成未暂存，把未暂存的内容暂存起来\n\n这个有点困难， 我能想到的最好的方法是先stash未暂存的内容， 然后重置(reset)，再pop第一步stashed的内容, 最后再add它们。\n\n```sh\n$ git stash -k\n$ git reset --hard\n$ git stash pop\n$ git add -A\n```\n\n# 未暂存(Unstaged)的内容\n\n## 想把未暂存的内容移动到一个新分支\n\n```sh\n$ git checkout -b my-branch\n```\n\n## 想把未暂存的内容移动到另一个已存在的分支\n\n```sh\n$ git stash\n$ git checkout my-branch\n$ git stash pop\n```\n\n## 想丢弃本地未提交的变化\n\n如果你只是想重置源(origin)和你本地(local)之间的一些提交(commit)，你可以：\n\n```sh\n# one commit\n(my-branch)$ git reset --hard HEAD^\n# two commits\n(my-branch)$ git reset --hard HEAD^^\n# four commits\n(my-branch)$ git reset --hard HEAD~4\n# or\n(master)$ git checkout -f\n```\n\n重置某个特殊的文件, 你可以用文件名做为参数:\n\n```sh\n$ git reset filename\n```\n\n## 想丢弃某些未暂存的内容\n\n如果你想丢弃工作拷贝中的一部分内容，而不是全部。\n\n签出(checkout)不需要的内容，保留需要的。\n\n```sh\n$ git checkout -p\n# Answer y to all of the snippets you want to drop\n```\n\n另外一个方法是使用 `stash`， Stash所有要保留下的内容, 重置工作拷贝, 重新应用保留的部分。\n\n```sh\n$ git stash -p\n# Select all of the snippets you want to save\n$ git reset --hard\n$ git stash pop\n```\n\n或者, stash 你不需要的部分, 然后stash drop。\n\n```sh\n$ git stash -p\n# Select all of the snippets you don't want to save\n$ git stash drop\n```\n\n# 分支(Branches)\n\n## 从错误的分支拉取了内容，或把内容拉取到了错误的分支\n\n这是另外一种使用 `git reflog` 情况，找到在这次错误拉(pull) 之前HEAD的指向。\n\n```sh\n(master)$ git reflog\nab7555f HEAD@{0}: pull origin wrong-branch: Fast-forward\nc5bc55a HEAD@{1}: checkout: checkout message goes here\n```\n\n重置分支到你所需的提交(desired commit):\n\n```sh\n$ git reset --hard c5bc55a\n```\n\n完成。\n\n## 想扔掉本地的提交，以便我的分支与远程的保持一致\n\n先确认你没有推(push)你的内容到远程。\n\n`git status` 会显示你领先(ahead)源(origin)多少个提交:\n\n```sh\n(my-branch)$ git status\n# On branch my-branch\n# Your branch is ahead of 'origin/my-branch' by 2 commits.\n#   (use \"git push\" to publish your local commits)\n#\n```\n\n一种方法是:\n\n```sh\n(master)$ git reset --hard origin/my-branch\n```\n\n## 需要提交到一个新分支，但错误的提交到了master\n\n在master下创建一个新分支，不切换到新分支,仍在master下:\n\n```sh\n(master)$ git branch my-branch\n```\n\n把master分支重置到前一个提交:\n\n```sh\n(master)$ git reset --hard HEAD^\n```\n\n`HEAD^` 是 `HEAD^1` 的简写，你可以通过指定要设置的`HEAD`来进一步重置。\n\n或者, 如果你不想使用 `HEAD^`, 找到你想重置到的提交(commit)的hash(`git log` 能够完成)， 然后重置到这个hash。 使用`git push` 同步内容到远程。\n\n例如, master分支想重置到的提交的hash为`a13b85e`:\n\n```sh\n(master)$ git reset --hard a13b85e\nHEAD is now at a13b85e\n```\n\n签出(checkout)刚才新建的分支继续工作:\n\n```sh\n(master)$ git checkout my-branch\n```\n\n## 想保留来自另外一个ref-ish的整个文件\n\n假设你正在做一个原型方案(原文为working spike (see note)), 有成百的内容，每个都工作得很好。现在, 你提交到了一个分支，保存工作内容:\n\n```sh\n(solution)$ git add -A && git commit -m \"Adding all changes from this spike into one big commit.\"\n```\n\n当你想要把它放到一个分支里 (可能是`feature`, 或者 `develop`), 你关心是保持整个文件的完整，你想要一个大的提交分隔成比较小。\n\n假设你有:\n\n  * 分支 `solution`, 拥有原型方案， 领先 `develop` 分支。\n  * 分支 `develop`, 在这里你应用原型方案的一些内容。\n\n我去可以通过把内容拿到你的分支里，来解决这个问题:\n\n```sh\n(develop)$ git checkout solution -- file1.txt\n```\n\n这会把这个文件内容从分支 `solution` 拿到分支 `develop` 里来:\n\n```sh\n# On branch develop\n# Your branch is up-to-date with 'origin/develop'.\n# Changes to be committed:\n#  (use \"git reset HEAD <file>...\" to unstage)\n#\n#        modified:   file1.txt\n```\n\n然后, 正常提交。\n\nNote: Spike solutions are made to analyze or solve the problem. These solutions are used for estimation and discarded once everyone gets clear visualization of the problem. ~ [Wikipedia](https://en.wikipedia.org/wiki/Extreme_programming_practices).\n\n## 把几个提交提交到了同一个分支，而这些提交应该分布在不同的分支里\n\n假设你有一个`master`分支， 执行`git log`, 你看到你做过两次提交:\n\n```sh\n(master)$ git log\n\ncommit e3851e817c451cc36f2e6f3049db528415e3c114\nAuthor: Alex Lee <alexlee@example.com>\nDate:   Tue Jul 22 15:39:27 2014 -0400\n\n    Bug #21 - Added CSRF protection\n\ncommit 5ea51731d150f7ddc4a365437931cd8be3bf3131\nAuthor: Alex Lee <alexlee@example.com>\nDate:   Tue Jul 22 15:39:12 2014 -0400\n\n    Bug #14 - Fixed spacing on title\n\ncommit a13b85e984171c6e2a1729bb061994525f626d14\nAuthor: Aki Rose <akirose@example.com>\nDate:   Tue Jul 21 01:12:48 2014 -0400\n\n    First commit\n```\n\n让我们用提交hash(commit hash)标记bug (`e3851e8` for #21, `5ea5173` for #14).\n\n首先, 我们把`master`分支重置到正确的提交(`a13b85e`):\n\n```sh\n(master)$ git reset --hard a13b85e\nHEAD is now at a13b85e\n```\n\n现在, 我们对 bug #21 创建一个新的分支:\n\n```sh\n(master)$ git checkout -b 21\n(21)$\n```\n\n接着, 我们用 *cherry-pick* 把对bug #21的提交放入当前分支。 这意味着我们将应用(apply)这个提交(commit)，仅仅这一个提交(commit)，直接在HEAD上面。\n\n```sh\n(21)$ git cherry-pick e3851e8\n```\n\n这时候, 这里可能会产生冲突， 参见[交互式 rebasing 章](#interactive-rebase) [**冲突节**](#merge-conflict) 解决冲突.\n\n再者， 我们为bug #14 创建一个新的分支, 也基于`master`分支\n\n```sh\n(21)$ git checkout master\n(master)$ git checkout -b 14\n(14)$\n```\n\n最后, 为 bug #14 执行 `cherry-pick`:\n\n```sh\n(14)$ git cherry-pick 5ea5173\n```\n\n## 想删除上游分支被删除了的本地分支\n一旦你在github 上面合并(merge)了一个pull request, 你就可以删除你fork里被合并的分支。 如果你不准备继续在这个分支里工作, 删除这个分支的本地拷贝会更干净，使你不会陷入工作分支和一堆陈旧分支的混乱之中。\n\n```sh\n$ git fetch -p\n```\n\n## 不小心删除了我的分支\n\n如果你定期推送到远程, 多数情况下应该是安全的，但有些时候还是可能删除了还没有推到远程的分支。 让我们先创建一个分支和一个新的文件:\n\n```sh\n(master)$ git checkout -b my-branch\n(my-branch)$ git branch\n(my-branch)$ touch foo.txt\n(my-branch)$ ls\nREADME.md foo.txt\n```\n\n添加文件并做一次提交\n\n```sh\n(my-branch)$ git add .\n(my-branch)$ git commit -m 'foo.txt added'\n(my-branch)$ foo.txt added\n 1 files changed, 1 insertions(+)\n create mode 100644 foo.txt\n(my-branch)$ git log\n\ncommit 4e3cd85a670ced7cc17a2b5d8d3d809ac88d5012\nAuthor: siemiatj <siemiatj@example.com>\nDate:   Wed Jul 30 00:34:10 2014 +0200\n\n    foo.txt added\n\ncommit 69204cdf0acbab201619d95ad8295928e7f411d5\nAuthor: Kate Hudson <katehudson@example.com>\nDate:   Tue Jul 29 13:14:46 2014 -0400\n\n    Fixes #6: Force pushing after amending commits\n```\n\n现在我们切回到主(master)分支，‘不小心的’删除`my-branch`分支\n\n```sh\n(my-branch)$ git checkout master\nSwitched to branch 'master'\nYour branch is up-to-date with 'origin/master'.\n(master)$ git branch -D my-branch\nDeleted branch my-branch (was 4e3cd85).\n(master)$ echo oh noes, deleted my branch!\noh noes, deleted my branch!\n```\n\n在这时候你应该想起了`reflog`, 一个升级版的日志，它存储了仓库(repo)里面所有动作的历史。\n\n```\n(master)$ git reflog\n69204cd HEAD@{0}: checkout: moving from my-branch to master\n4e3cd85 HEAD@{1}: commit: foo.txt added\n69204cd HEAD@{2}: checkout: moving from master to my-branch\n```\n\n正如你所见，我们有一个来自删除分支的提交hash(commit hash)，接下来看看是否能恢复删除了的分支。\n\n```sh\n(master)$ git checkout -b my-branch-help\nSwitched to a new branch 'my-branch-help'\n(my-branch-help)$ git reset --hard 4e3cd85\nHEAD is now at 4e3cd85 foo.txt added\n(my-branch-help)$ ls\nREADME.md foo.txt\n```\n\n看! 我们把删除的文件找回来了。 Git的 `reflog` 在rebasing出错的时候也是同样有用的。\n\n## 想删除一个分支\n\n删除一个远程分支:\n\n```sh\n(master)$ git push origin --delete my-branch\n```\n\n你也可以:\n\n```sh\n(master)$ git push origin :my-branch\n```\n\n删除一个本地分支:\n\n```sh\n(master)$ git branch -D my-branch\n```\n\n## 想从别人正在工作的远程分支签出一个分支\n\n首先, 从远程拉取(fetch) 所有分支:\n\n```sh\n(master)$ git fetch --all\n```\n\n假设你想要从远程的`daves`分支签出到本地的`daves`\n\n```sh\n(master)$ git checkout --track origin/daves\nBranch daves set up to track remote branch daves from origin.\nSwitched to a new branch 'daves'\n```\n\n(`--track` 是 `git checkout -b [branch] [remotename]/[branch]` 的简写)\n\n这样就得到了一个`daves`分支的本地拷贝, 任何推过(pushed)的更新，远程都能看到.\n\n# Rebasing 和合并(Merging)\n\n## 想撤销rebase/merge\n\n你可以合并(merge)或rebase了一个错误的分支, 或者完成不了一个进行中的rebase/merge。 Git 在进行危险操作的时候会把原始的HEAD保存在一个叫ORIG_HEAD的变量里, 所以要把分支恢复到rebase/merge前的状态是很容易的。\n\n```sh\n(my-branch)$ git reset --hard ORIG_HEAD\n```\n\n## 已经rebase过, 但是我不想强推\n\n不幸的是，如果你想把这些变化(changes)反应到远程分支上，你就必须得强推(force push)。 是因你快进(Fast forward)了提交，改变了Git历史, 远程分支不会接受变化(changes)，除非强推(force push)。这就是许多人使用 merge 工作流, 而不是 rebasing 工作流的主要原因之一， 开发者的强推(force push)会使大的团队陷入麻烦。使用时需要注意，一种安全使用 rebase 的方法是，不要把你的变化(changes)反映到远程分支上, 而是按下面的做:\n\n```sh\n(master)$ git checkout my-branch\n(my-branch)$ git rebase -i master\n(my-branch)$ git checkout master\n(master)$ git merge --ff-only my-branch\n```\n\n更多, 参见 [this SO thread](http://stackoverflow.com/questions/11058312/how-can-i-use-git-rebase-without-requiring-a-forced-push).\n\n## 需要组合几个提交\n\n假设你的工作分支将会做对于 `master` 的pull-request。 一般情况下你不关心提交(commit)的时间戳，只想组合 *所有* 提交(commit) 到一个单独的里面, 然后重置(reset)重提交(recommit)。 确保主(master)分支是最新的和你的变化都已经提交了, 然后:\n\n```sh\n(my-branch)$ git reset --soft master\n(my-branch)$ git commit -am \"New awesome feature\"\n```\n\n如果你想要更多的控制, 想要保留时间戳, 你需要做交互式rebase (interactive rebase):\n\n```sh\n(my-branch)$ git rebase -i master\n```\n\n如果没有相对的其它分支， 你将不得不相对自己的`HEAD` 进行 rebase。 例如：你想组合最近的两次提交(commit), 你将相对于`HEAD~2` 进行rebase， 组合最近3次提交(commit), 相对于`HEAD~3`, 等等。\n\n```sh\n(master)$ git rebase -i HEAD~2\n```\n\n在你执行了交互式 rebase的命令(interactive rebase command)后, 你将在你的编辑器里看到类似下面的内容:\n\n```vim\npick a9c8a1d Some refactoring\npick 01b2fd8 New awesome feature\npick b729ad5 fixup\npick e3851e8 another fix\n\n# Rebase 8074d12..b729ad5 onto 8074d12\n#\n# Commands:\n#  p, pick = use commit\n#  r, reword = use commit, but edit the commit message\n#  e, edit = use commit, but stop for amending\n#  s, squash = use commit, but meld into previous commit\n#  f, fixup = like \"squash\", but discard this commit's log message\n#  x, exec = run command (the rest of the line) using shell\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n```\n\n所有以 `#` 开头的行都是注释, 不会影响 rebase.\n\n然后，你可以用任何上面命令列表的命令替换 `pick`, 你也可以通过删除对应的行来删除一个提交(commit)。\n\n例如, 如果你想 **单独保留最旧(first)的提交(commit),组合所有剩下的到第二个里面**, 你就应该编辑第二个提交(commit)后面的每个提交(commit) 前的单词为 `f`:\n\n```vim\npick a9c8a1d Some refactoring\npick 01b2fd8 New awesome feature\nf b729ad5 fixup\nf e3851e8 another fix\n```\n\n如果你想组合这些提交(commit) **并重命名这个提交(commit)**, 你应该在第二个提交(commit)旁边添加一个`r`，或者更简单的用`s` 替代 `f`:\n\n```vim\npick a9c8a1d Some refactoring\npick 01b2fd8 New awesome feature\ns b729ad5 fixup\ns e3851e8 another fix\n```\n\n你可以在接下来弹出的文本提示框里重命名提交(commit)。\n\n```vim\nNewer, awesomer features\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n# rebase in progress; onto 8074d12\n# You are currently editing a commit while rebasing branch 'master' on '8074d12'.\n#\n# Changes to be committed:\n#\tmodified:   README.md\n#\n\n```\n\n如果成功了, 你应该看到类似下面的内容:\n\n```sh\n(master)$ Successfully rebased and updated refs/heads/master.\n```\n\n### 安全合并策略\n`--no-commit` 执行合并(merge)但不自动提交, 给用户在做提交前检查和修改的机会。 `no-ff` 会为特性分支(feature branch)的存在过留下证据, 保持项目历史一致。\n\n```sh\n(master)$ git merge --no-ff --no-commit my-branch\n```\n\n### 需要将一个分支合并成一个提交\n\n```sh\n(master)$ git merge --squash my-branch\n```\n\n### 只想组合未推的提交\n\n有时候，在将数据推向上游之前，你有几个正在进行的工作提交(commit)。这时候不希望把已经推(push)过的组合进来，因为其他人可能已经有提交(commit)引用它们了。\n\n```sh\n(master)$ git rebase -i @{u}\n```\n\n这会产生一次交互式的rebase(interactive rebase), 只会列出没有推(push)的提交(commit)， 在这个列表时进行reorder/fix/squash 都是安全的。\n\n## 检查是否分支上的所有提交都合并过了\n\n检查一个分支上的所有提交(commit)是否都已经合并(merge)到了其它分支, 你应该在这些分支的head(或任何 commits)之间做一次diff:\n\n```sh\n(master)$ git log --graph --left-right --cherry-pick --oneline HEAD...feature/120-on-scroll\n```\n\n这会告诉你在一个分支里有而另一个分支没有的所有提交(commit), 和分支之间不共享的提交(commit)的列表。 另一个做法可以是:\n\n```sh\n(master)$ git log master ^feature/120-on-scroll --no-merges\n```\n\n## 交互式rebase可能出现的问题\n\n### 这个rebase编辑屏幕出现'noop'\n\n如果你看到的是这样:\n```\nnoop\n```\n\n这意味着你rebase的分支和当前分支在同一个提交(commit)上, 或者 *领先(ahead)* 当前分支。 你可以尝试:\n\n* 检查确保主(master)分支没有问题\n* rebase  `HEAD~2` 或者更早\n\n### 有冲突的情况\n\n如果你不能成功的完成rebase, 你可能必须要解决冲突。\n\n首先执行 `git status` 找出哪些文件有冲突:\n\n```sh\n(my-branch)$ git status\nOn branch my-branch\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   README.md\n```\n\n在这个例子里面, `README.md` 有冲突。 打开这个文件找到类似下面的内容:\n\n```vim\n   <<<<<<< HEAD\n   some code\n   =========\n   some code\n   >>>>>>> new-commit\n```\n\n你需要解决新提交的代码(示例里, 从中间`==`线到`new-commit`的地方)与`HEAD` 之间不一样的地方.\n\n有时候这些合并非常复杂，你应该使用可视化的差异编辑器(visual diff editor):\n\n```sh\n(master*)$ git mergetool -t opendiff\n```\n\n在你解决完所有冲突和测试过后, `git add` 变化了的(changed)文件, 然后用`git rebase --continue` 继续rebase。\n\n```sh\n(my-branch)$ git add README.md\n(my-branch)$ git rebase --continue\n```\n\n如果在解决完所有的冲突过后，得到了与提交前一样的结果, 可以执行`git rebase --skip`。\n\n任何时候你想结束整个rebase 过程，回来rebase前的分支状态, 你可以做:\n\n```sh\n(my-branch)$ git rebase --abort\n```\n\n# 杂项(Miscellaneous Objects)\n\n## 克隆所有子模块\n\n```sh\n$ git clone --recursive git://github.com/foo/bar.git\n```\n\n如果已经克隆了:\n\n```sh\n$ git submodule update --init --recursive\n```\n\n## 删除标签\n\n```sh\n$ git tag -d <tag_name>\n$ git push <remote> :refs/tags/<tag_name>\n```\n\n## 恢复已删除标签\n\n如果你想恢复一个已删除标签(tag), 可以按照下面的步骤: 首先, 需要找到无法访问的标签(unreachable tag):\n\n```sh\n$ git fsck --unreachable | grep tag\n```\n\n记下这个标签(tag)的hash，然后用Git的 [update-ref](http://git-scm.com/docs/git-update-ref):\n\n```sh\n$ git update-ref refs/tags/<tag_name> <hash>\n```\n\n这时你的标签(tag)应该已经恢复了。\n\n## 已删除补丁\n\n如果某人在 GitHub 上给你发了一个pull request, 但是然后他删除了他自己的原始 fork, 你将没法克隆他们的提交(commit)或使用 `git am`。在这种情况下, 最好手动的查看他们的提交(commit)，并把它们拷贝到一个本地新分支，然后做提交。\n\n做完提交后, 再修改作者，参见[变更作者](#commit-wrong-author)。 然后, 应用变化, 再发起一个新的pull request。\n\n# 跟踪文件(Tracking Files)\n\n## 只想改变一个文件名字的大小写，而不修改内容\n\n```sh\n(master)$ git mv --force myfile MyFile\n```\n\n## 想从Git删除一个文件，但保留该文件\n\n```sh\n(master)$ git rm --cached log.txt\n```\n\n# 配置(Configuration)\n\n## 想给一些Git命令添加别名\n\n在 OS X 和 Linux 下, 你的 Git的配置文件储存在 ```~/.gitconfig```。我在```[alias]``` 部分添加了一些快捷别名(和一些我容易拼写错误的)，如下:\n\n```vim\n[alias]\n    a = add\n    amend = commit --amend\n    c = commit\n    ca = commit --amend\n    ci = commit -a\n    co = checkout\n    d = diff\n    dc = diff --changed\n    ds = diff --staged\n    f = fetch\n    loll = log --graph --decorate --pretty=oneline --abbrev-commit\n    m = merge\n    one = log --pretty=oneline\n    outstanding = rebase -i @{u}\n    s = status\n    unpushed = log @{u}\n    wc = whatchanged\n    wip = rebase -i @{u}\n    zap = fetch -p\n```\n\n## 想缓存一个仓库的用户名和密码\n\n你可能有一个仓库需要授权，这时你可以缓存用户名和密码，而不用每次推/拉(push/pull)的时候都输入，Credential helper能帮你。\n\n```sh\n$ git config --global credential.helper cache\n# Set git to use the credential memory cache\n```\n\n```sh\n$ git config --global credential.helper 'cache --timeout=3600'\n# Set the cache to timeout after 1 hour (setting is in seconds)\n```\n\n# 不知道我做错了些什么\n\n你把事情搞砸了：你 `重置(reset)` 了一些东西, 或者你合并了错误的分支, 亦或你强推了后找不到你自己的提交(commit)了。有些时候, 你一直都做得很好, 但你想回到以前的某个状态。\n\n这就是 `git reflog` 的目的， `reflog` 记录对分支顶端(the tip of a branch)的任何改变, 即使那个顶端没有被任何分支或标签引用。基本上, 每次HEAD的改变, 一条新的记录就会增加到`reflog`。遗憾的是，这只对本地分支起作用，且它只跟踪动作 (例如，不会跟踪一个没有被记录的文件的任何改变)。\n\n```sh\n(master)$ git reflog\n0a2e358 HEAD@{0}: reset: moving to HEAD~2\n0254ea7 HEAD@{1}: checkout: moving from 2.2 to master\nc10f740 HEAD@{2}: checkout: moving from master to 2.2\n```\n\n上面的reflog展示了从master分支签出(checkout)到2.2 分支，然后再签回。 那里，还有一个硬重置(hard reset)到一个较旧的提交。最新的动作出现在最上面以 `HEAD@{0}`标识.\n\n如果事实证明你不小心回移(move back)了提交(commit), reflog 会包含你不小心回移前master上指向的提交(0254ea7)。\n\n```sh\n$ git reset --hard 0254ea7\n```\n\n然后使用git reset就可以把master改回到之前的commit，这提供了一个在历史被意外更改情况下的安全网。\n\n([摘自](https://www.atlassian.com/git/tutorials/rewriting-history/git-reflog)).\n\n# 其它资源(Other Resources)\n\n## 书(Books)\n\n* [Pro Git](https://git-scm.com/book/en/v2) - Scott Chacon's excellent git book\n* [Git Internals](https://github.com/pluralsight/git-internals-pdf) - Scott Chacon's other excellent git book\n\n## 教程(Tutorials)\n\n* [Learn Git branching](https://learngitbranching.js.org/) 一个基于网页的交互式 branching/merging/rebasing 教程\n* [Getting solid at Git rebase vs. merge](https://medium.com/@porteneuve/getting-solid-at-git-rebase-vs-merge-4fa1a48c53aa)\n* [git-workflow](https://github.com/asmeurer/git-workflow) - [Aaron Meurer](https://github.com/asmeurer)的怎么使用Git为开源仓库贡献\n* [GitHub as a workflow](http://hugogiraudel.com/2015/08/13/github-as-a-workflow/) - 使用GitHub做为工作流的趣事, 尤其是空PRs\n\n## 脚本和工具(Scripts and Tools)\n\n* [firstaidgit.io](http://firstaidgit.io/) 一个可搜索的最常被问到的Git的问题\n* [git-extra-commands](https://github.com/unixorn/git-extra-commands) - 一堆有用的额外的Git脚本\n* [git-extras](https://github.com/tj/git-extras) - GIT 工具集 -- repo summary, repl, changelog population, author commit percentages and more\n* [git-fire](https://github.com/qw3rtman/git-fire) - git-fire 是一个 Git 插件，用于帮助在紧急情况下添加所有当前文件, 做提交(committing), 和推(push)到一个新分支(阻止合并冲突)。\n* [git-tips](https://github.com/git-tips/tips) - Git小提示\n* [git-town](https://github.com/Originate/git-town) - 通用，高级Git工作流支持！ http://www.git-town.com\n\n## GUI客户端(GUI Clients)\n* [GitKraken](https://www.gitkraken.com/) - 豪华的Git客户端 Windows, Mac & Linux\n* [git-cola](https://git-cola.github.io/) - 另外一个Git客户端 Windows & OS X\n* [GitUp](https://github.com/git-up/GitUp) - 一个新的Git客户端，在处理Git的复杂性上有自己的特点\n* [gitx-dev](https://rowanj.github.io/gitx/) - 图形化的Git客户端 OS X\n* [Source Tree](https://www.sourcetreeapp.com/) - 免费的图形化Git客户端 Windows & OS X\n* [Tower](http://www.git-tower.com/) - 图形化Git客户端 OS X(付费)\n* [SmartGit](https://www.syntevo.com/smartgit/) - 推荐，对个人用户免费","content":"<blockquote>\n<p>图形化客户端强烈推荐：<a href=\"https://www.syntevo.com/smartgit/\" target=\"_blank\" rel=\"noopener\">SmartGit</a>， 本文是基于<a href=\"https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md\" target=\"_blank\" rel=\"noopener\">Git飞行规则</a>上做的修改与补充。</p>\n</blockquote>\n<h1 id=\"快速查询目录\"><a href=\"#快速查询目录\" class=\"headerlink\" title=\"快速查询目录\"></a>快速查询目录</h1><!-- page_toc -->  \n<blockquote>\n<p>为了清楚的表述，这篇文档里的所有例子使用了自定义的bash 提示，以便指示当前分支和是否有暂存的变化(changes)。分支名用小括号括起来，分支名后面跟的<code>*</code>表示暂存的变化(changes)。</p>\n</blockquote>\n<h1 id=\"编辑提交-editting-commits\"><a href=\"#编辑提交-editting-commits\" class=\"headerlink\" title=\"编辑提交(editting commits)\"></a>编辑提交(editting commits)</h1><h2 id=\"刚才提交了什么\"><a href=\"#刚才提交了什么\" class=\"headerlink\" title=\"刚才提交了什么\"></a>刚才提交了什么</h2><p>如果你用 <code>git commit -a</code> 提交了一次变化(changes)，而你又不确定到底这次提交了哪些内容。 你就可以用下面的命令显示当前<code>HEAD</code>上的最近一次的提交(commit):</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git show</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">log</span> -n1 -p</span><br></pre></td></tr></table></figure>\n<h2 id=\"提交信息写错了\"><a href=\"#提交信息写错了\" class=\"headerlink\" title=\"提交信息写错了\"></a>提交信息写错了</h2><p>如果你的提交信息(commit message)写错了且这次提交(commit)还没有推(push), 你可以通过下面的方法来修改提交信息(commit message):</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit --amend</span><br></pre></td></tr></table></figure>\n<p>这会打开你的默认编辑器, 在这里你可以编辑信息. 另一方面, 你也可以用一条命令一次完成:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit --amend -m <span class=\"string\">'xxxxxxx'</span></span><br></pre></td></tr></table></figure>\n<p>如果你已经推(push)了这次提交(commit), 你可以修改这次提交(commit)然后强推(force push), 但是不推荐这么做。</p>\n<h2 id=\"提交里的用户名和邮箱不对\"><a href=\"#提交里的用户名和邮箱不对\" class=\"headerlink\" title=\"提交里的用户名和邮箱不对\"></a>提交里的用户名和邮箱不对</h2><p>如果这只是单个提交(commit)，修改它：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit --amend --author <span class=\"string\">\"New Authorname &lt;authoremail@mydomain.com&gt;\"</span></span><br></pre></td></tr></table></figure>\n<p>如果你需要修改所有历史, 参考 ‘git filter-branch’的指南页.</p>\n<h2 id=\"想从一个提交里移除一个文件\"><a href=\"#想从一个提交里移除一个文件\" class=\"headerlink\" title=\"想从一个提交里移除一个文件\"></a>想从一个提交里移除一个文件</h2><p>通过下面的方法，从一个提交(commit)里移除一个文件:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout HEAD^ myfile</span><br><span class=\"line\">$ git add -A</span><br><span class=\"line\">$ git commit --amend</span><br></pre></td></tr></table></figure>\n<p>这将非常有用，当你有一个开放的补丁(open patch)，你往上面提交了一个不必要的文件，你需要强推(force push)去更新这个远程补丁。</p>\n<h2 id=\"想删除最后一次提交\"><a href=\"#想删除最后一次提交\" class=\"headerlink\" title=\"想删除最后一次提交\"></a>想删除最后一次提交</h2><p>如果你需要删除推了的提交(pushed commits)，你可以使用下面的方法。可是，这会不可逆的改变你的历史，也会搞乱那些已经从该仓库拉取(pulled)了的人的历史。简而言之，如果你不是很确定，千万不要这么做。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset HEAD^ --hard</span><br><span class=\"line\">$ git push -f [remote] [branch]</span><br></pre></td></tr></table></figure>\n<p>如果你还没有推到远程, 把Git重置(reset)到你最后一次提交前的状态就可以了(同时保存暂存的变化):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(my-branch*)$ git reset --soft HEAD@&#123;1&#125;</span><br></pre></td></tr></table></figure>\n<p>这只能在没有推送之前有用. 如果你已经推了, 唯一安全能做的是 <code>git revert SHAofBadCommit</code>， 那会创建一个新的提交(commit)用于撤消前一个提交的所有变化(changes)； 或者, 如果你推的这个分支是rebase-safe的 (例如： 其它开发者不会从这个分支拉), 只需要使用 <code>git push -f</code>； 更多, 请参考 <a href=\"#deleteremove-last-pushed-commit\">the above section</a>。</p>\n<h2 id=\"删除任意提交\"><a href=\"#删除任意提交\" class=\"headerlink\" title=\"删除任意提交\"></a>删除任意提交</h2><p>同样的警告：不到万不得已的时候不要这么做.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rebase --onto SHA1_OF_BAD_COMMIT^ SHA1_OF_BAD_COMMIT</span><br><span class=\"line\">$ git push -f [remote] [branch]</span><br></pre></td></tr></table></figure>\n<p>或者做一个 <a href=\"#interactive-rebase\">交互式rebase</a> 删除那些你想要删除的提交(commit)里所对应的行。</p>\n<h2 id=\"尝试推一个修正后的提交到远程，但是报错：\"><a href=\"#尝试推一个修正后的提交到远程，但是报错：\" class=\"headerlink\" title=\"尝试推一个修正后的提交到远程，但是报错：\"></a>尝试推一个修正后的提交到远程，但是报错：</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">To https://github.com/yourusername/repo.git</span><br><span class=\"line\">! [rejected]        mybranch -&gt; mybranch (non-fast-forward)</span><br><span class=\"line\">error: failed to push some refs to <span class=\"string\">'https://github.com/tanay1337/webmaker.org.git'</span></span><br><span class=\"line\">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class=\"line\">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class=\"line\">hint: <span class=\"string\">'git pull ...'</span>) before pushing again.</span><br><span class=\"line\">hint: See the <span class=\"string\">'Note about fast-forwards'</span> <span class=\"keyword\">in</span> <span class=\"string\">'git push --help'</span> <span class=\"keyword\">for</span> details.</span><br></pre></td></tr></table></figure>\n<p>注意, rebasing(见下面)和修正(amending)会用一个<strong>新的提交(commit)代替旧的</strong>, 所以如果之前你已经往远程仓库上推过一次修正前的提交(commit)，那你现在就必须强推(force push) (<code>-f</code>)。 注意 &ndash; <em>总是</em> 确保你指明一个分支!</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(my-branch)$ git push origin mybranch -f</span><br></pre></td></tr></table></figure>\n<p>一般来说, <strong>要避免强推</strong>. 最好是创建和推(push)一个新的提交(commit)，而不是强推一个修正后的提交。后者会使那些与该分支或该分支的子分支工作的开发者，在源历史中产生冲突。</p>\n<h2 id=\"意外的做了一次硬重置，想找回内容\"><a href=\"#意外的做了一次硬重置，想找回内容\" class=\"headerlink\" title=\"意外的做了一次硬重置，想找回内容\"></a>意外的做了一次硬重置，想找回内容</h2><p>如果你意外的做了 <code>git reset --hard</code>, 你通常能找回你的提交(commit), 因为Git对每件事都会有日志，且都会保存几天。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git reflog</span><br></pre></td></tr></table></figure>\n<p>你将会看到一个你过去提交(commit)的列表, 和一个重置的提交。 选择你想要回到的提交(commit)的SHA，再重置一次:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git reset --hard SHA1234</span><br></pre></td></tr></table></figure>\n<p>这样就完成了。</p>\n<h1 id=\"暂存-Staging\"><a href=\"#暂存-Staging\" class=\"headerlink\" title=\"暂存(Staging)\"></a>暂存(Staging)</h1><h2 id=\"需要把暂存的内容添加到上一次的提交\"><a href=\"#需要把暂存的内容添加到上一次的提交\" class=\"headerlink\" title=\"需要把暂存的内容添加到上一次的提交\"></a>需要把暂存的内容添加到上一次的提交</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(my-branch*)$ git commit --amend</span><br></pre></td></tr></table></figure>\n<h2 id=\"想要暂存一个新文件的一部分，而不是这个文件的全部\"><a href=\"#想要暂存一个新文件的一部分，而不是这个文件的全部\" class=\"headerlink\" title=\"想要暂存一个新文件的一部分，而不是这个文件的全部\"></a>想要暂存一个新文件的一部分，而不是这个文件的全部</h2><p>一般来说, 如果你想暂存一个文件的一部分, 你可这样做:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add --patch filename.x</span><br></pre></td></tr></table></figure>\n<p><code>-p</code> 简写。这会打开交互模式， 你将能够用 <code>s</code> 选项来分隔提交(commit)； 然而, 如果这个文件是新的, 会没有这个选择， 添加一个新文件时, 这样做:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add -N filename.x</span><br></pre></td></tr></table></figure>\n<p>然后, 你需要用 <code>e</code> 选项来手动选择需要添加的行，执行 <code>git diff --cached</code> 将会显示哪些行暂存了哪些行只是保存在本地了。</p>\n<h2 id=\"想把在一个文件里的变化加到两个提交里\"><a href=\"#想把在一个文件里的变化加到两个提交里\" class=\"headerlink\" title=\"想把在一个文件里的变化加到两个提交里\"></a>想把在一个文件里的变化加到两个提交里</h2><p><code>git add</code> 会把整个文件加入到一个提交. <code>git add -p</code> 允许交互式的选择你想要提交的部分.</p>\n<h2 id=\"想把暂存的内容变成未暂存，把未暂存的内容暂存起来\"><a href=\"#想把暂存的内容变成未暂存，把未暂存的内容暂存起来\" class=\"headerlink\" title=\"想把暂存的内容变成未暂存，把未暂存的内容暂存起来\"></a>想把暂存的内容变成未暂存，把未暂存的内容暂存起来</h2><p>这个有点困难， 我能想到的最好的方法是先stash未暂存的内容， 然后重置(reset)，再pop第一步stashed的内容, 最后再add它们。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash -k</span><br><span class=\"line\">$ git reset --hard</span><br><span class=\"line\">$ git stash pop</span><br><span class=\"line\">$ git add -A</span><br></pre></td></tr></table></figure>\n<h1 id=\"未暂存-Unstaged-的内容\"><a href=\"#未暂存-Unstaged-的内容\" class=\"headerlink\" title=\"未暂存(Unstaged)的内容\"></a>未暂存(Unstaged)的内容</h1><h2 id=\"想把未暂存的内容移动到一个新分支\"><a href=\"#想把未暂存的内容移动到一个新分支\" class=\"headerlink\" title=\"想把未暂存的内容移动到一个新分支\"></a>想把未暂存的内容移动到一个新分支</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b my-branch</span><br></pre></td></tr></table></figure>\n<h2 id=\"想把未暂存的内容移动到另一个已存在的分支\"><a href=\"#想把未暂存的内容移动到另一个已存在的分支\" class=\"headerlink\" title=\"想把未暂存的内容移动到另一个已存在的分支\"></a>想把未暂存的内容移动到另一个已存在的分支</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash</span><br><span class=\"line\">$ git checkout my-branch</span><br><span class=\"line\">$ git stash pop</span><br></pre></td></tr></table></figure>\n<h2 id=\"想丢弃本地未提交的变化\"><a href=\"#想丢弃本地未提交的变化\" class=\"headerlink\" title=\"想丢弃本地未提交的变化\"></a>想丢弃本地未提交的变化</h2><p>如果你只是想重置源(origin)和你本地(local)之间的一些提交(commit)，你可以：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># one commit</span></span><br><span class=\"line\">(my-branch)$ git reset --hard HEAD^</span><br><span class=\"line\"><span class=\"comment\"># two commits</span></span><br><span class=\"line\">(my-branch)$ git reset --hard HEAD^^</span><br><span class=\"line\"><span class=\"comment\"># four commits</span></span><br><span class=\"line\">(my-branch)$ git reset --hard HEAD~4</span><br><span class=\"line\"><span class=\"comment\"># or</span></span><br><span class=\"line\">(master)$ git checkout -f</span><br></pre></td></tr></table></figure>\n<p>重置某个特殊的文件, 你可以用文件名做为参数:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset filename</span><br></pre></td></tr></table></figure>\n<h2 id=\"想丢弃某些未暂存的内容\"><a href=\"#想丢弃某些未暂存的内容\" class=\"headerlink\" title=\"想丢弃某些未暂存的内容\"></a>想丢弃某些未暂存的内容</h2><p>如果你想丢弃工作拷贝中的一部分内容，而不是全部。</p>\n<p>签出(checkout)不需要的内容，保留需要的。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -p</span><br><span class=\"line\"><span class=\"comment\"># Answer y to all of the snippets you want to drop</span></span><br></pre></td></tr></table></figure>\n<p>另外一个方法是使用 <code>stash</code>， Stash所有要保留下的内容, 重置工作拷贝, 重新应用保留的部分。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash -p</span><br><span class=\"line\"><span class=\"comment\"># Select all of the snippets you want to save</span></span><br><span class=\"line\">$ git reset --hard</span><br><span class=\"line\">$ git stash pop</span><br></pre></td></tr></table></figure>\n<p>或者, stash 你不需要的部分, 然后stash drop。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash -p</span><br><span class=\"line\"><span class=\"comment\"># Select all of the snippets you don't want to save</span></span><br><span class=\"line\">$ git stash drop</span><br></pre></td></tr></table></figure>\n<h1 id=\"分支-Branches\"><a href=\"#分支-Branches\" class=\"headerlink\" title=\"分支(Branches)\"></a>分支(Branches)</h1><h2 id=\"从错误的分支拉取了内容，或把内容拉取到了错误的分支\"><a href=\"#从错误的分支拉取了内容，或把内容拉取到了错误的分支\" class=\"headerlink\" title=\"从错误的分支拉取了内容，或把内容拉取到了错误的分支\"></a>从错误的分支拉取了内容，或把内容拉取到了错误的分支</h2><p>这是另外一种使用 <code>git reflog</code> 情况，找到在这次错误拉(pull) 之前HEAD的指向。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git reflog</span><br><span class=\"line\">ab7555f HEAD@&#123;0&#125;: pull origin wrong-branch: Fast-forward</span><br><span class=\"line\">c5bc55a HEAD@&#123;1&#125;: checkout: checkout message goes here</span><br></pre></td></tr></table></figure>\n<p>重置分支到你所需的提交(desired commit):</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard c5bc55a</span><br></pre></td></tr></table></figure>\n<p>完成。</p>\n<h2 id=\"想扔掉本地的提交，以便我的分支与远程的保持一致\"><a href=\"#想扔掉本地的提交，以便我的分支与远程的保持一致\" class=\"headerlink\" title=\"想扔掉本地的提交，以便我的分支与远程的保持一致\"></a>想扔掉本地的提交，以便我的分支与远程的保持一致</h2><p>先确认你没有推(push)你的内容到远程。</p>\n<p><code>git status</code> 会显示你领先(ahead)源(origin)多少个提交:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(my-branch)$ git status</span><br><span class=\"line\"><span class=\"comment\"># On branch my-branch</span></span><br><span class=\"line\"><span class=\"comment\"># Your branch is ahead of 'origin/my-branch' by 2 commits.</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git push\" to publish your local commits)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n<p>一种方法是:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git reset --hard origin/my-branch</span><br></pre></td></tr></table></figure>\n<h2 id=\"需要提交到一个新分支，但错误的提交到了master\"><a href=\"#需要提交到一个新分支，但错误的提交到了master\" class=\"headerlink\" title=\"需要提交到一个新分支，但错误的提交到了master\"></a>需要提交到一个新分支，但错误的提交到了master</h2><p>在master下创建一个新分支，不切换到新分支,仍在master下:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git branch my-branch</span><br></pre></td></tr></table></figure>\n<p>把master分支重置到前一个提交:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure>\n<p><code>HEAD^</code> 是 <code>HEAD^1</code> 的简写，你可以通过指定要设置的<code>HEAD</code>来进一步重置。</p>\n<p>或者, 如果你不想使用 <code>HEAD^</code>, 找到你想重置到的提交(commit)的hash(<code>git log</code> 能够完成)， 然后重置到这个hash。 使用<code>git push</code> 同步内容到远程。</p>\n<p>例如, master分支想重置到的提交的hash为<code>a13b85e</code>:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git reset --hard a13b85e</span><br><span class=\"line\">HEAD is now at a13b85e</span><br></pre></td></tr></table></figure>\n<p>签出(checkout)刚才新建的分支继续工作:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git checkout my-branch</span><br></pre></td></tr></table></figure>\n<h2 id=\"想保留来自另外一个ref-ish的整个文件\"><a href=\"#想保留来自另外一个ref-ish的整个文件\" class=\"headerlink\" title=\"想保留来自另外一个ref-ish的整个文件\"></a>想保留来自另外一个ref-ish的整个文件</h2><p>假设你正在做一个原型方案(原文为working spike (see note)), 有成百的内容，每个都工作得很好。现在, 你提交到了一个分支，保存工作内容:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(solution)$ git add -A &amp;&amp; git commit -m <span class=\"string\">\"Adding all changes from this spike into one big commit.\"</span></span><br></pre></td></tr></table></figure>\n<p>当你想要把它放到一个分支里 (可能是<code>feature</code>, 或者 <code>develop</code>), 你关心是保持整个文件的完整，你想要一个大的提交分隔成比较小。</p>\n<p>假设你有:</p>\n<ul>\n<li>分支 <code>solution</code>, 拥有原型方案， 领先 <code>develop</code> 分支。</li>\n<li>分支 <code>develop</code>, 在这里你应用原型方案的一些内容。</li>\n</ul>\n<p>我去可以通过把内容拿到你的分支里，来解决这个问题:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(develop)$ git checkout solution -- file1.txt</span><br></pre></td></tr></table></figure>\n<p>这会把这个文件内容从分支 <code>solution</code> 拿到分支 <code>develop</code> 里来:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># On branch develop</span></span><br><span class=\"line\"><span class=\"comment\"># Your branch is up-to-date with 'origin/develop'.</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#  (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#        modified:   file1.txt</span></span><br></pre></td></tr></table></figure>\n<p>然后, 正常提交。</p>\n<p>Note: Spike solutions are made to analyze or solve the problem. These solutions are used for estimation and discarded once everyone gets clear visualization of the problem. ~ <a href=\"https://en.wikipedia.org/wiki/Extreme_programming_practices\" target=\"_blank\" rel=\"noopener\">Wikipedia</a>.</p>\n<h2 id=\"把几个提交提交到了同一个分支，而这些提交应该分布在不同的分支里\"><a href=\"#把几个提交提交到了同一个分支，而这些提交应该分布在不同的分支里\" class=\"headerlink\" title=\"把几个提交提交到了同一个分支，而这些提交应该分布在不同的分支里\"></a>把几个提交提交到了同一个分支，而这些提交应该分布在不同的分支里</h2><p>假设你有一个<code>master</code>分支， 执行<code>git log</code>, 你看到你做过两次提交:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git <span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\">commit e3851e817c451cc36f2e6f3049db528415e3c114</span><br><span class=\"line\">Author: Alex Lee &lt;alexlee@example.com&gt;</span><br><span class=\"line\">Date:   Tue Jul 22 15:39:27 2014 -0400</span><br><span class=\"line\"></span><br><span class=\"line\">    Bug <span class=\"comment\">#21 - Added CSRF protection</span></span><br><span class=\"line\"></span><br><span class=\"line\">commit 5ea51731d150f7ddc4a365437931cd8be3bf3131</span><br><span class=\"line\">Author: Alex Lee &lt;alexlee@example.com&gt;</span><br><span class=\"line\">Date:   Tue Jul 22 15:39:12 2014 -0400</span><br><span class=\"line\"></span><br><span class=\"line\">    Bug <span class=\"comment\">#14 - Fixed spacing on title</span></span><br><span class=\"line\"></span><br><span class=\"line\">commit a13b85e984171c6e2a1729bb061994525f626d14</span><br><span class=\"line\">Author: Aki Rose &lt;akirose@example.com&gt;</span><br><span class=\"line\">Date:   Tue Jul 21 01:12:48 2014 -0400</span><br><span class=\"line\"></span><br><span class=\"line\">    First commit</span><br></pre></td></tr></table></figure>\n<p>让我们用提交hash(commit hash)标记bug (<code>e3851e8</code> for #21, <code>5ea5173</code> for #14).</p>\n<p>首先, 我们把<code>master</code>分支重置到正确的提交(<code>a13b85e</code>):</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git reset --hard a13b85e</span><br><span class=\"line\">HEAD is now at a13b85e</span><br></pre></td></tr></table></figure>\n<p>现在, 我们对 bug #21 创建一个新的分支:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git checkout -b 21</span><br><span class=\"line\">(21)$</span><br></pre></td></tr></table></figure>\n<p>接着, 我们用 <em>cherry-pick</em> 把对bug #21的提交放入当前分支。 这意味着我们将应用(apply)这个提交(commit)，仅仅这一个提交(commit)，直接在HEAD上面。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(21)$ git cherry-pick e3851e8</span><br></pre></td></tr></table></figure>\n<p>这时候, 这里可能会产生冲突， 参见<a href=\"#interactive-rebase\">交互式 rebasing 章</a> <a href=\"#merge-conflict\"><strong>冲突节</strong></a> 解决冲突.</p>\n<p>再者， 我们为bug #14 创建一个新的分支, 也基于<code>master</code>分支</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(21)$ git checkout master</span><br><span class=\"line\">(master)$ git checkout -b 14</span><br><span class=\"line\">(14)$</span><br></pre></td></tr></table></figure>\n<p>最后, 为 bug #14 执行 <code>cherry-pick</code>:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(14)$ git cherry-pick 5ea5173</span><br></pre></td></tr></table></figure>\n<h2 id=\"想删除上游分支被删除了的本地分支\"><a href=\"#想删除上游分支被删除了的本地分支\" class=\"headerlink\" title=\"想删除上游分支被删除了的本地分支\"></a>想删除上游分支被删除了的本地分支</h2><p>一旦你在github 上面合并(merge)了一个pull request, 你就可以删除你fork里被合并的分支。 如果你不准备继续在这个分支里工作, 删除这个分支的本地拷贝会更干净，使你不会陷入工作分支和一堆陈旧分支的混乱之中。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git fetch -p</span><br></pre></td></tr></table></figure>\n<h2 id=\"不小心删除了我的分支\"><a href=\"#不小心删除了我的分支\" class=\"headerlink\" title=\"不小心删除了我的分支\"></a>不小心删除了我的分支</h2><p>如果你定期推送到远程, 多数情况下应该是安全的，但有些时候还是可能删除了还没有推到远程的分支。 让我们先创建一个分支和一个新的文件:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git checkout -b my-branch</span><br><span class=\"line\">(my-branch)$ git branch</span><br><span class=\"line\">(my-branch)$ touch foo.txt</span><br><span class=\"line\">(my-branch)$ ls</span><br><span class=\"line\">README.md foo.txt</span><br></pre></td></tr></table></figure>\n<p>添加文件并做一次提交</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(my-branch)$ git add .</span><br><span class=\"line\">(my-branch)$ git commit -m <span class=\"string\">'foo.txt added'</span></span><br><span class=\"line\">(my-branch)$ foo.txt added</span><br><span class=\"line\"> 1 files changed, 1 insertions(+)</span><br><span class=\"line\"> create mode 100644 foo.txt</span><br><span class=\"line\">(my-branch)$ git <span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\">commit 4e3cd85a670ced7cc17a2b5d8d3d809ac88d5012</span><br><span class=\"line\">Author: siemiatj &lt;siemiatj@example.com&gt;</span><br><span class=\"line\">Date:   Wed Jul 30 00:34:10 2014 +0200</span><br><span class=\"line\"></span><br><span class=\"line\">    foo.txt added</span><br><span class=\"line\"></span><br><span class=\"line\">commit 69204cdf0acbab201619d95ad8295928e7f411d5</span><br><span class=\"line\">Author: Kate Hudson &lt;katehudson@example.com&gt;</span><br><span class=\"line\">Date:   Tue Jul 29 13:14:46 2014 -0400</span><br><span class=\"line\"></span><br><span class=\"line\">    Fixes <span class=\"comment\">#6: Force pushing after amending commits</span></span><br></pre></td></tr></table></figure>\n<p>现在我们切回到主(master)分支，‘不小心的’删除<code>my-branch</code>分支</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(my-branch)$ git checkout master</span><br><span class=\"line\">Switched to branch <span class=\"string\">'master'</span></span><br><span class=\"line\">Your branch is up-to-date with <span class=\"string\">'origin/master'</span>.</span><br><span class=\"line\">(master)$ git branch -D my-branch</span><br><span class=\"line\">Deleted branch my-branch (was 4e3cd85).</span><br><span class=\"line\">(master)$ <span class=\"built_in\">echo</span> oh noes, deleted my branch!</span><br><span class=\"line\">oh noes, deleted my branch!</span><br></pre></td></tr></table></figure>\n<p>在这时候你应该想起了<code>reflog</code>, 一个升级版的日志，它存储了仓库(repo)里面所有动作的历史。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git reflog</span><br><span class=\"line\">69204cd HEAD@&#123;0&#125;: checkout: moving from my-branch to master</span><br><span class=\"line\">4e3cd85 HEAD@&#123;1&#125;: commit: foo.txt added</span><br><span class=\"line\">69204cd HEAD@&#123;2&#125;: checkout: moving from master to my-branch</span><br></pre></td></tr></table></figure>\n<p>正如你所见，我们有一个来自删除分支的提交hash(commit hash)，接下来看看是否能恢复删除了的分支。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git checkout -b my-branch-help</span><br><span class=\"line\">Switched to a new branch <span class=\"string\">'my-branch-help'</span></span><br><span class=\"line\">(my-branch-help)$ git reset --hard 4e3cd85</span><br><span class=\"line\">HEAD is now at 4e3cd85 foo.txt added</span><br><span class=\"line\">(my-branch-help)$ ls</span><br><span class=\"line\">README.md foo.txt</span><br></pre></td></tr></table></figure>\n<p>看! 我们把删除的文件找回来了。 Git的 <code>reflog</code> 在rebasing出错的时候也是同样有用的。</p>\n<h2 id=\"想删除一个分支\"><a href=\"#想删除一个分支\" class=\"headerlink\" title=\"想删除一个分支\"></a>想删除一个分支</h2><p>删除一个远程分支:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git push origin --delete my-branch</span><br></pre></td></tr></table></figure>\n<p>你也可以:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git push origin :my-branch</span><br></pre></td></tr></table></figure>\n<p>删除一个本地分支:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git branch -D my-branch</span><br></pre></td></tr></table></figure>\n<h2 id=\"想从别人正在工作的远程分支签出一个分支\"><a href=\"#想从别人正在工作的远程分支签出一个分支\" class=\"headerlink\" title=\"想从别人正在工作的远程分支签出一个分支\"></a>想从别人正在工作的远程分支签出一个分支</h2><p>首先, 从远程拉取(fetch) 所有分支:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git fetch --all</span><br></pre></td></tr></table></figure>\n<p>假设你想要从远程的<code>daves</code>分支签出到本地的<code>daves</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git checkout --track origin/daves</span><br><span class=\"line\">Branch daves <span class=\"built_in\">set</span> up to track remote branch daves from origin.</span><br><span class=\"line\">Switched to a new branch <span class=\"string\">'daves'</span></span><br></pre></td></tr></table></figure>\n<p>(<code>--track</code> 是 <code>git checkout -b [branch] [remotename]/[branch]</code> 的简写)</p>\n<p>这样就得到了一个<code>daves</code>分支的本地拷贝, 任何推过(pushed)的更新，远程都能看到.</p>\n<h1 id=\"Rebasing-和合并-Merging\"><a href=\"#Rebasing-和合并-Merging\" class=\"headerlink\" title=\"Rebasing 和合并(Merging)\"></a>Rebasing 和合并(Merging)</h1><h2 id=\"想撤销rebase-merge\"><a href=\"#想撤销rebase-merge\" class=\"headerlink\" title=\"想撤销rebase/merge\"></a>想撤销rebase/merge</h2><p>你可以合并(merge)或rebase了一个错误的分支, 或者完成不了一个进行中的rebase/merge。 Git 在进行危险操作的时候会把原始的HEAD保存在一个叫ORIG_HEAD的变量里, 所以要把分支恢复到rebase/merge前的状态是很容易的。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(my-branch)$ git reset --hard ORIG_HEAD</span><br></pre></td></tr></table></figure>\n<h2 id=\"已经rebase过-但是我不想强推\"><a href=\"#已经rebase过-但是我不想强推\" class=\"headerlink\" title=\"已经rebase过, 但是我不想强推\"></a>已经rebase过, 但是我不想强推</h2><p>不幸的是，如果你想把这些变化(changes)反应到远程分支上，你就必须得强推(force push)。 是因你快进(Fast forward)了提交，改变了Git历史, 远程分支不会接受变化(changes)，除非强推(force push)。这就是许多人使用 merge 工作流, 而不是 rebasing 工作流的主要原因之一， 开发者的强推(force push)会使大的团队陷入麻烦。使用时需要注意，一种安全使用 rebase 的方法是，不要把你的变化(changes)反映到远程分支上, 而是按下面的做:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git checkout my-branch</span><br><span class=\"line\">(my-branch)$ git rebase -i master</span><br><span class=\"line\">(my-branch)$ git checkout master</span><br><span class=\"line\">(master)$ git merge --ff-only my-branch</span><br></pre></td></tr></table></figure>\n<p>更多, 参见 <a href=\"http://stackoverflow.com/questions/11058312/how-can-i-use-git-rebase-without-requiring-a-forced-push\" target=\"_blank\" rel=\"noopener\">this SO thread</a>.</p>\n<h2 id=\"需要组合几个提交\"><a href=\"#需要组合几个提交\" class=\"headerlink\" title=\"需要组合几个提交\"></a>需要组合几个提交</h2><p>假设你的工作分支将会做对于 <code>master</code> 的pull-request。 一般情况下你不关心提交(commit)的时间戳，只想组合 <em>所有</em> 提交(commit) 到一个单独的里面, 然后重置(reset)重提交(recommit)。 确保主(master)分支是最新的和你的变化都已经提交了, 然后:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(my-branch)$ git reset --soft master</span><br><span class=\"line\">(my-branch)$ git commit -am <span class=\"string\">\"New awesome feature\"</span></span><br></pre></td></tr></table></figure>\n<p>如果你想要更多的控制, 想要保留时间戳, 你需要做交互式rebase (interactive rebase):</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(my-branch)$ git rebase -i master</span><br></pre></td></tr></table></figure>\n<p>如果没有相对的其它分支， 你将不得不相对自己的<code>HEAD</code> 进行 rebase。 例如：你想组合最近的两次提交(commit), 你将相对于<code>HEAD~2</code> 进行rebase， 组合最近3次提交(commit), 相对于<code>HEAD~3</code>, 等等。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git rebase -i HEAD~2</span><br></pre></td></tr></table></figure>\n<p>在你执行了交互式 rebase的命令(interactive rebase command)后, 你将在你的编辑器里看到类似下面的内容:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pick a9c8a1d Some refactoring</span><br><span class=\"line\">pick <span class=\"number\">01</span>b2fd8 New awesome feature</span><br><span class=\"line\">pick b729ad5 fixup</span><br><span class=\"line\">pick e3851e8 another <span class=\"keyword\">fix</span></span><br><span class=\"line\"></span><br><span class=\"line\"># Rebase <span class=\"number\">8074</span>d12..b729ad5 onto <span class=\"number\">8074</span>d12</span><br><span class=\"line\">#</span><br><span class=\"line\"># Command<span class=\"variable\">s:</span></span><br><span class=\"line\">#  <span class=\"keyword\">p</span>, pick = use commit</span><br><span class=\"line\">#  r, reword = use commit, but <span class=\"keyword\">edit</span> the commit message</span><br><span class=\"line\">#  <span class=\"keyword\">e</span>, <span class=\"keyword\">edit</span> = use commit, but <span class=\"keyword\">stop</span> <span class=\"keyword\">for</span> amending</span><br><span class=\"line\">#  s, squash = use commit, but meld into <span class=\"keyword\">previous</span> commit</span><br><span class=\"line\">#  <span class=\"keyword\">f</span>, fixup = like <span class=\"string\">\"squash\"</span>, but discard this commit<span class=\"string\">'s log message</span></span><br><span class=\"line\"><span class=\"string\">#  x, exec = run command (the rest of the line) using shell</span></span><br><span class=\"line\"><span class=\"string\">#</span></span><br><span class=\"line\"><span class=\"string\"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class=\"line\"><span class=\"string\">#</span></span><br><span class=\"line\"><span class=\"string\"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class=\"line\"><span class=\"string\">#</span></span><br><span class=\"line\"><span class=\"string\"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class=\"line\"><span class=\"string\">#</span></span><br><span class=\"line\"><span class=\"string\"># Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure>\n<p>所有以 <code>#</code> 开头的行都是注释, 不会影响 rebase.</p>\n<p>然后，你可以用任何上面命令列表的命令替换 <code>pick</code>, 你也可以通过删除对应的行来删除一个提交(commit)。</p>\n<p>例如, 如果你想 <strong>单独保留最旧(first)的提交(commit),组合所有剩下的到第二个里面</strong>, 你就应该编辑第二个提交(commit)后面的每个提交(commit) 前的单词为 <code>f</code>:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pick a9c8a1d Some refactoring</span><br><span class=\"line\">pick <span class=\"number\">01</span>b2fd8 New awesome feature</span><br><span class=\"line\"><span class=\"keyword\">f</span> b729ad5 fixup</span><br><span class=\"line\"><span class=\"keyword\">f</span> e3851e8 another <span class=\"keyword\">fix</span></span><br></pre></td></tr></table></figure>\n<p>如果你想组合这些提交(commit) <strong>并重命名这个提交(commit)</strong>, 你应该在第二个提交(commit)旁边添加一个<code>r</code>，或者更简单的用<code>s</code> 替代 <code>f</code>:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pick a9c8a1d Some refactoring</span><br><span class=\"line\">pick <span class=\"number\">01</span>b2fd8 New awesome feature</span><br><span class=\"line\">s b729ad5 fixup</span><br><span class=\"line\">s e3851e8 another <span class=\"keyword\">fix</span></span><br></pre></td></tr></table></figure>\n<p>你可以在接下来弹出的文本提示框里重命名提交(commit)。</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Newer, awesomer features</span><br><span class=\"line\"></span><br><span class=\"line\"># Please enter the commit message <span class=\"keyword\">for</span> your <span class=\"keyword\">changes</span>. Lines starting</span><br><span class=\"line\"># with <span class=\"string\">'#'</span> will <span class=\"keyword\">be</span> ignored, <span class=\"built_in\">and</span> <span class=\"keyword\">an</span> <span class=\"built_in\">empty</span> message aborts the commit.</span><br><span class=\"line\"># rebase in progress; onto 8074d12</span><br><span class=\"line\"># You are currently editing <span class=\"keyword\">a</span> commit <span class=\"keyword\">while</span> rebasing branch <span class=\"string\">'master'</span> <span class=\"keyword\">on</span> <span class=\"string\">'8074d12'</span>.</span><br><span class=\"line\">#</span><br><span class=\"line\"># Changes <span class=\"keyword\">to</span> <span class=\"keyword\">be</span> committed:</span><br><span class=\"line\">#\tmodified:   README.md</span><br><span class=\"line\">#</span><br></pre></td></tr></table></figure>\n<p>如果成功了, 你应该看到类似下面的内容:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ Successfully rebased and updated refs/heads/master.</span><br></pre></td></tr></table></figure>\n<h3 id=\"安全合并策略\"><a href=\"#安全合并策略\" class=\"headerlink\" title=\"安全合并策略\"></a>安全合并策略</h3><p><code>--no-commit</code> 执行合并(merge)但不自动提交, 给用户在做提交前检查和修改的机会。 <code>no-ff</code> 会为特性分支(feature branch)的存在过留下证据, 保持项目历史一致。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git merge --no-ff --no-commit my-branch</span><br></pre></td></tr></table></figure>\n<h3 id=\"需要将一个分支合并成一个提交\"><a href=\"#需要将一个分支合并成一个提交\" class=\"headerlink\" title=\"需要将一个分支合并成一个提交\"></a>需要将一个分支合并成一个提交</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git merge --squash my-branch</span><br></pre></td></tr></table></figure>\n<h3 id=\"只想组合未推的提交\"><a href=\"#只想组合未推的提交\" class=\"headerlink\" title=\"只想组合未推的提交\"></a>只想组合未推的提交</h3><p>有时候，在将数据推向上游之前，你有几个正在进行的工作提交(commit)。这时候不希望把已经推(push)过的组合进来，因为其他人可能已经有提交(commit)引用它们了。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git rebase -i @&#123;u&#125;</span><br></pre></td></tr></table></figure>\n<p>这会产生一次交互式的rebase(interactive rebase), 只会列出没有推(push)的提交(commit)， 在这个列表时进行reorder/fix/squash 都是安全的。</p>\n<h2 id=\"检查是否分支上的所有提交都合并过了\"><a href=\"#检查是否分支上的所有提交都合并过了\" class=\"headerlink\" title=\"检查是否分支上的所有提交都合并过了\"></a>检查是否分支上的所有提交都合并过了</h2><p>检查一个分支上的所有提交(commit)是否都已经合并(merge)到了其它分支, 你应该在这些分支的head(或任何 commits)之间做一次diff:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git <span class=\"built_in\">log</span> --graph --left-right --cherry-pick --oneline HEAD...feature/120-on-scroll</span><br></pre></td></tr></table></figure>\n<p>这会告诉你在一个分支里有而另一个分支没有的所有提交(commit), 和分支之间不共享的提交(commit)的列表。 另一个做法可以是:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git <span class=\"built_in\">log</span> master ^feature/120-on-scroll --no-merges</span><br></pre></td></tr></table></figure>\n<h2 id=\"交互式rebase可能出现的问题\"><a href=\"#交互式rebase可能出现的问题\" class=\"headerlink\" title=\"交互式rebase可能出现的问题\"></a>交互式rebase可能出现的问题</h2><h3 id=\"这个rebase编辑屏幕出现’noop’\"><a href=\"#这个rebase编辑屏幕出现’noop’\" class=\"headerlink\" title=\"这个rebase编辑屏幕出现’noop’\"></a>这个rebase编辑屏幕出现’noop’</h3><p>如果你看到的是这样:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">noop</span><br></pre></td></tr></table></figure></p>\n<p>这意味着你rebase的分支和当前分支在同一个提交(commit)上, 或者 <em>领先(ahead)</em> 当前分支。 你可以尝试:</p>\n<ul>\n<li>检查确保主(master)分支没有问题</li>\n<li>rebase  <code>HEAD~2</code> 或者更早</li>\n</ul>\n<h3 id=\"有冲突的情况\"><a href=\"#有冲突的情况\" class=\"headerlink\" title=\"有冲突的情况\"></a>有冲突的情况</h3><p>如果你不能成功的完成rebase, 你可能必须要解决冲突。</p>\n<p>首先执行 <code>git status</code> 找出哪些文件有冲突:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(my-branch)$ git status</span><br><span class=\"line\">On branch my-branch</span><br><span class=\"line\">Changes not staged <span class=\"keyword\">for</span> commit:</span><br><span class=\"line\">  (use <span class=\"string\">\"git add &lt;file&gt;...\"</span> to update what will be committed)</span><br><span class=\"line\">  (use <span class=\"string\">\"git checkout -- &lt;file&gt;...\"</span> to discard changes <span class=\"keyword\">in</span> working directory)</span><br><span class=\"line\"></span><br><span class=\"line\">truemodified:   README.md</span><br></pre></td></tr></table></figure>\n<p>在这个例子里面, <code>README.md</code> 有冲突。 打开这个文件找到类似下面的内容:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">some code</span><br><span class=\"line\">=========</span><br><span class=\"line\">some code</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class=\"keyword\">new</span>-commit</span><br></pre></td></tr></table></figure>\n<p>你需要解决新提交的代码(示例里, 从中间<code>==</code>线到<code>new-commit</code>的地方)与<code>HEAD</code> 之间不一样的地方.</p>\n<p>有时候这些合并非常复杂，你应该使用可视化的差异编辑器(visual diff editor):</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master*)$ git mergetool -t opendiff</span><br></pre></td></tr></table></figure>\n<p>在你解决完所有冲突和测试过后, <code>git add</code> 变化了的(changed)文件, 然后用<code>git rebase --continue</code> 继续rebase。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(my-branch)$ git add README.md</span><br><span class=\"line\">(my-branch)$ git rebase --<span class=\"built_in\">continue</span></span><br></pre></td></tr></table></figure>\n<p>如果在解决完所有的冲突过后，得到了与提交前一样的结果, 可以执行<code>git rebase --skip</code>。</p>\n<p>任何时候你想结束整个rebase 过程，回来rebase前的分支状态, 你可以做:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(my-branch)$ git rebase --abort</span><br></pre></td></tr></table></figure>\n<h1 id=\"杂项-Miscellaneous-Objects\"><a href=\"#杂项-Miscellaneous-Objects\" class=\"headerlink\" title=\"杂项(Miscellaneous Objects)\"></a>杂项(Miscellaneous Objects)</h1><h2 id=\"克隆所有子模块\"><a href=\"#克隆所有子模块\" class=\"headerlink\" title=\"克隆所有子模块\"></a>克隆所有子模块</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> --recursive git://github.com/foo/bar.git</span><br></pre></td></tr></table></figure>\n<p>如果已经克隆了:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除标签\"><a href=\"#删除标签\" class=\"headerlink\" title=\"删除标签\"></a>删除标签</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -d &lt;tag_name&gt;</span><br><span class=\"line\">$ git push &lt;remote&gt; :refs/tags/&lt;tag_name&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"恢复已删除标签\"><a href=\"#恢复已删除标签\" class=\"headerlink\" title=\"恢复已删除标签\"></a>恢复已删除标签</h2><p>如果你想恢复一个已删除标签(tag), 可以按照下面的步骤: 首先, 需要找到无法访问的标签(unreachable tag):</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git fsck --unreachable | grep tag</span><br></pre></td></tr></table></figure>\n<p>记下这个标签(tag)的hash，然后用Git的 <a href=\"http://git-scm.com/docs/git-update-ref\" target=\"_blank\" rel=\"noopener\">update-ref</a>:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git update-ref refs/tags/&lt;tag_name&gt; &lt;<span class=\"built_in\">hash</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>这时你的标签(tag)应该已经恢复了。</p>\n<h2 id=\"已删除补丁\"><a href=\"#已删除补丁\" class=\"headerlink\" title=\"已删除补丁\"></a>已删除补丁</h2><p>如果某人在 GitHub 上给你发了一个pull request, 但是然后他删除了他自己的原始 fork, 你将没法克隆他们的提交(commit)或使用 <code>git am</code>。在这种情况下, 最好手动的查看他们的提交(commit)，并把它们拷贝到一个本地新分支，然后做提交。</p>\n<p>做完提交后, 再修改作者，参见<a href=\"#commit-wrong-author\">变更作者</a>。 然后, 应用变化, 再发起一个新的pull request。</p>\n<h1 id=\"跟踪文件-Tracking-Files\"><a href=\"#跟踪文件-Tracking-Files\" class=\"headerlink\" title=\"跟踪文件(Tracking Files)\"></a>跟踪文件(Tracking Files)</h1><h2 id=\"只想改变一个文件名字的大小写，而不修改内容\"><a href=\"#只想改变一个文件名字的大小写，而不修改内容\" class=\"headerlink\" title=\"只想改变一个文件名字的大小写，而不修改内容\"></a>只想改变一个文件名字的大小写，而不修改内容</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git mv --force myfile MyFile</span><br></pre></td></tr></table></figure>\n<h2 id=\"想从Git删除一个文件，但保留该文件\"><a href=\"#想从Git删除一个文件，但保留该文件\" class=\"headerlink\" title=\"想从Git删除一个文件，但保留该文件\"></a>想从Git删除一个文件，但保留该文件</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git rm --cached log.txt</span><br></pre></td></tr></table></figure>\n<h1 id=\"配置-Configuration\"><a href=\"#配置-Configuration\" class=\"headerlink\" title=\"配置(Configuration)\"></a>配置(Configuration)</h1><h2 id=\"想给一些Git命令添加别名\"><a href=\"#想给一些Git命令添加别名\" class=\"headerlink\" title=\"想给一些Git命令添加别名\"></a>想给一些Git命令添加别名</h2><p>在 OS X 和 Linux 下, 你的 Git的配置文件储存在 <figure class=\"highlight plain\"><figcaption><span>部分添加了一些快捷别名(和一些我容易拼写错误的)，如下:</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```vim</span><br><span class=\"line\">[alias]</span><br><span class=\"line\">    a = add</span><br><span class=\"line\">    amend = commit --amend</span><br><span class=\"line\">    c = commit</span><br><span class=\"line\">    ca = commit --amend</span><br><span class=\"line\">    ci = commit -a</span><br><span class=\"line\">    co = checkout</span><br><span class=\"line\">    d = diff</span><br><span class=\"line\">    dc = diff --changed</span><br><span class=\"line\">    ds = diff --staged</span><br><span class=\"line\">    f = fetch</span><br><span class=\"line\">    loll = log --graph --decorate --pretty=oneline --abbrev-commit</span><br><span class=\"line\">    m = merge</span><br><span class=\"line\">    one = log --pretty=oneline</span><br><span class=\"line\">    outstanding = rebase -i @&#123;u&#125;</span><br><span class=\"line\">    s = status</span><br><span class=\"line\">    unpushed = log @&#123;u&#125;</span><br><span class=\"line\">    wc = whatchanged</span><br><span class=\"line\">    wip = rebase -i @&#123;u&#125;</span><br><span class=\"line\">    zap = fetch -p</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"想缓存一个仓库的用户名和密码\"><a href=\"#想缓存一个仓库的用户名和密码\" class=\"headerlink\" title=\"想缓存一个仓库的用户名和密码\"></a>想缓存一个仓库的用户名和密码</h2><p>你可能有一个仓库需要授权，这时你可以缓存用户名和密码，而不用每次推/拉(push/pull)的时候都输入，Credential helper能帮你。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global credential.helper cache</span><br><span class=\"line\"><span class=\"comment\"># Set git to use the credential memory cache</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global credential.helper <span class=\"string\">'cache --timeout=3600'</span></span><br><span class=\"line\"><span class=\"comment\"># Set the cache to timeout after 1 hour (setting is in seconds)</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"不知道我做错了些什么\"><a href=\"#不知道我做错了些什么\" class=\"headerlink\" title=\"不知道我做错了些什么\"></a>不知道我做错了些什么</h1><p>你把事情搞砸了：你 <code>重置(reset)</code> 了一些东西, 或者你合并了错误的分支, 亦或你强推了后找不到你自己的提交(commit)了。有些时候, 你一直都做得很好, 但你想回到以前的某个状态。</p>\n<p>这就是 <code>git reflog</code> 的目的， <code>reflog</code> 记录对分支顶端(the tip of a branch)的任何改变, 即使那个顶端没有被任何分支或标签引用。基本上, 每次HEAD的改变, 一条新的记录就会增加到<code>reflog</code>。遗憾的是，这只对本地分支起作用，且它只跟踪动作 (例如，不会跟踪一个没有被记录的文件的任何改变)。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(master)$ git reflog</span><br><span class=\"line\">0a2e358 HEAD@&#123;0&#125;: reset: moving to HEAD~2</span><br><span class=\"line\">0254ea7 HEAD@&#123;1&#125;: checkout: moving from 2.2 to master</span><br><span class=\"line\">c10f740 HEAD@&#123;2&#125;: checkout: moving from master to 2.2</span><br></pre></td></tr></table></figure>\n<p>上面的reflog展示了从master分支签出(checkout)到2.2 分支，然后再签回。 那里，还有一个硬重置(hard reset)到一个较旧的提交。最新的动作出现在最上面以 <code>HEAD@{0}</code>标识.</p>\n<p>如果事实证明你不小心回移(move back)了提交(commit), reflog 会包含你不小心回移前master上指向的提交(0254ea7)。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard 0254ea7</span><br></pre></td></tr></table></figure>\n<p>然后使用git reset就可以把master改回到之前的commit，这提供了一个在历史被意外更改情况下的安全网。</p>\n<p>(<a href=\"https://www.atlassian.com/git/tutorials/rewriting-history/git-reflog\" target=\"_blank\" rel=\"noopener\">摘自</a>).</p>\n<h1 id=\"其它资源-Other-Resources\"><a href=\"#其它资源-Other-Resources\" class=\"headerlink\" title=\"其它资源(Other Resources)\"></a>其它资源(Other Resources)</h1><h2 id=\"书-Books\"><a href=\"#书-Books\" class=\"headerlink\" title=\"书(Books)\"></a>书(Books)</h2><ul>\n<li><a href=\"https://git-scm.com/book/en/v2\" target=\"_blank\" rel=\"noopener\">Pro Git</a> - Scott Chacon’s excellent git book</li>\n<li><a href=\"https://github.com/pluralsight/git-internals-pdf\" target=\"_blank\" rel=\"noopener\">Git Internals</a> - Scott Chacon’s other excellent git book</li>\n</ul>\n<h2 id=\"教程-Tutorials\"><a href=\"#教程-Tutorials\" class=\"headerlink\" title=\"教程(Tutorials)\"></a>教程(Tutorials)</h2><ul>\n<li><a href=\"https://learngitbranching.js.org/\" target=\"_blank\" rel=\"noopener\">Learn Git branching</a> 一个基于网页的交互式 branching/merging/rebasing 教程</li>\n<li><a href=\"https://medium.com/@porteneuve/getting-solid-at-git-rebase-vs-merge-4fa1a48c53aa\" target=\"_blank\" rel=\"noopener\">Getting solid at Git rebase vs. merge</a></li>\n<li><a href=\"https://github.com/asmeurer/git-workflow\" target=\"_blank\" rel=\"noopener\">git-workflow</a> - <a href=\"https://github.com/asmeurer\" target=\"_blank\" rel=\"noopener\">Aaron Meurer</a>的怎么使用Git为开源仓库贡献</li>\n<li><a href=\"http://hugogiraudel.com/2015/08/13/github-as-a-workflow/\" target=\"_blank\" rel=\"noopener\">GitHub as a workflow</a> - 使用GitHub做为工作流的趣事, 尤其是空PRs</li>\n</ul>\n<h2 id=\"脚本和工具-Scripts-and-Tools\"><a href=\"#脚本和工具-Scripts-and-Tools\" class=\"headerlink\" title=\"脚本和工具(Scripts and Tools)\"></a>脚本和工具(Scripts and Tools)</h2><ul>\n<li><a href=\"http://firstaidgit.io/\" target=\"_blank\" rel=\"noopener\">firstaidgit.io</a> 一个可搜索的最常被问到的Git的问题</li>\n<li><a href=\"https://github.com/unixorn/git-extra-commands\" target=\"_blank\" rel=\"noopener\">git-extra-commands</a> - 一堆有用的额外的Git脚本</li>\n<li><a href=\"https://github.com/tj/git-extras\" target=\"_blank\" rel=\"noopener\">git-extras</a> - GIT 工具集 – repo summary, repl, changelog population, author commit percentages and more</li>\n<li><a href=\"https://github.com/qw3rtman/git-fire\" target=\"_blank\" rel=\"noopener\">git-fire</a> - git-fire 是一个 Git 插件，用于帮助在紧急情况下添加所有当前文件, 做提交(committing), 和推(push)到一个新分支(阻止合并冲突)。</li>\n<li><a href=\"https://github.com/git-tips/tips\" target=\"_blank\" rel=\"noopener\">git-tips</a> - Git小提示</li>\n<li><a href=\"https://github.com/Originate/git-town\" target=\"_blank\" rel=\"noopener\">git-town</a> - 通用，高级Git工作流支持！ <a href=\"http://www.git-town.com\" target=\"_blank\" rel=\"noopener\">http://www.git-town.com</a></li>\n</ul>\n<h2 id=\"GUI客户端-GUI-Clients\"><a href=\"#GUI客户端-GUI-Clients\" class=\"headerlink\" title=\"GUI客户端(GUI Clients)\"></a>GUI客户端(GUI Clients)</h2><ul>\n<li><a href=\"https://www.gitkraken.com/\" target=\"_blank\" rel=\"noopener\">GitKraken</a> - 豪华的Git客户端 Windows, Mac &amp; Linux</li>\n<li><a href=\"https://git-cola.github.io/\" target=\"_blank\" rel=\"noopener\">git-cola</a> - 另外一个Git客户端 Windows &amp; OS X</li>\n<li><a href=\"https://github.com/git-up/GitUp\" target=\"_blank\" rel=\"noopener\">GitUp</a> - 一个新的Git客户端，在处理Git的复杂性上有自己的特点</li>\n<li><a href=\"https://rowanj.github.io/gitx/\" target=\"_blank\" rel=\"noopener\">gitx-dev</a> - 图形化的Git客户端 OS X</li>\n<li><a href=\"https://www.sourcetreeapp.com/\" target=\"_blank\" rel=\"noopener\">Source Tree</a> - 免费的图形化Git客户端 Windows &amp; OS X</li>\n<li><a href=\"http://www.git-tower.com/\" target=\"_blank\" rel=\"noopener\">Tower</a> - 图形化Git客户端 OS X(付费)</li>\n<li><a href=\"https://www.syntevo.com/smartgit/\" target=\"_blank\" rel=\"noopener\">SmartGit</a> - 推荐，对个人用户免费</li>\n</ul>\n","categories":[{"name":"飞行手册","slug":"飞行手册","permalink":"http://ruanxinyu.github.io/categories/飞行手册/"}],"tags":[{"name":"飞行手册","slug":"飞行手册","permalink":"http://ruanxinyu.github.io/tags/飞行手册/"}]},{"title":"Ubuntu下Mysql+Keepalived双主热备高可用环境的搭建","slug":"Ubuntu下Mysql-Keepalived双主热备高可用环境的搭建","date":"un44fin44","updated":"un55fin55","comments":true,"path":"posts/Ubuntu下Mysql-Keepalived双主热备高可用环境的搭建/","link":"","permalink":"http://ruanxinyu.github.io/posts/Ubuntu下Mysql-Keepalived双主热备高可用环境的搭建/","excerpt":"","keywords":"","text":"Mysql复制模式及原理Mysql内建的复制功能是构建大型，高性能应用程序的基础。Mysql将数据库的更改写入到二进制日志文件，而复制功能就是基于该日志完成的。Mysql的二进制日志格式也有三种：STATEMENT，ROW，MIXED。对应的是Mysql的三种复制模式. 复制原理master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；salve服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件，同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。过程如下： 注意几点： master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。 slave开启两个线程：IO线程和SQL线程。其中：IO线程负责读取master的binlog内容到中继日志relay log里；SQL线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和master数据保持一致了。 Mysql复制至少需要两个Mysql的服务，当然Mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。 Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本） master和slave两节点间时间需同步 主服务写入日志和从数据库回访日志都是串行的 注意：所有对表的操作都需要在主服务器上操作，否则会造成数据冲突 基于SQL语句的复制(SBR)基于SQL语句的复制(statement-based replication, SBR)的优点有： 产生的binlog文件较小，比较节省空间 binlog既可以用来复制，也可以用于实时的还原 主从版本可以不一样，从服务器版本可以比主服务器版本高。 缺点有： 不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候。 调用具有不确定因素的 UDF 时复制也可能出问题，比如LOAD_FILE()，UUID()，USER()，FOUND_ROWS()，SYSDATE() INSERT ... SELECT 会产生比 RBR 更多的行级锁 基于行的复制(RBR)基于行的复制(row-based replication, RBR)的优点有： 任何情况都可以被复制，这对复制来说是最安全可靠的 多数情况下，从服务器上的表如果有主键的话，复制就会快了很多 执行 INSERT，UPDATE，DELETE 语句时锁更少 从服务器上采用多线程来执行复制成为可能 缺点有： binlog 文件太大 复杂的回滚时 binlog 中会包含大量的数据 主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题 UDF 产生的大 BLOB 值会导致复制变慢 无法从 binlog 中看到都复制了写什么语句，无法进行审计 混合模式复制(MBR)混合模式复制(mixed-based replication, MBR) 解决的问题Mysql支持主从复制模式和主主复制模式，能够解决以下的问题： 数据分布 (Data distribution ) 负载平衡(load balancing) 数据备份(Backups) ，保证数据安全 高可用性和容错行(High availability and failover) 实现读写分离，缓解数据库压力 基础环境说明本次教程搭建的架构图如下所示，通过Mysql的主从同步实现数据的同步，通过KeepAlived实现Mysql的故障时的自动切换，其中为192.168.1.132和192.168.1.133，VIP为192.168.1.134。 使用的Ubuntu是18.04.1版本：VirtualBox安装Ubuntu教程 使用的Mysql是8.0.12版本：Ubuntu下Mysql的安装与验证 使用的KeepAlived是2.0.7版本：Ubuntu下KeepAlived的安装与配置 Mysql的主从同步设置 用户配置文件位置：/etc/mysql/my.cnf pid文件位置：/var/run/mysqld/mysqld.pid socket文件位置：/var/run/mysqld/mysqld.sock 数据目录： /var/lib/mysql 错误日志文件： /var/log/mysql/error.log 配置my.cnf文件Mysql_01(192.168.1.132)编辑sudo vim /etc/mysql/my.cnf文件，添加如下内容： 12345[mysqld]log-bin=mysql-binrelay_log=mysql-relay-binserver-id=1log_slave_updates=1 Mysql_02(192.168.1.133)编辑sudo vim /etc/mysql/my.cnf文件，添加如下内容： 12345[mysqld]log-bin=mysql-binrelay_log=mysql-relay-binserver-id=2log_slave_updates=1 上述配置mysql的二进制日志的名称为mysql-bin，采用的是相对目录，具体绝对目录可以通过执行show variables like &#39;log_%&#39;;得到，如下所示 如上述配置指定了relay_log的值，否则mysql会自动根据主机的hostname命名，如果修改hostname的话可能就会出问题，在error.log中也可以看到对应的警告： 创建复制用户Mysql_01(192.168.1.132)中执行mysql -u root -p进入到mysql的控制台执行如下语句： 123CREATE USER 'repl'@'192.168.1.133' IDENTIFIED BY 'mysql';GRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168.1.133';FLUSH PRIVILEGES; Mysql_02(192.168.1.133)中执行mysql -u root -p进入到mysql的控制台执行如下语句： 123CREATE USER 'repl'@'192.168.1.132' IDENTIFIED BY 'mysql';GRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168.1.132';FLUSH PRIVILEGES; 执行CHANGE MASTER TO语句Mysql_01(192.168.1.132)中执行mysql -u root -p进入到mysql的控制台执行如下语句： 123456CHANGE MASTER TO MASTER_HOST='192.168.1.133', MASTER_USER='repl', MASTER_PASSWORD='mysql', MASTER_LOG_FILE='mysql-bin.000001', MASTER_LOG_POS=0; Mysql_02(192.168.1.133)中执执行mysql -u root -p进入到mysql的控制台执行如下语句： 123456CHANGE MASTER TO MASTER_HOST='192.168.1.132', MASTER_USER='repl', MASTER_PASSWORD='mysql', MASTER_LOG_FILE='mysql-bin.000001', MASTER_LOG_POS=0; MASTER_LOG_FILE用来指定初始复制时的mysql1中的binlog文件， MASTER_LOG_POS用来指定初始复制时binlog文件的位置 重启并查看同步状态 sudo systemctl restart mysql.service重启mysql mysql -u root -p进入到mysql的控制台执行start slave; 通过show slave status\\G;查看启动状态，如果出现下面的内容则表示成功 KeepAlived的配置Keepalived的安装请参考：Ubuntu下KeepAlived的安装与配置。配置文件主要有如下几点变化： 两台机器的state都设置为BACKUP，同时nopreempt配置，可以防止切换到从库后，主keepalived恢复后自动切换回主库 virtual_ipaddress改为192.168.1.134 vrrp_script中的命令改为netstat -na | grep LISTEN | grep 3306 || killall keepalived 特别说明: 此处仅仅简单的通过检查33060端口来判断mysql是否正常。你可以可以根据自己的需求，将该脚本设计的更复杂一些。比如根据数据库的插入、删除等是否可用、主从线程是否开启等进行细分。提高检测的精准度。 Mysql_01(192.168.1.132)中KeepAlived的配置如下： 1234567891011121314151617181920vrrp_script chk_service_ok &#123; script \"netstat -na | grep LISTEN | grep 3306 || killall keepalived\" interval 2&#125;vrrp_instance VI_1 &#123; interface enp0s3 state BACKUP # 通过下面的priority来区分MASTER和BACKUP，也只有如此，底下的nopreempt才有效 virtual_router_id 51 priority 100 nopreempt # 防止切换到从库后，主keepalived恢复后自动切换回主库 virtual_ipaddress &#123; 192.168.1.134/24 &#125; track_script &#123; chk_service_ok &#125;&#125; Mysql_02(192.168.1.133)中KeepAlived的配置如下： 1234567891011121314151617181920vrrp_script chk_service_ok &#123; script \"netstat -na | grep LISTEN | grep 3306 || killall keepalived\" interval 2&#125;vrrp_instance VI_1 &#123; interface enp0s3 state BACKUP # 通过下面的priority来区分MASTER和BACKUP，也只有如此，底下的nopreempt才有效 virtual_router_id 51 priority 80 nopreempt # 防止切换到从库后，主keepalived恢复后自动切换回主库 virtual_ipaddress &#123; 192.168.1.134/24 &#125; track_script &#123; chk_service_ok &#125;&#125; 配置完毕之后执行sudo systemctl restart keepalived重新启动keepalived。 功能验证正常情况下的验证首先，通过ip a可以看到VIP在Mysql_01(192.168.1.132)上： 在Mysql_01(192.168.1.132)上执行mysql -u root -p进入到mysql的控制台， 创建数据库create database database_01;;在Mysql_02(192.168.1.133)上执行mysql -u root -p进入到mysql的控制台， 创建数据库create database database_02;; 然后分别在两台机器上执行show databases；，可以看到两台mysql中都包含database_01和database_02，说明mysql的主主同步生效。 异常恢复下的验证Mysql_01(192.168.1.132)上执行sudo systemctl stop mysql.service停止mysql以模拟故障，此时可以看到VIP(192.168.1.134)已经漂移到mysql_02上，我们ssh连接VIP并往数据库中创建一个数据库create database database_vip;，可以看到是可以正常创建的，说明keepalived已经能保证mysql的高可用。 此时我们重新启动Mysql_01(192.168.1.132)以模拟故障恢复，此时发现VIP还在mysql_02上，同时Mysql_01的数据库中也已经存在database_vip数据库。说明故障恢复后数据仍旧能够正常同步。 常见操作说明彻底解除主从复制关系 stop slave reset slave; 或直接删除master.info和relay-log.info这两个文件 修改my.cnf删除主从相关配置参数 让slave不随MySQL自动启动修改my.cnf, 在[mysqld]中增加skip-slave-start选项 数据备份的快速恢复执行如下命令备份，可以保留 file 和 position 的信息，在新搭建一个slave的时候，还原完数据库， file 和 position 的信息也随之更新，接着再start slave 就可以很迅速的完成增量同步： 1mysqldump --master-data --single-transaction --user=username --password=password dbname&gt; dumpfilename 如何限制复制哪些数据库 在执行grant授权的时候就限定数据库 在主服务器上限定binlog_do_db = 数据库名 主服务器上不限定数据库，在从服务器上限定replicate-do-db = 数据库名 修改log-bin和relay_log后重启报错先执行reset slave，然后执行start slave即可。 日志出现[Warning] IP address &#39;xxxx&#39; could not be resolved: Name or service not knownmysql默认会反向解析DNS，对于访问者Mysql不会判断是hosts还是ip都会进行dns反向解析，我们可以通过在my.cnf中添加skip-name-resolve禁用dns反查即可。 主备同步报：Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs是因为数据目录下的/var/lib/mysql/auto.cnf文件是一样导致的，我们可以删除备机上的该文件，然后重启mysql","raw":"---\ntitle: Ubuntu下Mysql+Keepalived双主热备高可用环境的搭建\ntags: 环境搭建\ncategories: 环境搭建\ndate: 2018-10-04 12:50:27\n---\n\n# Mysql复制模式及原理\n\nMysql内建的复制功能是构建大型，高性能应用程序的基础。Mysql将数据库的更改写入到二进制日志文件，而复制功能就是基于该日志完成的。Mysql的二进制日志格式也有三种：STATEMENT，ROW，MIXED。对应的是Mysql的三种复制模式.\n\n## 复制原理\n\nmaster服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；salve服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件，同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。过程如下：\n{% asset_img 2018-10-04-20-43-35.png [blog.ruanxinyu.cn] %}\n\n注意几点：\n\n+ master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。\n+ slave开启两个线程：IO线程和SQL线程。其中：IO线程负责读取master的binlog内容到中继日志relay log里；SQL线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和master数据保持一致了。\n+ Mysql复制至少需要两个Mysql的服务，当然Mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。\n+ Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）\n+ master和slave两节点间时间需同步\n+ 主服务写入日志和从数据库回访日志都是串行的\n\n> 注意：所有对表的操作都需要在主服务器上操作，否则会造成数据冲突\n\n## 基于SQL语句的复制(SBR)\n\n基于SQL语句的复制(statement-based replication, SBR)的优点有：\n\n1. 产生的binlog文件较小，比较节省空间\n1. binlog既可以用来复制，也可以用于实时的还原\n1. 主从版本可以不一样，从服务器版本可以比主服务器版本高。\n\n缺点有：\n\n1. 不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候。\n1. 调用具有不确定因素的 UDF 时复制也可能出问题，比如`LOAD_FILE()`，`UUID()`，`USER()`，`FOUND_ROWS()`，`SYSDATE()`\n1. `INSERT ... SELECT` 会产生比 RBR 更多的行级锁\n\n## 基于行的复制(RBR)\n\n基于行的复制(row-based replication, RBR)的优点有：\n\n1. 任何情况都可以被复制，这对复制来说是最安全可靠的\n1. 多数情况下，从服务器上的表如果有主键的话，复制就会快了很多\n1. 执行 INSERT，UPDATE，DELETE 语句时锁更少\n1. 从服务器上采用多线程来执行复制成为可能\n\n缺点有：\n\n1. binlog 文件太大\n1. 复杂的回滚时 binlog 中会包含大量的数据\n1. 主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题\n1. UDF 产生的大 BLOB 值会导致复制变慢\n1. 无法从 binlog 中看到都复制了写什么语句，无法进行审计\n\n## 混合模式复制(MBR)\n\n混合模式复制(mixed-based replication, MBR)\n\n## 解决的问题\n\nMysql支持主从复制模式和主主复制模式，能够解决以下的问题：\n\n1. 数据分布 (Data distribution )\n1. 负载平衡(load balancing)\n1. 数据备份(Backups) ，保证数据安全\n1. 高可用性和容错行(High availability and failover)\n1. 实现读写分离，缓解数据库压力\n\n# 基础环境说明\n\n本次教程搭建的架构图如下所示，通过Mysql的主从同步实现数据的同步，通过KeepAlived实现Mysql的故障时的自动切换，其中为`192.168.1.132`和`192.168.1.133`，VIP为`192.168.1.134`。\n{% asset_img 2018-10-05-19-29-21.png [blog.ruanxinyu.cn] %}\n\n1. 使用的Ubuntu是`18.04.1`版本：{% post_link VirtualBox安装Ubuntu教程 %}\n1. 使用的Mysql是`8.0.12`版本：{% post_link Ubuntu下Mysql的安装与验证 %}\n1. 使用的KeepAlived是`2.0.7`版本：{% post_link Ubuntu下KeepAlived的安装与配置 %}\n\n# Mysql的主从同步设置\n\n1. 用户配置文件位置：`/etc/mysql/my.cnf`\n1. pid文件位置：`/var/run/mysqld/mysqld.pid`\n1. socket文件位置：`/var/run/mysqld/mysqld.sock`\n1. 数据目录： `/var/lib/mysql`\n1. 错误日志文件： `/var/log/mysql/error.log`\n\n## 配置my.cnf文件\n\nMysql_01(`192.168.1.132`)编辑`sudo vim /etc/mysql/my.cnf`文件，添加如下内容：\n\n```bash\n[mysqld]\nlog-bin=mysql-bin\nrelay_log=mysql-relay-bin\nserver-id=1\nlog_slave_updates=1\n```\n\nMysql_02(`192.168.1.133`)编辑`sudo vim /etc/mysql/my.cnf`文件，添加如下内容：\n\n```bash\n[mysqld]\nlog-bin=mysql-bin\nrelay_log=mysql-relay-bin\nserver-id=2\nlog_slave_updates=1\n```\n\n上述配置mysql的二进制日志的名称为`mysql-bin`，采用的是相对目录，具体绝对目录可以通过执行`show variables like 'log_%';`得到，如下所示\n\n{% asset_img 2018-10-05-21-11-21.png [blog.ruanxinyu.cn] %}\n\n如上述配置指定了`relay_log`的值，否则mysql会自动根据主机的hostname命名，如果修改hostname的话可能就会出问题，在error.log中也可以看到对应的警告：\n\n{% asset_img 2018-10-05-21-31-11.png [blog.ruanxinyu.cn] %}\n\n## 创建复制用户\n\nMysql_01(`192.168.1.132`)中执行`mysql -u root -p`进入到mysql的控制台执行如下语句：\n\n```sql\nCREATE USER 'repl'@'192.168.1.133' IDENTIFIED BY 'mysql';\nGRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168.1.133';\nFLUSH PRIVILEGES;\n```\n\nMysql_02(`192.168.1.133`)中执行`mysql -u root -p`进入到mysql的控制台执行如下语句：\n\n```sql\nCREATE USER 'repl'@'192.168.1.132' IDENTIFIED BY 'mysql';\nGRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168.1.132';\nFLUSH PRIVILEGES;\n```\n\n{% asset_img 2018-10-05-20-57-56.png [blog.ruanxinyu.cn] %}\n\n## 执行CHANGE MASTER TO语句\n\nMysql_01(`192.168.1.132`)中执行`mysql -u root -p`进入到mysql的控制台执行如下语句：\n\n```sql\nCHANGE MASTER TO\n  MASTER_HOST='192.168.1.133',\n  MASTER_USER='repl',\n  MASTER_PASSWORD='mysql',\n  MASTER_LOG_FILE='mysql-bin.000001',\n  MASTER_LOG_POS=0;\n```\n\nMysql_02(`192.168.1.133`)中执执行`mysql -u root -p`进入到mysql的控制台执行如下语句：\n\n```sql\nCHANGE MASTER TO\n  MASTER_HOST='192.168.1.132',\n  MASTER_USER='repl',\n  MASTER_PASSWORD='mysql',\n  MASTER_LOG_FILE='mysql-bin.000001',\n  MASTER_LOG_POS=0;\n```\n\n`MASTER_LOG_FILE`用来指定初始复制时的mysql1中的binlog文件， `MASTER_LOG_POS`用来指定初始复制时binlog文件的位置\n\n## 重启并查看同步状态\n\n1. `sudo systemctl restart mysql.service`重启mysql\n1. `mysql -u root -p`进入到mysql的控制台执行`start slave;`\n1. 通过`show slave status\\G;`查看启动状态，如果出现下面的内容则表示成功\n{% asset_img 2018-10-05-22-29-06.png [blog.ruanxinyu.cn] %}\n\n# KeepAlived的配置\n\nKeepalived的安装请参考：{% post_link Ubuntu下KeepAlived的安装与配置 %}。配置文件主要有如下几点变化：\n\n1. 两台机器的`state`都设置为`BACKUP`，同时`nopreempt`配置，可以防止切换到从库后，主keepalived恢复后自动切换回主库\n1. `virtual_ipaddress`改为`192.168.1.134`\n1. `vrrp_script`中的命令改为`netstat -na | grep LISTEN | grep 3306 || killall keepalived`\n\n**特别说明: **\n\n> 此处仅仅简单的通过检查`33060`端口来判断mysql是否正常。你可以可以根据自己的需求，将该脚本设计的更复杂一些。比如根据数据库的插入、删除等是否可用、主从线程是否开启等进行细分。提高检测的精准度。\n\nMysql_01(`192.168.1.132`)中KeepAlived的配置如下：\n\n```bash\nvrrp_script chk_service_ok {\n       script \"netstat -na | grep LISTEN | grep 3306 || killall keepalived\"\n       interval 2\n}\n\nvrrp_instance VI_1 {\n    interface enp0s3\n    state BACKUP    # 通过下面的priority来区分MASTER和BACKUP，也只有如此，底下的nopreempt才有效\n    virtual_router_id 51\n    priority 100\n    nopreempt   # 防止切换到从库后，主keepalived恢复后自动切换回主库\n\n    virtual_ipaddress {\n        192.168.1.134/24\n    }\n\n    track_script {\n       chk_service_ok\n    }\n}\n```\n\nMysql_02(`192.168.1.133`)中KeepAlived的配置如下：\n\n```bash\nvrrp_script chk_service_ok {\n       script \"netstat -na | grep LISTEN | grep 3306 || killall keepalived\"\n       interval 2\n}\n\nvrrp_instance VI_1 {\n    interface enp0s3\n    state BACKUP    # 通过下面的priority来区分MASTER和BACKUP，也只有如此，底下的nopreempt才有效\n    virtual_router_id 51\n    priority 80\n    nopreempt   # 防止切换到从库后，主keepalived恢复后自动切换回主库\n\n    virtual_ipaddress {\n        192.168.1.134/24\n    }\n\n    track_script {\n       chk_service_ok\n    }\n}\n```\n\n配置完毕之后执行`sudo systemctl restart keepalived`重新启动keepalived。\n\n# 功能验证\n\n## 正常情况下的验证\n\n首先，通过`ip a`可以看到VIP在Mysql_01(`192.168.1.132`)上：\n\n{% asset_img 2018-10-05-22-53-36.png [blog.ruanxinyu.cn] %}\n\n在Mysql_01(`192.168.1.132`)上执行`mysql -u root -p`进入到mysql的控制台， 创建数据库`create database database_01;`;\n在Mysql_02(`192.168.1.133`)上执行`mysql -u root -p`进入到mysql的控制台， 创建数据库`create database database_02;`;\n\n然后分别在两台机器上执行`show databases；`，可以看到两台mysql中都包含`database_01`和`database_02`，说明mysql的主主同步生效。\n\n{% asset_img 2018-10-05-22-59-11.png [blog.ruanxinyu.cn] %}\n\n## 异常恢复下的验证\n\nMysql_01(`192.168.1.132`)上执行`sudo systemctl stop mysql.service`停止mysql以模拟故障，此时可以看到VIP(`192.168.1.134`)已经漂移到mysql_02上，我们ssh连接VIP并往数据库中创建一个数据库`create database database_vip;`，可以看到是可以正常创建的，说明keepalived已经能保证mysql的高可用。\n\n{% asset_img 2018-10-05-23-09-29.png [blog.ruanxinyu.cn] %}\n\n此时我们重新启动Mysql_01(`192.168.1.132`)以模拟故障恢复，此时发现VIP还在mysql_02上，同时Mysql_01的数据库中也已经存在`database_vip`数据库。说明故障恢复后数据仍旧能够正常同步。\n\n{% asset_img 2018-10-05-23-12-07.png [blog.ruanxinyu.cn] %}\n\n# 常见操作说明\n\n## 彻底解除主从复制关系\n\n1. `stop slave`\n1. `reset slave`; 或直接删除`master.info`和`relay-log.info`这两个文件\n1. 修改`my.cnf`删除主从相关配置参数\n\n## 让slave不随MySQL自动启动\n\n修改`my.cnf`, 在`[mysqld]`中增加`skip-slave-start`选项\n\n## 数据备份的快速恢复\n\n执行如下命令备份，可以保留 `file` 和 `position` 的信息，在新搭建一个slave的时候，还原完数据库， `file` 和 `position` 的信息也随之更新，接着再`start slave` 就可以很迅速的完成增量同步：\n\n```sql\nmysqldump --master-data --single-transaction --user=username --password=password dbname> dumpfilename\n```\n\n## 如何限制复制哪些数据库\n\n1. 在执行`grant`授权的时候就限定数据库\n1. 在主服务器上限定`binlog_do_db = 数据库名`\n1. 主服务器上不限定数据库，在从服务器上限定`replicate-do-db = 数据库名`\n\n## 修改`log-bin`和`relay_log`后重启报错\n\n先执行`reset slave`，然后执行`start slave`即可。\n\n## 日志出现`[Warning] IP address 'xxxx' could not be resolved: Name or service not known`\n\nmysql默认会反向解析DNS，对于访问者Mysql不会判断是hosts还是ip都会进行dns反向解析，我们可以通过在`my.cnf`中添加`skip-name-resolve`禁用dns反查即可。\n\n## 主备同步报：`Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs`\n\n是因为数据目录下的`/var/lib/mysql/auto.cnf`文件是一样导致的，我们可以删除备机上的该文件，然后重启mysql","content":"<h1 id=\"Mysql复制模式及原理\"><a href=\"#Mysql复制模式及原理\" class=\"headerlink\" title=\"Mysql复制模式及原理\"></a>Mysql复制模式及原理</h1><p>Mysql内建的复制功能是构建大型，高性能应用程序的基础。Mysql将数据库的更改写入到二进制日志文件，而复制功能就是基于该日志完成的。Mysql的二进制日志格式也有三种：STATEMENT，ROW，MIXED。对应的是Mysql的三种复制模式.</p>\n<h2 id=\"复制原理\"><a href=\"#复制原理\" class=\"headerlink\" title=\"复制原理\"></a>复制原理</h2><p>master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；salve服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件，同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。过程如下：<br><img src=\"/posts/Ubuntu下Mysql-Keepalived双主热备高可用环境的搭建/2018-10-04-20-43-35.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>注意几点：</p>\n<ul>\n<li>master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。</li>\n<li>slave开启两个线程：IO线程和SQL线程。其中：IO线程负责读取master的binlog内容到中继日志relay log里；SQL线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和master数据保持一致了。</li>\n<li>Mysql复制至少需要两个Mysql的服务，当然Mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。</li>\n<li>Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）</li>\n<li>master和slave两节点间时间需同步</li>\n<li>主服务写入日志和从数据库回访日志都是串行的</li>\n</ul>\n<blockquote>\n<p>注意：所有对表的操作都需要在主服务器上操作，否则会造成数据冲突</p>\n</blockquote>\n<h2 id=\"基于SQL语句的复制-SBR\"><a href=\"#基于SQL语句的复制-SBR\" class=\"headerlink\" title=\"基于SQL语句的复制(SBR)\"></a>基于SQL语句的复制(SBR)</h2><p>基于SQL语句的复制(statement-based replication, SBR)的优点有：</p>\n<ol>\n<li>产生的binlog文件较小，比较节省空间</li>\n<li>binlog既可以用来复制，也可以用于实时的还原</li>\n<li>主从版本可以不一样，从服务器版本可以比主服务器版本高。</li>\n</ol>\n<p>缺点有：</p>\n<ol>\n<li>不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候。</li>\n<li>调用具有不确定因素的 UDF 时复制也可能出问题，比如<code>LOAD_FILE()</code>，<code>UUID()</code>，<code>USER()</code>，<code>FOUND_ROWS()</code>，<code>SYSDATE()</code></li>\n<li><code>INSERT ... SELECT</code> 会产生比 RBR 更多的行级锁</li>\n</ol>\n<h2 id=\"基于行的复制-RBR\"><a href=\"#基于行的复制-RBR\" class=\"headerlink\" title=\"基于行的复制(RBR)\"></a>基于行的复制(RBR)</h2><p>基于行的复制(row-based replication, RBR)的优点有：</p>\n<ol>\n<li>任何情况都可以被复制，这对复制来说是最安全可靠的</li>\n<li>多数情况下，从服务器上的表如果有主键的话，复制就会快了很多</li>\n<li>执行 INSERT，UPDATE，DELETE 语句时锁更少</li>\n<li>从服务器上采用多线程来执行复制成为可能</li>\n</ol>\n<p>缺点有：</p>\n<ol>\n<li>binlog 文件太大</li>\n<li>复杂的回滚时 binlog 中会包含大量的数据</li>\n<li>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题</li>\n<li>UDF 产生的大 BLOB 值会导致复制变慢</li>\n<li>无法从 binlog 中看到都复制了写什么语句，无法进行审计</li>\n</ol>\n<h2 id=\"混合模式复制-MBR\"><a href=\"#混合模式复制-MBR\" class=\"headerlink\" title=\"混合模式复制(MBR)\"></a>混合模式复制(MBR)</h2><p>混合模式复制(mixed-based replication, MBR)</p>\n<h2 id=\"解决的问题\"><a href=\"#解决的问题\" class=\"headerlink\" title=\"解决的问题\"></a>解决的问题</h2><p>Mysql支持主从复制模式和主主复制模式，能够解决以下的问题：</p>\n<ol>\n<li>数据分布 (Data distribution )</li>\n<li>负载平衡(load balancing)</li>\n<li>数据备份(Backups) ，保证数据安全</li>\n<li>高可用性和容错行(High availability and failover)</li>\n<li>实现读写分离，缓解数据库压力</li>\n</ol>\n<h1 id=\"基础环境说明\"><a href=\"#基础环境说明\" class=\"headerlink\" title=\"基础环境说明\"></a>基础环境说明</h1><p>本次教程搭建的架构图如下所示，通过Mysql的主从同步实现数据的同步，通过KeepAlived实现Mysql的故障时的自动切换，其中为<code>192.168.1.132</code>和<code>192.168.1.133</code>，VIP为<code>192.168.1.134</code>。<br><img src=\"/posts/Ubuntu下Mysql-Keepalived双主热备高可用环境的搭建/2018-10-05-19-29-21.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<ol>\n<li>使用的Ubuntu是<code>18.04.1</code>版本：<a href=\"/posts/VirtualBox安装Ubuntu教程/\" title=\"VirtualBox安装Ubuntu教程\">VirtualBox安装Ubuntu教程</a></li>\n<li>使用的Mysql是<code>8.0.12</code>版本：<a href=\"/posts/Ubuntu下Mysql的安装与验证/\" title=\"Ubuntu下Mysql的安装与验证\">Ubuntu下Mysql的安装与验证</a></li>\n<li>使用的KeepAlived是<code>2.0.7</code>版本：<a href=\"/posts/Ubuntu下KeepAlived的安装与配置/\" title=\"Ubuntu下KeepAlived的安装与配置\">Ubuntu下KeepAlived的安装与配置</a></li>\n</ol>\n<h1 id=\"Mysql的主从同步设置\"><a href=\"#Mysql的主从同步设置\" class=\"headerlink\" title=\"Mysql的主从同步设置\"></a>Mysql的主从同步设置</h1><ol>\n<li>用户配置文件位置：<code>/etc/mysql/my.cnf</code></li>\n<li>pid文件位置：<code>/var/run/mysqld/mysqld.pid</code></li>\n<li>socket文件位置：<code>/var/run/mysqld/mysqld.sock</code></li>\n<li>数据目录： <code>/var/lib/mysql</code></li>\n<li>错误日志文件： <code>/var/log/mysql/error.log</code></li>\n</ol>\n<h2 id=\"配置my-cnf文件\"><a href=\"#配置my-cnf文件\" class=\"headerlink\" title=\"配置my.cnf文件\"></a>配置my.cnf文件</h2><p>Mysql_01(<code>192.168.1.132</code>)编辑<code>sudo vim /etc/mysql/my.cnf</code>文件，添加如下内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\"><span class=\"built_in\">log</span>-bin=mysql-bin</span><br><span class=\"line\">relay_log=mysql-relay-bin</span><br><span class=\"line\">server-id=1</span><br><span class=\"line\">log_slave_updates=1</span><br></pre></td></tr></table></figure>\n<p>Mysql_02(<code>192.168.1.133</code>)编辑<code>sudo vim /etc/mysql/my.cnf</code>文件，添加如下内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\"><span class=\"built_in\">log</span>-bin=mysql-bin</span><br><span class=\"line\">relay_log=mysql-relay-bin</span><br><span class=\"line\">server-id=2</span><br><span class=\"line\">log_slave_updates=1</span><br></pre></td></tr></table></figure>\n<p>上述配置mysql的二进制日志的名称为<code>mysql-bin</code>，采用的是相对目录，具体绝对目录可以通过执行<code>show variables like &#39;log_%&#39;;</code>得到，如下所示</p>\n<img src=\"/posts/Ubuntu下Mysql-Keepalived双主热备高可用环境的搭建/2018-10-05-21-11-21.png\" title=\"[blog.ruanxinyu.cn]\">\n<p>如上述配置指定了<code>relay_log</code>的值，否则mysql会自动根据主机的hostname命名，如果修改hostname的话可能就会出问题，在error.log中也可以看到对应的警告：</p>\n<img src=\"/posts/Ubuntu下Mysql-Keepalived双主热备高可用环境的搭建/2018-10-05-21-31-11.png\" title=\"[blog.ruanxinyu.cn]\">\n<h2 id=\"创建复制用户\"><a href=\"#创建复制用户\" class=\"headerlink\" title=\"创建复制用户\"></a>创建复制用户</h2><p>Mysql_01(<code>192.168.1.132</code>)中执行<code>mysql -u root -p</code>进入到mysql的控制台执行如下语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> <span class=\"string\">'repl'</span>@<span class=\"string\">'192.168.1.133'</span> <span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">BY</span> <span class=\"string\">'mysql'</span>;</span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">REPLICATION</span> <span class=\"keyword\">SLAVE</span> <span class=\"keyword\">ON</span> *.* <span class=\"keyword\">TO</span> <span class=\"string\">'repl'</span>@<span class=\"string\">'192.168.1.133'</span>;</span><br><span class=\"line\"><span class=\"keyword\">FLUSH</span> <span class=\"keyword\">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure>\n<p>Mysql_02(<code>192.168.1.133</code>)中执行<code>mysql -u root -p</code>进入到mysql的控制台执行如下语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> <span class=\"string\">'repl'</span>@<span class=\"string\">'192.168.1.132'</span> <span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">BY</span> <span class=\"string\">'mysql'</span>;</span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">REPLICATION</span> <span class=\"keyword\">SLAVE</span> <span class=\"keyword\">ON</span> *.* <span class=\"keyword\">TO</span> <span class=\"string\">'repl'</span>@<span class=\"string\">'192.168.1.132'</span>;</span><br><span class=\"line\"><span class=\"keyword\">FLUSH</span> <span class=\"keyword\">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure>\n<img src=\"/posts/Ubuntu下Mysql-Keepalived双主热备高可用环境的搭建/2018-10-05-20-57-56.png\" title=\"[blog.ruanxinyu.cn]\">\n<h2 id=\"执行CHANGE-MASTER-TO语句\"><a href=\"#执行CHANGE-MASTER-TO语句\" class=\"headerlink\" title=\"执行CHANGE MASTER TO语句\"></a>执行CHANGE MASTER TO语句</h2><p>Mysql_01(<code>192.168.1.132</code>)中执行<code>mysql -u root -p</code>进入到mysql的控制台执行如下语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CHANGE</span> <span class=\"keyword\">MASTER</span> <span class=\"keyword\">TO</span></span><br><span class=\"line\">  MASTER_HOST=<span class=\"string\">'192.168.1.133'</span>,</span><br><span class=\"line\">  MASTER_USER=<span class=\"string\">'repl'</span>,</span><br><span class=\"line\">  MASTER_PASSWORD=<span class=\"string\">'mysql'</span>,</span><br><span class=\"line\">  MASTER_LOG_FILE=<span class=\"string\">'mysql-bin.000001'</span>,</span><br><span class=\"line\">  MASTER_LOG_POS=<span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<p>Mysql_02(<code>192.168.1.133</code>)中执执行<code>mysql -u root -p</code>进入到mysql的控制台执行如下语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CHANGE</span> <span class=\"keyword\">MASTER</span> <span class=\"keyword\">TO</span></span><br><span class=\"line\">  MASTER_HOST=<span class=\"string\">'192.168.1.132'</span>,</span><br><span class=\"line\">  MASTER_USER=<span class=\"string\">'repl'</span>,</span><br><span class=\"line\">  MASTER_PASSWORD=<span class=\"string\">'mysql'</span>,</span><br><span class=\"line\">  MASTER_LOG_FILE=<span class=\"string\">'mysql-bin.000001'</span>,</span><br><span class=\"line\">  MASTER_LOG_POS=<span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<p><code>MASTER_LOG_FILE</code>用来指定初始复制时的mysql1中的binlog文件， <code>MASTER_LOG_POS</code>用来指定初始复制时binlog文件的位置</p>\n<h2 id=\"重启并查看同步状态\"><a href=\"#重启并查看同步状态\" class=\"headerlink\" title=\"重启并查看同步状态\"></a>重启并查看同步状态</h2><ol>\n<li><code>sudo systemctl restart mysql.service</code>重启mysql</li>\n<li><code>mysql -u root -p</code>进入到mysql的控制台执行<code>start slave;</code></li>\n<li>通过<code>show slave status\\G;</code>查看启动状态，如果出现下面的内容则表示成功<img src=\"/posts/Ubuntu下Mysql-Keepalived双主热备高可用环境的搭建/2018-10-05-22-29-06.png\" title=\"[blog.ruanxinyu.cn]\">\n</li>\n</ol>\n<h1 id=\"KeepAlived的配置\"><a href=\"#KeepAlived的配置\" class=\"headerlink\" title=\"KeepAlived的配置\"></a>KeepAlived的配置</h1><p>Keepalived的安装请参考：<a href=\"/posts/Ubuntu下KeepAlived的安装与配置/\" title=\"Ubuntu下KeepAlived的安装与配置\">Ubuntu下KeepAlived的安装与配置</a>。配置文件主要有如下几点变化：</p>\n<ol>\n<li>两台机器的<code>state</code>都设置为<code>BACKUP</code>，同时<code>nopreempt</code>配置，可以防止切换到从库后，主keepalived恢复后自动切换回主库</li>\n<li><code>virtual_ipaddress</code>改为<code>192.168.1.134</code></li>\n<li><code>vrrp_script</code>中的命令改为<code>netstat -na | grep LISTEN | grep 3306 || killall keepalived</code></li>\n</ol>\n<p><strong>特别说明: </strong></p>\n<blockquote>\n<p>此处仅仅简单的通过检查<code>33060</code>端口来判断mysql是否正常。你可以可以根据自己的需求，将该脚本设计的更复杂一些。比如根据数据库的插入、删除等是否可用、主从线程是否开启等进行细分。提高检测的精准度。</p>\n</blockquote>\n<p>Mysql_01(<code>192.168.1.132</code>)中KeepAlived的配置如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vrrp_script chk_service_ok &#123;</span><br><span class=\"line\">       script <span class=\"string\">\"netstat -na | grep LISTEN | grep 3306 || killall keepalived\"</span></span><br><span class=\"line\">       interval 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">vrrp_instance VI_1 &#123;</span><br><span class=\"line\">    interface enp0s3</span><br><span class=\"line\">    state BACKUP    <span class=\"comment\"># 通过下面的priority来区分MASTER和BACKUP，也只有如此，底下的nopreempt才有效</span></span><br><span class=\"line\">    virtual_router_id 51</span><br><span class=\"line\">    priority 100</span><br><span class=\"line\">    nopreempt   <span class=\"comment\"># 防止切换到从库后，主keepalived恢复后自动切换回主库</span></span><br><span class=\"line\"></span><br><span class=\"line\">    virtual_ipaddress &#123;</span><br><span class=\"line\">        192.168.1.134/24</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    track_script &#123;</span><br><span class=\"line\">       chk_service_ok</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Mysql_02(<code>192.168.1.133</code>)中KeepAlived的配置如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vrrp_script chk_service_ok &#123;</span><br><span class=\"line\">       script <span class=\"string\">\"netstat -na | grep LISTEN | grep 3306 || killall keepalived\"</span></span><br><span class=\"line\">       interval 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">vrrp_instance VI_1 &#123;</span><br><span class=\"line\">    interface enp0s3</span><br><span class=\"line\">    state BACKUP    <span class=\"comment\"># 通过下面的priority来区分MASTER和BACKUP，也只有如此，底下的nopreempt才有效</span></span><br><span class=\"line\">    virtual_router_id 51</span><br><span class=\"line\">    priority 80</span><br><span class=\"line\">    nopreempt   <span class=\"comment\"># 防止切换到从库后，主keepalived恢复后自动切换回主库</span></span><br><span class=\"line\"></span><br><span class=\"line\">    virtual_ipaddress &#123;</span><br><span class=\"line\">        192.168.1.134/24</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    track_script &#123;</span><br><span class=\"line\">       chk_service_ok</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置完毕之后执行<code>sudo systemctl restart keepalived</code>重新启动keepalived。</p>\n<h1 id=\"功能验证\"><a href=\"#功能验证\" class=\"headerlink\" title=\"功能验证\"></a>功能验证</h1><h2 id=\"正常情况下的验证\"><a href=\"#正常情况下的验证\" class=\"headerlink\" title=\"正常情况下的验证\"></a>正常情况下的验证</h2><p>首先，通过<code>ip a</code>可以看到VIP在Mysql_01(<code>192.168.1.132</code>)上：</p>\n<img src=\"/posts/Ubuntu下Mysql-Keepalived双主热备高可用环境的搭建/2018-10-05-22-53-36.png\" title=\"[blog.ruanxinyu.cn]\">\n<p>在Mysql_01(<code>192.168.1.132</code>)上执行<code>mysql -u root -p</code>进入到mysql的控制台， 创建数据库<code>create database database_01;</code>;<br>在Mysql_02(<code>192.168.1.133</code>)上执行<code>mysql -u root -p</code>进入到mysql的控制台， 创建数据库<code>create database database_02;</code>;</p>\n<p>然后分别在两台机器上执行<code>show databases；</code>，可以看到两台mysql中都包含<code>database_01</code>和<code>database_02</code>，说明mysql的主主同步生效。</p>\n<img src=\"/posts/Ubuntu下Mysql-Keepalived双主热备高可用环境的搭建/2018-10-05-22-59-11.png\" title=\"[blog.ruanxinyu.cn]\">\n<h2 id=\"异常恢复下的验证\"><a href=\"#异常恢复下的验证\" class=\"headerlink\" title=\"异常恢复下的验证\"></a>异常恢复下的验证</h2><p>Mysql_01(<code>192.168.1.132</code>)上执行<code>sudo systemctl stop mysql.service</code>停止mysql以模拟故障，此时可以看到VIP(<code>192.168.1.134</code>)已经漂移到mysql_02上，我们ssh连接VIP并往数据库中创建一个数据库<code>create database database_vip;</code>，可以看到是可以正常创建的，说明keepalived已经能保证mysql的高可用。</p>\n<img src=\"/posts/Ubuntu下Mysql-Keepalived双主热备高可用环境的搭建/2018-10-05-23-09-29.png\" title=\"[blog.ruanxinyu.cn]\">\n<p>此时我们重新启动Mysql_01(<code>192.168.1.132</code>)以模拟故障恢复，此时发现VIP还在mysql_02上，同时Mysql_01的数据库中也已经存在<code>database_vip</code>数据库。说明故障恢复后数据仍旧能够正常同步。</p>\n<img src=\"/posts/Ubuntu下Mysql-Keepalived双主热备高可用环境的搭建/2018-10-05-23-12-07.png\" title=\"[blog.ruanxinyu.cn]\">\n<h1 id=\"常见操作说明\"><a href=\"#常见操作说明\" class=\"headerlink\" title=\"常见操作说明\"></a>常见操作说明</h1><h2 id=\"彻底解除主从复制关系\"><a href=\"#彻底解除主从复制关系\" class=\"headerlink\" title=\"彻底解除主从复制关系\"></a>彻底解除主从复制关系</h2><ol>\n<li><code>stop slave</code></li>\n<li><code>reset slave</code>; 或直接删除<code>master.info</code>和<code>relay-log.info</code>这两个文件</li>\n<li>修改<code>my.cnf</code>删除主从相关配置参数</li>\n</ol>\n<h2 id=\"让slave不随MySQL自动启动\"><a href=\"#让slave不随MySQL自动启动\" class=\"headerlink\" title=\"让slave不随MySQL自动启动\"></a>让slave不随MySQL自动启动</h2><p>修改<code>my.cnf</code>, 在<code>[mysqld]</code>中增加<code>skip-slave-start</code>选项</p>\n<h2 id=\"数据备份的快速恢复\"><a href=\"#数据备份的快速恢复\" class=\"headerlink\" title=\"数据备份的快速恢复\"></a>数据备份的快速恢复</h2><p>执行如下命令备份，可以保留 <code>file</code> 和 <code>position</code> 的信息，在新搭建一个slave的时候，还原完数据库， <code>file</code> 和 <code>position</code> 的信息也随之更新，接着再<code>start slave</code> 就可以很迅速的完成增量同步：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqldump <span class=\"comment\">--master-data --single-transaction --user=username --password=password dbname&gt; dumpfilename</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"如何限制复制哪些数据库\"><a href=\"#如何限制复制哪些数据库\" class=\"headerlink\" title=\"如何限制复制哪些数据库\"></a>如何限制复制哪些数据库</h2><ol>\n<li>在执行<code>grant</code>授权的时候就限定数据库</li>\n<li>在主服务器上限定<code>binlog_do_db = 数据库名</code></li>\n<li>主服务器上不限定数据库，在从服务器上限定<code>replicate-do-db = 数据库名</code></li>\n</ol>\n<h2 id=\"修改log-bin和relay-log后重启报错\"><a href=\"#修改log-bin和relay-log后重启报错\" class=\"headerlink\" title=\"修改log-bin和relay_log后重启报错\"></a>修改<code>log-bin</code>和<code>relay_log</code>后重启报错</h2><p>先执行<code>reset slave</code>，然后执行<code>start slave</code>即可。</p>\n<h2 id=\"日志出现-Warning-IP-address-39-xxxx-39-could-not-be-resolved-Name-or-service-not-known\"><a href=\"#日志出现-Warning-IP-address-39-xxxx-39-could-not-be-resolved-Name-or-service-not-known\" class=\"headerlink\" title=\"日志出现[Warning] IP address &#39;xxxx&#39; could not be resolved: Name or service not known\"></a>日志出现<code>[Warning] IP address &#39;xxxx&#39; could not be resolved: Name or service not known</code></h2><p>mysql默认会反向解析DNS，对于访问者Mysql不会判断是hosts还是ip都会进行dns反向解析，我们可以通过在<code>my.cnf</code>中添加<code>skip-name-resolve</code>禁用dns反查即可。</p>\n<h2 id=\"主备同步报：Fatal-error-The-slave-I-O-thread-stops-because-master-and-slave-have-equal-MySQL-server-UUIDs\"><a href=\"#主备同步报：Fatal-error-The-slave-I-O-thread-stops-because-master-and-slave-have-equal-MySQL-server-UUIDs\" class=\"headerlink\" title=\"主备同步报：Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs\"></a>主备同步报：<code>Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs</code></h2><p>是因为数据目录下的<code>/var/lib/mysql/auto.cnf</code>文件是一样导致的，我们可以删除备机上的该文件，然后重启mysql</p>\n","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/categories/环境搭建/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/tags/环境搭建/"}]},{"title":"TypeScript学习记录-1","slug":"TypeScript学习记录-1","date":"un44fin44","updated":"un44fin44","comments":true,"path":"posts/TypeScript学习记录-1/","link":"","permalink":"http://ruanxinyu.github.io/posts/TypeScript学习记录-1/","excerpt":"","keywords":"","text":"安装和编译使用npm进行安装： 1npm install -g typescript 使用tsc可以将ts文件编译为js文件： 1tsc greeter.ts 变量类型官方文档地址为：http://www.typescriptlang.org/docs/handbook/basic-types.html。基本的数据类型及使用如下所示： 1234567891011121314151617181920212223242526// booleanlet isDone: boolean = false;// numberlet decimal: number = 6;let hex: number = 0xf00d;let binary: number = 0b1010;let octal: number = 0o744;// 字符串即字符串中的变量引用let fullName: string = `Bob Bobbington`;let age: number = 37;let sentence: string = `Hello, my name is $&#123; fullName &#125;.I'll be $&#123; age + 1 &#125; years old next month.`;// 数组let list: number[] = [1, 2, 3];let list: Array&lt;number&gt; = [1, 2, 3];// 元组let x: [string, number] = [\"hello\", 10];// 枚举enum Color &#123;Red = 1, Green, Blue&#125;let c: Color = Color.Green; 还有其他的类型包括：any, void, null, undifined, never, object。 变量声明变量的声明有3个关键字var, let, const。 定义要尽可能使用let，而不是var const是针对不可以重新复制的变量 object的声明与json的定义方式是一样的 默认值123function keepWholeObject(wholeObject: &#123; a: string, b?: number &#125;) &#123; let &#123; a, b = 1001 &#125; = wholeObject;&#125; 函数声明1234type C = &#123; a: string, b?: number &#125;function f(&#123; a, b &#125;: C): void &#123; // ...&#125; 123456function f(&#123; a, b = 0 &#125; = &#123; a: \"\" &#125;): void &#123; // ...&#125;f(&#123; a: \"yes\" &#125;); // ok, default b = 0f(); // ok, default to &#123; a: \"\" &#125;, which then defaults b = 0f(&#123;&#125;); // error, 'a' is required if you supply an argument Spread12345678// 数组let first = [1, 2];let second = [3, 4];let bothPlus = [0, ...first, ...second, 5];// 对象let defaults = &#123; food: \"spicy\", price: \"$$\", ambiance: \"noisy\" &#125;;let search = &#123; ...defaults, food: \"rich\" &#125;; 接口通过interface定义接口，只要校验传进来的参数是否包含接口中的变量，则认为传进来的参数与接口是兼容的。可以通过?来指定是否是函数的可选参数，通过readonly来指定参数是只读的。 1234567891011121314151617181920interface SquareConfig &#123; color?: string; width?: number; readonly height?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; let newSquare = &#123;color: \"white\", area: 100&#125;; if (config.clor) &#123; // Error: Property 'clor' does not exist on type 'SquareConfig' newSquare.color = config.clor; &#125; if (config.width) &#123; newSquare.area = config.width * config.width; &#125; return newSquare;&#125;let mySquare = createSquare(&#123;color: \"black\"&#125;);Readonly properties 接口中也是可以定义函数的。 接口可以通过extends来继承 类 通过class定义类，通过implements实现接口 通过constructor来定义构造函数 支持getter/setter方法 支持static关键字 支持abstract关键字 函数多参数支持 12345function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + \" \" + restOfName.join(\" \");&#125;let employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\"); this和箭头函数Arrow functions capture the this where the function is created rather than where it is invoked. 所以在定义函数的时候尽量使用箭头函数，如果使用this的时候提示是any类型，可以显性的传入this变量 12345678910111213141516171819202122232425262728interface Card &#123; suit: string; card: number;&#125;interface Deck &#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), // 显性的传入this createCardPicker: function(this: Deck) &#123; // 是哟弄个箭头函数 return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); 泛型函数 12345function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity; // 类 123456class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;(); 类继承 12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); // Now we know it has a .length property, so no more error return arg;&#125;","raw":"---\ntitle: TypeScript学习记录-1\ntags: 前端 学习记录\ncategories: 学习记录\ndate: 2018-10-04 10:08:09\n---\n\n\n# 安装和编译\n\n使用npm进行安装：\n\n```bash\nnpm install -g typescript\n```\n\n使用`tsc`可以将ts文件编译为js文件：\n\n```bash\ntsc greeter.ts\n```\n\n# 变量类型\n\n官方文档地址为：[http://www.typescriptlang.org/docs/handbook/basic-types.html](http://www.typescriptlang.org/docs/handbook/basic-types.html)。基本的数据类型及使用如下所示：\n\n```ts\n// boolean\nlet isDone: boolean = false;\n\n// number\nlet decimal: number = 6;\nlet hex: number = 0xf00d;\nlet binary: number = 0b1010;\nlet octal: number = 0o744;\n\n// 字符串即字符串中的变量引用\nlet fullName: string = `Bob Bobbington`;\nlet age: number = 37;\nlet sentence: string = `Hello, my name is ${ fullName }.\n\nI'll be ${ age + 1 } years old next month.`;\n\n// 数组\nlet list: number[] = [1, 2, 3];\nlet list: Array<number> = [1, 2, 3];\n\n// 元组\nlet x: [string, number] = [\"hello\", 10];\n\n// 枚举\nenum Color {Red = 1, Green, Blue}\nlet c: Color = Color.Green;\n```\n\n还有其他的类型包括：`any`, `void`, `null`, `undifined`, `never`, `object`。\n\n# 变量声明\n\n变量的声明有3个关键字`var`, `let`, `const`。\n\n+ 定义要尽可能使用`let`，而不是`var`\n+ `const`是针对不可以重新复制的变量\n+ `object`的声明与json的定义方式是一样的\n\n## 默认值\n\n```ts\nfunction keepWholeObject(wholeObject: { a: string, b?: number }) {\n    let { a, b = 1001 } = wholeObject;\n}\n```\n\n## 函数声明\n\n```ts\ntype C = { a: string, b?: number }\nfunction f({ a, b }: C): void {\n    // ...\n}\n```\n\n```ts\nfunction f({ a, b = 0 } = { a: \"\" }): void {\n    // ...\n}\nf({ a: \"yes\" }); // ok, default b = 0\nf(); // ok, default to { a: \"\" }, which then defaults b = 0\nf({}); // error, 'a' is required if you supply an argument\n```\n\n## Spread\n\n```ts\n// 数组\nlet first = [1, 2];\nlet second = [3, 4];\nlet bothPlus = [0, ...first, ...second, 5];\n\n// 对象\nlet defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };\nlet search = { ...defaults, food: \"rich\" };\n```\n\n# 接口\n\n通过`interface`定义接口，只要校验传进来的参数是否包含接口中的变量，则认为传进来的参数与接口是兼容的。可以通过`?`来指定是否是函数的可选参数，通过`readonly`来指定参数是只读的。\n\n```ts\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n    readonly height?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n    let newSquare = {color: \"white\", area: 100};\n    if (config.clor) {\n        // Error: Property 'clor' does not exist on type 'SquareConfig'\n        newSquare.color = config.clor;\n    }\n    if (config.width) {\n        newSquare.area = config.width * config.width;\n    }\n    return newSquare;\n}\n\nlet mySquare = createSquare({color: \"black\"});\nReadonly properties\n```\n\n接口中也是可以定义函数的。\n\n接口可以通过`extends`来继承\n\n# 类\n\n+ 通过`class`定义类，通过`implements`实现接口\n+ 通过`constructor`来定义构造函数\n+ 支持getter/setter方法\n+ 支持`static`关键字\n+ 支持`abstract`关键字\n\n# 函数\n\n多参数支持\n\n```ts\nfunction buildName(firstName: string, ...restOfName: string[]) {\n    return firstName + \" \" + restOfName.join(\" \");\n}\n\nlet employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\");\n```\n\n## this和箭头函数\n\n**Arrow functions capture the this where the function is created rather than where it is invoked.** 所以在定义函数的时候尽量使用箭头函数，如果使用this的时候提示是`any`类型，可以显性的传入this变量\n\n```ts\ninterface Card {\n    suit: string;\n    card: number;\n}\ninterface Deck {\n    suits: string[];\n    cards: number[];\n    createCardPicker(this: Deck): () => Card;\n}\nlet deck: Deck = {\n    suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n    cards: Array(52),\n    // 显性的传入this\n    createCardPicker: function(this: Deck) {\n        // 是哟弄个箭头函数\n        return () => {\n            let pickedCard = Math.floor(Math.random() * 52);\n            let pickedSuit = Math.floor(pickedCard / 13);\n\n            return {suit: this.suits[pickedSuit], card: pickedCard % 13};\n        }\n    }\n}\n\nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\n\nalert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit);\n```\n\n# 泛型\n\n函数\n\n```ts\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: {<T>(arg: T): T} = identity;\n```\n\n// 类\n\n```ts\nclass GenericNumber<T> {\n    zeroValue: T;\n    add: (x: T, y: T) => T;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\n```\n\n类继承\n\n```ts\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n    console.log(arg.length);  // Now we know it has a .length property, so no more error\n    return arg;\n}\n```","content":"<h1 id=\"安装和编译\"><a href=\"#安装和编译\" class=\"headerlink\" title=\"安装和编译\"></a>安装和编译</h1><p>使用npm进行安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g typescript</span><br></pre></td></tr></table></figure>\n<p>使用<code>tsc</code>可以将ts文件编译为js文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc greeter.ts</span><br></pre></td></tr></table></figure>\n<h1 id=\"变量类型\"><a href=\"#变量类型\" class=\"headerlink\" title=\"变量类型\"></a>变量类型</h1><p>官方文档地址为：<a href=\"http://www.typescriptlang.org/docs/handbook/basic-types.html\" target=\"_blank\" rel=\"noopener\">http://www.typescriptlang.org/docs/handbook/basic-types.html</a>。基本的数据类型及使用如下所示：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// boolean</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isDone: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> decimal: <span class=\"built_in\">number</span> = <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> hex: <span class=\"built_in\">number</span> = <span class=\"number\">0xf00d</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> binary: <span class=\"built_in\">number</span> = <span class=\"number\">0b1010</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> octal: <span class=\"built_in\">number</span> = <span class=\"number\">0o744</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串即字符串中的变量引用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fullName: <span class=\"built_in\">string</span> = <span class=\"string\">`Bob Bobbington`</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> age: <span class=\"built_in\">number</span> = <span class=\"number\">37</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> sentence: <span class=\"built_in\">string</span> = <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123; fullName &#125;</span>.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">I'll be <span class=\"subst\">$&#123; age + 1 &#125;</span> years old next month.`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数组</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 元组</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>] = [<span class=\"string\">\"hello\"</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 枚举</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n<p>还有其他的类型包括：<code>any</code>, <code>void</code>, <code>null</code>, <code>undifined</code>, <code>never</code>, <code>object</code>。</p>\n<h1 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h1><p>变量的声明有3个关键字<code>var</code>, <code>let</code>, <code>const</code>。</p>\n<ul>\n<li>定义要尽可能使用<code>let</code>，而不是<code>var</code></li>\n<li><code>const</code>是针对不可以重新复制的变量</li>\n<li><code>object</code>的声明与json的定义方式是一样的</li>\n</ul>\n<h2 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">keepWholeObject</span>(<span class=\"params\">wholeObject: &#123; a: <span class=\"built_in\">string</span>, b?: <span class=\"built_in\">number</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123; a, b = <span class=\"number\">1001</span> &#125; = wholeObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> C = &#123; a: <span class=\"built_in\">string</span>, b?: <span class=\"built_in\">number</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b &#125;: C</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(&#123; a, b = 0 &#125; = &#123; a: \"\" &#125;): void &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(&#123; a: <span class=\"string\">\"yes\"</span> &#125;); <span class=\"comment\">// ok, default b = 0</span></span><br><span class=\"line\">f(); <span class=\"comment\">// ok, default to &#123; a: \"\" &#125;, which then defaults b = 0</span></span><br><span class=\"line\">f(&#123;&#125;); <span class=\"comment\">// error, 'a' is required if you supply an argument</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Spread\"><a href=\"#Spread\" class=\"headerlink\" title=\"Spread\"></a>Spread</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> first = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> second = [<span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> bothPlus = [<span class=\"number\">0</span>, ...first, ...second, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; food: <span class=\"string\">\"spicy\"</span>, price: <span class=\"string\">\"$$\"</span>, ambiance: <span class=\"string\">\"noisy\"</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; ...defaults, food: <span class=\"string\">\"rich\"</span> &#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><p>通过<code>interface</code>定义接口，只要校验传进来的参数是否包含接口中的变量，则认为传进来的参数与接口是兼容的。可以通过<code>?</code>来指定是否是函数的可选参数，通过<code>readonly</code>来指定参数是只读的。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">    color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    readonly height?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span>(<span class=\"params\">config: SquareConfig</span>): </span>&#123; color: <span class=\"built_in\">string</span>; area: <span class=\"built_in\">number</span> &#125; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">\"white\"</span>, area: <span class=\"number\">100</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (config.clor) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Error: Property 'clor' does not exist on type 'SquareConfig'</span></span><br><span class=\"line\">        newSquare.color = config.clor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">        newSquare.area = config.width * config.width;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newSquare;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123;color: <span class=\"string\">\"black\"</span>&#125;);</span><br><span class=\"line\">Readonly properties</span><br></pre></td></tr></table></figure>\n<p>接口中也是可以定义函数的。</p>\n<p>接口可以通过<code>extends</code>来继承</p>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><ul>\n<li>通过<code>class</code>定义类，通过<code>implements</code>实现接口</li>\n<li>通过<code>constructor</code>来定义构造函数</li>\n<li>支持getter/setter方法</li>\n<li>支持<code>static</code>关键字</li>\n<li>支持<code>abstract</code>关键字</li>\n</ul>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><p>多参数支持</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, ...restOfName: <span class=\"built_in\">string</span>[]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName + <span class=\"string\">\" \"</span> + restOfName.join(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employeeName = buildName(<span class=\"string\">\"Joseph\"</span>, <span class=\"string\">\"Samuel\"</span>, <span class=\"string\">\"Lucas\"</span>, <span class=\"string\">\"MacKinzie\"</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"this和箭头函数\"><a href=\"#this和箭头函数\" class=\"headerlink\" title=\"this和箭头函数\"></a>this和箭头函数</h2><p><strong>Arrow functions capture the this where the function is created rather than where it is invoked.</strong> 所以在定义函数的时候尽量使用箭头函数，如果使用this的时候提示是<code>any</code>类型，可以显性的传入this变量</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Card &#123;</span><br><span class=\"line\">    suit: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    card: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Deck &#123;</span><br><span class=\"line\">    suits: <span class=\"built_in\">string</span>[];</span><br><span class=\"line\">    cards: <span class=\"built_in\">number</span>[];</span><br><span class=\"line\">    createCardPicker(<span class=\"keyword\">this</span>: Deck): <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> Card;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> deck: Deck = &#123;</span><br><span class=\"line\">    suits: [<span class=\"string\">\"hearts\"</span>, <span class=\"string\">\"spades\"</span>, <span class=\"string\">\"clubs\"</span>, <span class=\"string\">\"diamonds\"</span>],</span><br><span class=\"line\">    cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">    <span class=\"comment\">// 显性的传入this</span></span><br><span class=\"line\">    createCardPicker: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"><span class=\"keyword\">this</span>: Deck</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 是哟弄个箭头函数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;suit: <span class=\"keyword\">this</span>.suits[pickedSuit], card: pickedCard % <span class=\"number\">13</span>&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker();</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker();</span><br><span class=\"line\"></span><br><span class=\"line\">alert(<span class=\"string\">\"card: \"</span> + pickedCard.card + <span class=\"string\">\" of \"</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure>\n<h1 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h1><p>函数</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity;</span><br></pre></td></tr></table></figure>\n<p>// 类</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> GenericNumber&lt;T&gt; &#123;</span><br><span class=\"line\">    zeroValue: T;</span><br><span class=\"line\">    add: <span class=\"function\">(<span class=\"params\">x: T, y: T</span>) =&gt;</span> T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myGenericNumber = <span class=\"keyword\">new</span> GenericNumber&lt;<span class=\"built_in\">number</span>&gt;();</span><br></pre></td></tr></table></figure>\n<p>类继承</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Lengthwise &#123;</span><br><span class=\"line\">    length: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">Lengthwise</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arg.length);  <span class=\"comment\">// Now we know it has a .length property, so no more error</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://ruanxinyu.github.io/categories/学习记录/"}],"tags":[{"name":"前端 学习记录","slug":"前端-学习记录","permalink":"http://ruanxinyu.github.io/tags/前端-学习记录/"}]},{"title":"Jenkins的安装与使用","slug":"Jenkins的安装与使用","date":"un33fin33","updated":"un33fin33","comments":true,"path":"posts/Jenkins的安装与使用/","link":"","permalink":"http://ruanxinyu.github.io/posts/Jenkins的安装与使用/","excerpt":"","keywords":"","text":"Jenkins的介绍官方地址为：https://jenkins.io/。Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 Jenkins的安装 在启动之前需要先安装java环境，具体可以参考教程：JDK安装教程。该教程使用的Ubuntu版本是18.04.1版本，Ubuntu的安装教程参考VirtualBox安装Ubuntu教程。 具体的安装文档可以参考：https://jenkins.io/doc/book/installing/。 文档中直接通过sudo apt-get install jenkins的方式安装会报错，不兼容最新版本的Ubuntu系统，因此下文采用直接下载软件包安装的过程。 首先下载http://mirrors.jenkins.io/war-stable/latest/jenkins.war软件包，然后执行java -jar jenkins.war即可启动Jenkins。默认情况下Jenkins会监听8080端口，我们可以通过如下命令修改端口号java -jar jenkins.war --httpPort=9090。 访问http://192.168.1.108:8080/，可以看到如下的页面，提示输入密码，可以从界面中找到密码所在的文件路径，或者从启动日志中也可以看到。 修改Jenkins的主目录从Jenkins的启动日志中可以看出Jenkins默认的主目录为$user.home/.jenkins，我们在此将其主目录更改至/usr/local/jenkins/.jenkins，只需要导出环境JENKINS_HOME环境变量exprot JENKINS_HOME=/usr/local/jenkins/.jenkins，然后启动Jenkins即可。 系统服务与开机启动","raw":"---\ntitle: Jenkins的安装与使用\ntags: 环境搭建\ncategories: 环境搭建\ndate: 2018-10-03 17:01:53\n---\n\n# Jenkins的介绍\n\n官方地址为：[https://jenkins.io/](https://jenkins.io/)。Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。\n\n# Jenkins的安装\n\n> 在启动之前需要先安装java环境，具体可以参考教程：{% post_link JDK安装教程 %}。该教程使用的Ubuntu版本是18.04.1版本，Ubuntu的安装教程参考{% post_link VirtualBox安装Ubuntu教程 %}。\n\n具体的安装文档可以参考：[https://jenkins.io/doc/book/installing/](https://jenkins.io/doc/book/installing/)。\n\n> 文档中直接通过`sudo apt-get install jenkins`的方式安装会报错，不兼容最新版本的Ubuntu系统，因此下文采用直接下载软件包安装的过程。\n\n+ 首先下载`http://mirrors.jenkins.io/war-stable/latest/jenkins.war`软件包，然后执行`java -jar jenkins.war`即可启动Jenkins。默认情况下Jenkins会监听`8080`端口，我们可以通过如下命令修改端口号`java -jar jenkins.war --httpPort=9090`。\n\n+ 访问`http://192.168.1.108:8080/`，可以看到如下的页面，提示输入密码，可以从界面中找到密码所在的文件路径，或者从启动日志中也可以看到。\n{% asset_img 2018-10-03-17-27-12.png [blog.ruanxinyu.cn] %}\n\n# 修改Jenkins的主目录\n\n从Jenkins的启动日志中可以看出Jenkins默认的主目录为`$user.home/.jenkins`，我们在此将其主目录更改至`/usr/local/jenkins/.jenkins`，只需要导出环境`JENKINS_HOME`环境变量`exprot JENKINS_HOME=/usr/local/jenkins/.jenkins`，然后启动Jenkins即可。\n\n# 系统服务与开机启动\n\n\n\n\n","content":"<h1 id=\"Jenkins的介绍\"><a href=\"#Jenkins的介绍\" class=\"headerlink\" title=\"Jenkins的介绍\"></a>Jenkins的介绍</h1><p>官方地址为：<a href=\"https://jenkins.io/\" target=\"_blank\" rel=\"noopener\">https://jenkins.io/</a>。Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>\n<h1 id=\"Jenkins的安装\"><a href=\"#Jenkins的安装\" class=\"headerlink\" title=\"Jenkins的安装\"></a>Jenkins的安装</h1><blockquote>\n<p>在启动之前需要先安装java环境，具体可以参考教程：<a href=\"/posts/JDK安装教程/\" title=\"JDK安装教程\">JDK安装教程</a>。该教程使用的Ubuntu版本是18.04.1版本，Ubuntu的安装教程参考<a href=\"/posts/VirtualBox安装Ubuntu教程/\" title=\"VirtualBox安装Ubuntu教程\">VirtualBox安装Ubuntu教程</a>。</p>\n</blockquote>\n<p>具体的安装文档可以参考：<a href=\"https://jenkins.io/doc/book/installing/\" target=\"_blank\" rel=\"noopener\">https://jenkins.io/doc/book/installing/</a>。</p>\n<blockquote>\n<p>文档中直接通过<code>sudo apt-get install jenkins</code>的方式安装会报错，不兼容最新版本的Ubuntu系统，因此下文采用直接下载软件包安装的过程。</p>\n</blockquote>\n<ul>\n<li><p>首先下载<code>http://mirrors.jenkins.io/war-stable/latest/jenkins.war</code>软件包，然后执行<code>java -jar jenkins.war</code>即可启动Jenkins。默认情况下Jenkins会监听<code>8080</code>端口，我们可以通过如下命令修改端口号<code>java -jar jenkins.war --httpPort=9090</code>。</p>\n</li>\n<li><p>访问<code>http://192.168.1.108:8080/</code>，可以看到如下的页面，提示输入密码，可以从界面中找到密码所在的文件路径，或者从启动日志中也可以看到。</p>\n<img src=\"/posts/Jenkins的安装与使用/2018-10-03-17-27-12.png\" title=\"[blog.ruanxinyu.cn]\">\n</li>\n</ul>\n<h1 id=\"修改Jenkins的主目录\"><a href=\"#修改Jenkins的主目录\" class=\"headerlink\" title=\"修改Jenkins的主目录\"></a>修改Jenkins的主目录</h1><p>从Jenkins的启动日志中可以看出Jenkins默认的主目录为<code>$user.home/.jenkins</code>，我们在此将其主目录更改至<code>/usr/local/jenkins/.jenkins</code>，只需要导出环境<code>JENKINS_HOME</code>环境变量<code>exprot JENKINS_HOME=/usr/local/jenkins/.jenkins</code>，然后启动Jenkins即可。</p>\n<h1 id=\"系统服务与开机启动\"><a href=\"#系统服务与开机启动\" class=\"headerlink\" title=\"系统服务与开机启动\"></a>系统服务与开机启动</h1>","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/categories/环境搭建/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/tags/环境搭建/"}]},{"title":"SonatypeNexus的安装与使用","slug":"SonatypeNexus的安装与使用","date":"un22fin22","updated":"un22fin22","comments":true,"path":"posts/SonatypeNexus的安装与使用/","link":"","permalink":"http://ruanxinyu.github.io/posts/SonatypeNexus的安装与使用/","excerpt":"","keywords":"","text":"SonatypeNexus的介绍Sonatype Nexus可以用来作为Maven/Java, npm, NuGet, RubyGems, Docker, P2, OBR, APT and YUM等的代理仓和私有仓库，同时还与Eclipse, IntelliJ, Hudson, Jenkins, Puppet, Chef, Docker等工具有很好的集成。那么我们在开发中可以用SonatypeNexus做什么呢？ 代理并缓存Maven/npm/docker等中央仓，提升下载速度 作为Maven/npm/docker等的私有仓库，上传私有组件 作为编译构建仓库，用于分享或者部署到环境 SonatypeNexus的安装 在启动之前需要先安装java环境，具体可以参考教程：JDK安装教程。另外Nexus对内存要求比较大，请至少保持2G以上的内存。 Linux下源码安装的脚本可以点击此处下载： nexus_install.sh，下面对安装过程做一下说明。 SonatypeNexus的下载地址为： https://help.sonatype.com/repomanager3/download/download-archives—repository-manager-3 Linux通过如下命令下载并解压： 123wget http://download.sonatype.com/nexus/3/nexus-3.13.0-01-unix.tar.gzsudo tar -zxvf nexus-3.13.0-01-unix.tar.gz -C /usr/local/nexussudo chown -R $(whoami):$(whoami) /usr/local/nexus Windows点击http://download.sonatype.com/nexus/3/nexus-3.13.0-01-win64.zip下载后解压到本地磁盘 解压后，有nexus-3.13.0-01和sonatype-work两个目录： nexus-3.13.0-01是软件目录，升级SonatypeNexus版本是只需要替换这个目录即可 sonatype-work是数据目录，所有配置信息，软件包都在这个目录 SonatypeNexus的启动进入到Nexus的安装目录nexus-3.13.0-01/bin/nexus, Linux执行./nexus start即可启动。查看启动日志在tail -100f sonatype-work/nexus3/log/nexus.log，当日志中出现如下的字样时表示nexus已经启动成功。 Windows下执行nexus.exe /run即可启动。 默认情况下，Nexus监听的端口号为8081，我们通过浏览器访问就可以看到Nexus的页面，默认的用户名为admin，密码为admin123。 系统服务与开机启动我们还是采用systemd的方式添加到系统服务，执行如下命令： 12345678910111213141516171819202122(cat &lt;&lt;EOF[Unit]Description=Sonatyp Nexus DaemonAfter=network.targetWants=network-online.target[Service]Type=forkingLimitNOFILE=65536ExecStart=/usr/local/nexus/nexus-3.13.0-01/bin/nexus startExecStop=/usr/local/nexus/nexus-3.13.0-01/bin/nexus stopUser=$(whoami)Restart=on-abort[Install]WantedBy=multi-user.targetEOF) &gt; nexus.servicesudo cp -a nexus.service /lib/systemd/system/nexus.servicesudo ln -s /lib/systemd/system/nexus.service /etc/systemd/system/multi-user.target.wants/nexus.service 然后启动并添加为开机启动： 12sudo systemctl start nexussudo systemctl enable nexus Nexus启动不起来的可能原因: 没有安装java，可以通过java -version进行测试 当前用户没有nexus所在目录的权限，可以在执行用户下执行sudo chown -R $(whoami):$(whoami) /usr/local/nexus SonatypeNexus的配置配置最大文件句柄数在Nexus的界面中可以看到提示System Requirement: max file descriptors [4096] likely too low, increase to at least [65536].，点击进去可以看到具体的设置方式，如果采用上文中的systemd的方式启动nexus，则不存在这个问题，因为我们已经在nexus.service中设置最大文件句柄数LimitNOFILE=65536。 注意：设置完该参数后需要重新启动进程才可以生效。","raw":"---\ntitle: SonatypeNexus的安装与使用\ntags: 环境搭建\ncategories: 环境搭建\ndate: 2018-10-02 18:21:06\n---\n\n\n# SonatypeNexus的介绍\n\nSonatype Nexus可以用来作为Maven/Java, npm, NuGet, RubyGems, Docker, P2, OBR, APT and YUM等的代理仓和私有仓库，同时还与Eclipse, IntelliJ, Hudson, Jenkins, Puppet, Chef, Docker等工具有很好的集成。那么我们在开发中可以用SonatypeNexus做什么呢？\n\n1. 代理并缓存Maven/npm/docker等中央仓，提升下载速度\n1. 作为Maven/npm/docker等的私有仓库，上传私有组件\n1. 作为编译构建仓库，用于分享或者部署到环境\n\n# SonatypeNexus的安装\n\n> 在启动之前需要先安装java环境，具体可以参考教程：{% post_link JDK安装教程 %}。另外Nexus对内存要求比较大，请至少保持2G以上的内存。\n\nLinux下源码安装的脚本可以点击此处下载： {% asset_link nexus_install.sh nexus_install.sh %}，下面对安装过程做一下说明。\n\nSonatypeNexus的下载地址为： [https://help.sonatype.com/repomanager3/download/download-archives---repository-manager-3](https://help.sonatype.com/repomanager3/download/download-archives---repository-manager-3)\n\nLinux通过如下命令下载并解压：\n\n```bash\nwget http://download.sonatype.com/nexus/3/nexus-3.13.0-01-unix.tar.gz\nsudo tar -zxvf nexus-3.13.0-01-unix.tar.gz -C /usr/local/nexus\nsudo chown -R $(whoami):$(whoami) /usr/local/nexus\n```\n\n> Windows点击[http://download.sonatype.com/nexus/3/nexus-3.13.0-01-win64.zip](http://download.sonatype.com/nexus/3/nexus-3.13.0-01-win64.zip)下载后解压到本地磁盘\n\n解压后，有`nexus-3.13.0-01`和`sonatype-work`两个目录：\n\n1. `nexus-3.13.0-01`是软件目录，升级SonatypeNexus版本是只需要替换这个目录即可\n1. `sonatype-work`是数据目录，所有配置信息，软件包都在这个目录\n\n# SonatypeNexus的启动\n\n进入到Nexus的安装目录`nexus-3.13.0-01/bin/nexus`, Linux执行`./nexus start`即可启动。查看启动日志在`tail -100f sonatype-work/nexus3/log/nexus.log`，当日志中出现如下的字样时表示nexus已经启动成功。\n\n> Windows下执行`nexus.exe /run`即可启动。\n\n{% asset_img 2018-10-02-20-27-22.png [blog.ruanxinyu.cn] %}\n\n默认情况下，Nexus监听的端口号为`8081`，我们通过浏览器访问就可以看到Nexus的页面，默认的用户名为`admin`，密码为`admin123`。\n\n{% asset_img 2018-10-02-20-33-44.png [blog.ruanxinyu.cn] %}\n\n# 系统服务与开机启动\n\n我们还是采用systemd的方式添加到系统服务，执行如下命令：\n\n```bash\n(\ncat <<EOF\n[Unit]\nDescription=Sonatyp Nexus Daemon\nAfter=network.target\nWants=network-online.target\n\n[Service]\nType=forking\nLimitNOFILE=65536\nExecStart=/usr/local/nexus/nexus-3.13.0-01/bin/nexus start\nExecStop=/usr/local/nexus/nexus-3.13.0-01/bin/nexus stop\nUser=$(whoami)\nRestart=on-abort\n\n[Install]\nWantedBy=multi-user.target\nEOF\n) > nexus.service\n\nsudo cp -a nexus.service /lib/systemd/system/nexus.service\nsudo ln -s /lib/systemd/system/nexus.service /etc/systemd/system/multi-user.target.wants/nexus.service\n```\n\n然后启动并添加为开机启动：\n\n```bash\nsudo systemctl start nexus\nsudo systemctl enable nexus\n```\n\n**Nexus启动不起来的可能原因:**\n\n1. 没有安装java，可以通过`java -version`进行测试\n2. 当前用户没有nexus所在目录的权限，可以在执行用户下执行`sudo chown -R $(whoami):$(whoami) /usr/local/nexus`\n\n\n# SonatypeNexus的配置\n\n## 配置最大文件句柄数\n\n在Nexus的界面中可以看到提示[`System Requirement: max file descriptors [4096] likely too low, increase to at least [65536].`](https://help.sonatype.com/repomanager3/system-requirements#filehandles)，点击进去可以看到具体的设置方式，如果采用上文中的systemd的方式启动nexus，则不存在这个问题，因为我们已经在`nexus.service`中设置最大文件句柄数`LimitNOFILE=65536`。\n\n**注意：**设置完该参数后需要重新启动进程才可以生效。\n","content":"<h1 id=\"SonatypeNexus的介绍\"><a href=\"#SonatypeNexus的介绍\" class=\"headerlink\" title=\"SonatypeNexus的介绍\"></a>SonatypeNexus的介绍</h1><p>Sonatype Nexus可以用来作为Maven/Java, npm, NuGet, RubyGems, Docker, P2, OBR, APT and YUM等的代理仓和私有仓库，同时还与Eclipse, IntelliJ, Hudson, Jenkins, Puppet, Chef, Docker等工具有很好的集成。那么我们在开发中可以用SonatypeNexus做什么呢？</p>\n<ol>\n<li>代理并缓存Maven/npm/docker等中央仓，提升下载速度</li>\n<li>作为Maven/npm/docker等的私有仓库，上传私有组件</li>\n<li>作为编译构建仓库，用于分享或者部署到环境</li>\n</ol>\n<h1 id=\"SonatypeNexus的安装\"><a href=\"#SonatypeNexus的安装\" class=\"headerlink\" title=\"SonatypeNexus的安装\"></a>SonatypeNexus的安装</h1><blockquote>\n<p>在启动之前需要先安装java环境，具体可以参考教程：<a href=\"/posts/JDK安装教程/\" title=\"JDK安装教程\">JDK安装教程</a>。另外Nexus对内存要求比较大，请至少保持2G以上的内存。</p>\n</blockquote>\n<p>Linux下源码安装的脚本可以点击此处下载： <a href=\"/posts/SonatypeNexus的安装与使用/nexus_install.sh\" title=\"nexus_install.sh\">nexus_install.sh</a>，下面对安装过程做一下说明。</p>\n<p>SonatypeNexus的下载地址为： <a href=\"https://help.sonatype.com/repomanager3/download/download-archives---repository-manager-3\" target=\"_blank\" rel=\"noopener\">https://help.sonatype.com/repomanager3/download/download-archives—repository-manager-3</a></p>\n<p>Linux通过如下命令下载并解压：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://download.sonatype.com/nexus/3/nexus-3.13.0-01-unix.tar.gz</span><br><span class=\"line\">sudo tar -zxvf nexus-3.13.0-01-unix.tar.gz -C /usr/<span class=\"built_in\">local</span>/nexus</span><br><span class=\"line\">sudo chown -R $(whoami):$(whoami) /usr/<span class=\"built_in\">local</span>/nexus</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Windows点击<a href=\"http://download.sonatype.com/nexus/3/nexus-3.13.0-01-win64.zip\" target=\"_blank\" rel=\"noopener\">http://download.sonatype.com/nexus/3/nexus-3.13.0-01-win64.zip</a>下载后解压到本地磁盘</p>\n</blockquote>\n<p>解压后，有<code>nexus-3.13.0-01</code>和<code>sonatype-work</code>两个目录：</p>\n<ol>\n<li><code>nexus-3.13.0-01</code>是软件目录，升级SonatypeNexus版本是只需要替换这个目录即可</li>\n<li><code>sonatype-work</code>是数据目录，所有配置信息，软件包都在这个目录</li>\n</ol>\n<h1 id=\"SonatypeNexus的启动\"><a href=\"#SonatypeNexus的启动\" class=\"headerlink\" title=\"SonatypeNexus的启动\"></a>SonatypeNexus的启动</h1><p>进入到Nexus的安装目录<code>nexus-3.13.0-01/bin/nexus</code>, Linux执行<code>./nexus start</code>即可启动。查看启动日志在<code>tail -100f sonatype-work/nexus3/log/nexus.log</code>，当日志中出现如下的字样时表示nexus已经启动成功。</p>\n<blockquote>\n<p>Windows下执行<code>nexus.exe /run</code>即可启动。</p>\n</blockquote>\n<img src=\"/posts/SonatypeNexus的安装与使用/2018-10-02-20-27-22.png\" title=\"[blog.ruanxinyu.cn]\">\n<p>默认情况下，Nexus监听的端口号为<code>8081</code>，我们通过浏览器访问就可以看到Nexus的页面，默认的用户名为<code>admin</code>，密码为<code>admin123</code>。</p>\n<img src=\"/posts/SonatypeNexus的安装与使用/2018-10-02-20-33-44.png\" title=\"[blog.ruanxinyu.cn]\">\n<h1 id=\"系统服务与开机启动\"><a href=\"#系统服务与开机启动\" class=\"headerlink\" title=\"系统服务与开机启动\"></a>系统服务与开机启动</h1><p>我们还是采用systemd的方式添加到系统服务，执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(</span><br><span class=\"line\">cat &lt;&lt;EOF</span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Sonatyp Nexus Daemon</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\">Wants=network-online.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=forking</span><br><span class=\"line\">LimitNOFILE=65536</span><br><span class=\"line\">ExecStart=/usr/<span class=\"built_in\">local</span>/nexus/nexus-3.13.0-01/bin/nexus start</span><br><span class=\"line\">ExecStop=/usr/<span class=\"built_in\">local</span>/nexus/nexus-3.13.0-01/bin/nexus stop</span><br><span class=\"line\">User=$(whoami)</span><br><span class=\"line\">Restart=on-abort</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br><span class=\"line\">EOF</span><br><span class=\"line\">) &gt; nexus.service</span><br><span class=\"line\"></span><br><span class=\"line\">sudo cp -a nexus.service /lib/systemd/system/nexus.service</span><br><span class=\"line\">sudo ln -s /lib/systemd/system/nexus.service /etc/systemd/system/multi-user.target.wants/nexus.service</span><br></pre></td></tr></table></figure>\n<p>然后启动并添加为开机启动：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start nexus</span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">enable</span> nexus</span><br></pre></td></tr></table></figure>\n<p><strong>Nexus启动不起来的可能原因:</strong></p>\n<ol>\n<li>没有安装java，可以通过<code>java -version</code>进行测试</li>\n<li>当前用户没有nexus所在目录的权限，可以在执行用户下执行<code>sudo chown -R $(whoami):$(whoami) /usr/local/nexus</code></li>\n</ol>\n<h1 id=\"SonatypeNexus的配置\"><a href=\"#SonatypeNexus的配置\" class=\"headerlink\" title=\"SonatypeNexus的配置\"></a>SonatypeNexus的配置</h1><h2 id=\"配置最大文件句柄数\"><a href=\"#配置最大文件句柄数\" class=\"headerlink\" title=\"配置最大文件句柄数\"></a>配置最大文件句柄数</h2><p>在Nexus的界面中可以看到提示<a href=\"https://help.sonatype.com/repomanager3/system-requirements#filehandles\" target=\"_blank\" rel=\"noopener\"><code>System Requirement: max file descriptors [4096] likely too low, increase to at least [65536].</code></a>，点击进去可以看到具体的设置方式，如果采用上文中的systemd的方式启动nexus，则不存在这个问题，因为我们已经在<code>nexus.service</code>中设置最大文件句柄数<code>LimitNOFILE=65536</code>。</p>\n<p><strong>注意：</strong>设置完该参数后需要重新启动进程才可以生效。</p>\n","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/categories/环境搭建/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/tags/环境搭建/"}]},{"title":"我的博客规划路线图","slug":"我的博客规划路线图","date":"un22fin22","updated":"un66fin66","comments":true,"path":"posts/我的博客规划路线图/","link":"","permalink":"http://ruanxinyu.github.io/posts/我的博客规划路线图/","excerpt":"","keywords":"","text":"我对于博客建设的思考为什么要写博客？写博客有两个目的，一个是促进知识的内化，二是提升自己的影响力。 以教为学是一个很好的学习方式，而且现在信息太多，如果不经过自己整理归纳，那就很容易成为知识收藏者，而不是知识的产生者和传播者，显然我是希望成为后者的，我希望通过将知识体系化从而提升自己的核心竞争力。 影响力有两个很重要的作用，一个是提升收入，一个是提升满足感，这对我都很重要。如何建立影响力？建立品牌并服务他人，对于身边的人，还可以通过行为来影响，但是对于陌生人只能通过分享，因此内容建设很重要，博客是其中一个途径。 如何选择博客内容？博客内容选择需要考虑三个点：独特性，体系化，刚需。 独特性有两个方面，对于自己，因为要建立T型或者E型人才，所以要确定哪些内容需要深度，哪些内容需要广度；对于外部读者，如果博文是网上没有的，这样用户搜索肯定就会搜到你的，这肯是独特的，但是这样的主题能找到，但是可能不多，这个依赖于自己的观察，比如说Nexus的源码分析。 更多的时候博文内容网上通篇都是，那么用户为什么要看你的，那么这个地方就需要考虑体系化和刚需。内容不能太分散，需要成体系化，这样才能让博文之间产生关联性，提高点击率，产生用户粘性。谈到刚需，那么必然要谈到用户群体，我针对的是初级用户，比如未出学校的大学生和刚入职场的新人，因为他们可能缺少实际的项目经验，因此他们缺少体系化的认识，那么我就正好可以以我自己为例，为用户构建一个成长为T型人才的路径，这也和我自己的目标是一致的。所以博客的文章是可以零散的，但是文章之间的关系必须是体系化，场景化的。 博客不仅限于技术的分享，因为我的目标是让自己过得更好，那么在心理学，历史学，经济学，个人成长等领域也是可以总结和分享，以一个点为起点，逐步向周边辐射，扩展维度，这样才能保持自己的独特性。用20%的时间学习一个领域的80%内容，而不是用80%的时间将一个维度提升至90%，这样才能实现跨学科之间的创新性，当然，在这个过程中，在某一个核心领域还是要长期保持深入学习的。 对于心理学，历史学，经济学，个人成长其实更多的是以读书笔记为重点，通过得到App课程和主题阅读将内容体系化。 技术规划路线我是搞软件开发的，因此技术规划也就是软件行业的。因为代码能力需要多写，而且内容更零散的，而架构能力更能体现出体系化，因此我分享更多的是架构能力，基于不同场景使用不同架构，通过一步一步的搭建系统架构来帮助用户提升整体认识。每一个主题都有一个总体的架构图作为目标，为了达到这个目标，我们会分解目标逐步完成，分步验证。 【进行中】 Nginx-HAProxy-KeepAlived-Tomcat-MySQL等搭建高可用系统 【等待中】 搭建基于SpringCloud的高可用生产系统 【等待中】 如何从头开始搭建持续交付系统 Nginx-HAProxy-KeepAlived-Tomcat-MySQL等搭建高可用系统","raw":"---\ntitle: 我的博客规划路线图\ntags: 技术分享\ncategories: 技术分享\ndate: 2018-10-02 15:56:46\n---\n\n# 我对于博客建设的思考\n\n## 为什么要写博客？\n\n写博客有两个目的，一个是`促进知识的内化`，二是`提升自己的影响力`。\n\n以教为学是一个很好的学习方式，而且现在信息太多，如果不经过自己整理归纳，那就很容易成为知识收藏者，而不是知识的产生者和传播者，显然我是希望成为后者的，我希望通过将知识体系化从而提升自己的核心竞争力。\n\n影响力有两个很重要的作用，一个是提升收入，一个是提升满足感，这对我都很重要。如何建立影响力？建立品牌并服务他人，对于身边的人，还可以通过行为来影响，但是对于陌生人只能通过分享，因此内容建设很重要，博客是其中一个途径。\n\n## 如何选择博客内容？\n\n博客内容选择需要考虑三个点：`独特性`，`体系化`，`刚需`。\n\n独特性有两个方面，对于自己，因为要建立T型或者E型人才，所以要确定哪些内容需要深度，哪些内容需要广度；对于外部读者，如果博文是网上没有的，这样用户搜索肯定就会搜到你的，这肯是独特的，但是这样的主题能找到，但是可能不多，这个依赖于自己的观察，比如说Nexus的源码分析。\n\n更多的时候博文内容网上通篇都是，那么用户为什么要看你的，那么这个地方就需要考虑体系化和刚需。内容不能太分散，需要成体系化，这样才能让博文之间产生关联性，提高点击率，产生用户粘性。谈到刚需，那么必然要谈到用户群体，我针对的是初级用户，比如未出学校的大学生和刚入职场的新人，因为他们可能缺少实际的项目经验，因此他们缺少体系化的认识，那么我就正好可以以我自己为例，为用户构建一个成长为T型人才的路径，这也和我自己的目标是一致的。所以`博客的文章是可以零散的，但是文章之间的关系必须是体系化，场景化`的。\n\n博客不仅限于技术的分享，因为我的目标是让自己过得更好，那么在心理学，历史学，经济学，个人成长等领域也是可以总结和分享，`以一个点为起点，逐步向周边辐射，扩展维度，这样才能保持自己的独特性`。用20%的时间学习一个领域的80%内容，而不是用80%的时间将一个维度提升至90%，这样才能实现跨学科之间的创新性，当然，在这个过程中，在某一个核心领域还是要长期保持深入学习的。\n\n对于心理学，历史学，经济学，个人成长其实更多的是以`读书笔记`为重点，通过`得到App课程`和`主题阅读`将内容体系化。\n\n# 技术规划路线\n\n我是搞软件开发的，因此技术规划也就是软件行业的。因为代码能力需要多写，而且内容更零散的，而架构能力更能体现出体系化，因此`我分享更多的是架构能力，基于不同场景使用不同架构`，通过一步一步的搭建系统架构来帮助用户提升整体认识。每一个主题都有一个总体的架构图作为目标，为了达到这个目标，我们会分解目标逐步完成，分步验证。\n\n+ 【进行中】 Nginx-HAProxy-KeepAlived-Tomcat-MySQL等搭建高可用系统\n+ 【等待中】 搭建基于SpringCloud的高可用生产系统\n+ 【等待中】 如何从头开始搭建持续交付系统\n\n## Nginx-HAProxy-KeepAlived-Tomcat-MySQL等搭建高可用系统\n\n{% asset_img 2018-10-02-17-11-54.png [blog.ruanxinyu.cn] %}\n","content":"<h1 id=\"我对于博客建设的思考\"><a href=\"#我对于博客建设的思考\" class=\"headerlink\" title=\"我对于博客建设的思考\"></a>我对于博客建设的思考</h1><h2 id=\"为什么要写博客？\"><a href=\"#为什么要写博客？\" class=\"headerlink\" title=\"为什么要写博客？\"></a>为什么要写博客？</h2><p>写博客有两个目的，一个是<code>促进知识的内化</code>，二是<code>提升自己的影响力</code>。</p>\n<p>以教为学是一个很好的学习方式，而且现在信息太多，如果不经过自己整理归纳，那就很容易成为知识收藏者，而不是知识的产生者和传播者，显然我是希望成为后者的，我希望通过将知识体系化从而提升自己的核心竞争力。</p>\n<p>影响力有两个很重要的作用，一个是提升收入，一个是提升满足感，这对我都很重要。如何建立影响力？建立品牌并服务他人，对于身边的人，还可以通过行为来影响，但是对于陌生人只能通过分享，因此内容建设很重要，博客是其中一个途径。</p>\n<h2 id=\"如何选择博客内容？\"><a href=\"#如何选择博客内容？\" class=\"headerlink\" title=\"如何选择博客内容？\"></a>如何选择博客内容？</h2><p>博客内容选择需要考虑三个点：<code>独特性</code>，<code>体系化</code>，<code>刚需</code>。</p>\n<p>独特性有两个方面，对于自己，因为要建立T型或者E型人才，所以要确定哪些内容需要深度，哪些内容需要广度；对于外部读者，如果博文是网上没有的，这样用户搜索肯定就会搜到你的，这肯是独特的，但是这样的主题能找到，但是可能不多，这个依赖于自己的观察，比如说Nexus的源码分析。</p>\n<p>更多的时候博文内容网上通篇都是，那么用户为什么要看你的，那么这个地方就需要考虑体系化和刚需。内容不能太分散，需要成体系化，这样才能让博文之间产生关联性，提高点击率，产生用户粘性。谈到刚需，那么必然要谈到用户群体，我针对的是初级用户，比如未出学校的大学生和刚入职场的新人，因为他们可能缺少实际的项目经验，因此他们缺少体系化的认识，那么我就正好可以以我自己为例，为用户构建一个成长为T型人才的路径，这也和我自己的目标是一致的。所以<code>博客的文章是可以零散的，但是文章之间的关系必须是体系化，场景化</code>的。</p>\n<p>博客不仅限于技术的分享，因为我的目标是让自己过得更好，那么在心理学，历史学，经济学，个人成长等领域也是可以总结和分享，<code>以一个点为起点，逐步向周边辐射，扩展维度，这样才能保持自己的独特性</code>。用20%的时间学习一个领域的80%内容，而不是用80%的时间将一个维度提升至90%，这样才能实现跨学科之间的创新性，当然，在这个过程中，在某一个核心领域还是要长期保持深入学习的。</p>\n<p>对于心理学，历史学，经济学，个人成长其实更多的是以<code>读书笔记</code>为重点，通过<code>得到App课程</code>和<code>主题阅读</code>将内容体系化。</p>\n<h1 id=\"技术规划路线\"><a href=\"#技术规划路线\" class=\"headerlink\" title=\"技术规划路线\"></a>技术规划路线</h1><p>我是搞软件开发的，因此技术规划也就是软件行业的。因为代码能力需要多写，而且内容更零散的，而架构能力更能体现出体系化，因此<code>我分享更多的是架构能力，基于不同场景使用不同架构</code>，通过一步一步的搭建系统架构来帮助用户提升整体认识。每一个主题都有一个总体的架构图作为目标，为了达到这个目标，我们会分解目标逐步完成，分步验证。</p>\n<ul>\n<li>【进行中】 Nginx-HAProxy-KeepAlived-Tomcat-MySQL等搭建高可用系统</li>\n<li>【等待中】 搭建基于SpringCloud的高可用生产系统</li>\n<li>【等待中】 如何从头开始搭建持续交付系统</li>\n</ul>\n<h2 id=\"Nginx-HAProxy-KeepAlived-Tomcat-MySQL等搭建高可用系统\"><a href=\"#Nginx-HAProxy-KeepAlived-Tomcat-MySQL等搭建高可用系统\" class=\"headerlink\" title=\"Nginx-HAProxy-KeepAlived-Tomcat-MySQL等搭建高可用系统\"></a>Nginx-HAProxy-KeepAlived-Tomcat-MySQL等搭建高可用系统</h2><img src=\"/posts/我的博客规划路线图/2018-10-02-17-11-54.png\" title=\"[blog.ruanxinyu.cn]\">\n","categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://ruanxinyu.github.io/categories/技术分享/"}],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"http://ruanxinyu.github.io/tags/技术分享/"}]},{"title":"Ubuntu下Nginx的安装与配置","slug":"Ubuntu下Nginx的安装与配置","date":"un22fin22","updated":"un22fin22","comments":true,"path":"posts/Ubuntu下Nginx的安装与配置/","link":"","permalink":"http://ruanxinyu.github.io/posts/Ubuntu下Nginx的安装与配置/","excerpt":"","keywords":"","text":"Nginx的简介官方网址：http://nginx.org/。 Nginx可以作为http服务器、反向代理服务器、邮件服务器和负载均衡服务器等功能，具有性能高、扩展灵活等特点，能够快速的响应静态网页的请求，支持FastCGI/SSL/Virtual Host/URL Rwrite/Gzip/HTTP Basic Auth等功能，并且支持丰富的第三方扩展功能。 Nginx的安装该教程使用的Ubuntu版本是18.04.1版本，Ubuntu的安装教程参考VirtualBox安装Ubuntu教程。Nginx可以直接通过apt-get安装，也可以通过源码编译安装。 apt-get安装Ubuntu下执行sudo apt-get install nginx命令即可安装。 通过which nginx可以看到Nginx是安装在/usr/sbin/nginx下，配置文件在/etc/nginx/目录下。 源码编译安装源码安装的脚本可以点击此处下载： nginx_install.sh，下面对安装过程做一下说明。 首先安装编译工具和openssl，下载Nginx源码并解压，然后执行源码编译三件套（./configure &amp;&amp; make &amp;&amp; make install），我们安装的目录为/usr/local/nginx： 123456789sudo apt-get install build-essential libssl-dev # 安装编译工具和openssl依赖sudo apt-get install zlib1g-devsudo apt-get install libpcre3 libpcre3-devwget http://nginx.org/download/nginx-1.15.4.tar.gz # 下载源码tar -zxvf nginx-1.15.4.tar.gz # 解压源码cd nginx-1.15.4/./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_v2_module --with-http_gzip_static_module --with-http_sub_module --with-pcre --with-http_ssl_module # 配置nginx的安装参数，可以根据自己的需要进行调整make # 编译源码sudo make install # 安装到安装目录，需要使用root权限 Nginx的启动和关闭Nginx的启动直接使用/usr/local/nginx/sbin/nginx, 在源码安装下使用的配置文件是/usr/local/nginx/conf/nginx.conf，通过/usr/local/nginx/sbin/nginx -s reload命令重新加载, 可以通过/usr/local/nginx/sbin/nginx -s stop停止进程 Nginx的开机启动方式1：rc.local编辑sudo vim /etc/rc.local, 在最下面添加sudo /usr/local/nginx/sbin/nginx语句即可。 方式2：systemctl我们还是采用systemd的方式添加到系统服务，执行如下命令： 12345678910111213141516171819202122(cat &lt;&lt;EOF[Unit]Description=Nginx DaemonAfter=syslog.target network-online.targetWants=network-online.targetConditionFileNotEmpty=/usr/local/nginx/conf/nginx.conf[Service]Type=forkingKillMode=processExecStart=/usr/local/nginx/sbin/nginxExecStop=/usr/local/nginx/sbin/nginx -s stopExecReload=/usr/local/nginx/sbin/nginx -s reload[Install]WantedBy=multi-user.targetEOF) &gt; nginx.servicesudo cp -a nginx.service /lib/systemd/system/nginx.servicesudo ln -s /lib/systemd/system/nginx.service /etc/systemd/system/multi-user.target.wants/nginx.service 启动Nginx进程，并设置为开机启动，通过sudo systemctl status nginx查看状态： 123sudo systemctl start nginxsudo systemctl status nginxsudo systemctl enable nginx Nginx的配置 Nginx功能强大，配置无法简单描述，因此，下文仅以一个最简单的静态文件服务器为例进行说明验证，更多的应用场景将会在其他的文章中进行说明。 配置文件是/usr/local/nginx/conf/nginx.conf，源码安装后默认的配置文件就已经提供了静态文件服务器的配置，我们增加autoindex on;参数以便后续更加方便的验证功能，如下所示： 12345678910111213141516171819202122232425262728worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location / &#123; root html; # 设置静态文件服务的本地目录为html目录 autoindex on; # 增加该参数以便自动生成文件目录 index index.html index.htm; # 默认访问文件夹下的index.html &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 通过上面的配置可以看出，配置文件包含全局的配置、events和http等几部分，其中http表示定义了一个HTTP服务器，其中包含一个server监听本地机器的80端口，server中的location用来定义网址路由，通过root用来定义静态文件服务的本地目录，此处指定的是nginx安装目录下的html目录/usr/local/nginx/html/. Nginx的验证采用nginx的默认配置启动nginx，此时通过浏览器访问80端口即可以看到如下的页面，即/usr/local/nginx/html/index.html的内容。 我们在/usr/local/nginx/html/下创建一些文件夹和文件cd /usr/local/nginx/html/ &amp;&amp; sudo mkdir -p aa/aa aa/bb aa/cc aa/dd &amp;&amp; sudo touch aa/a.txt，可以通过浏览器看到对应的文件：","raw":"---\ntitle: Ubuntu下Nginx的安装与配置\ntags: 环境搭建\ncategories: 环境搭建\ndate: 2018-10-02 14:19:56\n---\n\n# Nginx的简介\n\n官方网址：[http://nginx.org/](http://nginx.org/)。 Nginx可以作为http服务器、反向代理服务器、邮件服务器和负载均衡服务器等功能，具有性能高、扩展灵活等特点，能够快速的响应静态网页的请求，支持FastCGI/SSL/Virtual Host/URL Rwrite/Gzip/HTTP Basic Auth等功能，并且支持丰富的第三方扩展功能。\n\n# Nginx的安装\n\n该教程使用的Ubuntu版本是18.04.1版本，Ubuntu的安装教程参考{% post_link VirtualBox安装Ubuntu教程 %}。Nginx可以直接通过apt-get安装，也可以通过源码编译安装。\n\n## apt-get安装\n\nUbuntu下执行`sudo apt-get install nginx`命令即可安装。\n\n通过`which nginx`可以看到Nginx是安装在`/usr/sbin/nginx`下，配置文件在`/etc/nginx/`目录下。\n\n## 源码编译安装\n\n源码安装的脚本可以点击此处下载： {% asset_link nginx_install.sh nginx_install.sh %}，下面对安装过程做一下说明。\n\n首先安装编译工具和openssl，下载Nginx源码并解压，然后执行源码编译三件套（`./configure && make && make install`），我们安装的目录为`/usr/local/nginx`：\n\n```bash\nsudo apt-get install build-essential libssl-dev # 安装编译工具和openssl依赖\nsudo apt-get install zlib1g-dev\nsudo apt-get install libpcre3 libpcre3-dev\nwget http://nginx.org/download/nginx-1.15.4.tar.gz # 下载源码\ntar -zxvf nginx-1.15.4.tar.gz # 解压源码\ncd nginx-1.15.4/\n./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_v2_module --with-http_gzip_static_module --with-http_sub_module --with-pcre --with-http_ssl_module # 配置nginx的安装参数，可以根据自己的需要进行调整\nmake # 编译源码\nsudo make install # 安装到安装目录，需要使用root权限\n```\n\n# Nginx的启动和关闭\n\nNginx的启动直接使用`/usr/local/nginx/sbin/nginx`, 在源码安装下使用的配置文件是`/usr/local/nginx/conf/nginx.conf`，通过`/usr/local/nginx/sbin/nginx -s reload`命令重新加载, 可以通过`/usr/local/nginx/sbin/nginx -s stop`停止进程\n\n# Nginx的开机启动\n\n## 方式1：rc.local\n\n编辑`sudo vim /etc/rc.local`, 在最下面添加`sudo /usr/local/nginx/sbin/nginx`语句即可。\n\n## 方式2：systemctl\n\n我们还是采用systemd的方式添加到系统服务，执行如下命令：\n\n```bash\n(\ncat <<EOF\n[Unit]\nDescription=Nginx Daemon\nAfter=syslog.target network-online.target\nWants=network-online.target\nConditionFileNotEmpty=/usr/local/nginx/conf/nginx.conf\n\n[Service]\nType=forking\nKillMode=process\nExecStart=/usr/local/nginx/sbin/nginx\nExecStop=/usr/local/nginx/sbin/nginx -s stop\nExecReload=/usr/local/nginx/sbin/nginx -s reload\n\n[Install]\nWantedBy=multi-user.target\nEOF\n) > nginx.service\n\nsudo cp -a nginx.service /lib/systemd/system/nginx.service\nsudo ln -s /lib/systemd/system/nginx.service /etc/systemd/system/multi-user.target.wants/nginx.service\n```\n\n启动Nginx进程，并设置为开机启动，通过`sudo systemctl status nginx`查看状态：\n\n```bash\nsudo systemctl start nginx\nsudo systemctl status nginx\nsudo systemctl enable nginx\n```\n\n# Nginx的配置\n\n> Nginx功能强大，配置无法简单描述，因此，下文仅以一个最简单的静态文件服务器为例进行说明验证，更多的应用场景将会在其他的文章中进行说明。\n\n配置文件是`/usr/local/nginx/conf/nginx.conf`，源码安装后默认的配置文件就已经提供了静态文件服务器的配置，我们增加`autoindex on;`参数以便后续更加方便的验证功能，如下所示：\n\n```bash\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n\n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n            root   html; # 设置静态文件服务的本地目录为html目录\n            autoindex on; # 增加该参数以便自动生成文件目录\n            index  index.html index.htm; # 默认访问文件夹下的index.html\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n    }\n}\n```\n\n通过上面的配置可以看出，配置文件包含全局的配置、`events`和`http`等几部分，其中`http`表示定义了一个HTTP服务器，其中包含一个`server`监听本地机器的80端口，`server`中的`location`用来定义网址路由，通过`root`用来定义静态文件服务的本地目录，此处指定的是nginx安装目录下的`html`目录`/usr/local/nginx/html/`.\n\n# Nginx的验证\n\n采用nginx的默认配置启动nginx，此时通过浏览器访问80端口即可以看到如下的页面，即`/usr/local/nginx/html/index.html`的内容。\n{% asset_img 2018-10-02-15-11-05.png [blog.ruanxinyu.cn] %}\n\n我们在`/usr/local/nginx/html/`下创建一些文件夹和文件`cd /usr/local/nginx/html/ && sudo mkdir -p  aa/aa aa/bb aa/cc aa/dd && sudo touch aa/a.txt`，可以通过浏览器看到对应的文件：\n{% asset_img 2018-10-02-15-15-27.png [blog.ruanxinyu.cn] %}","content":"<h1 id=\"Nginx的简介\"><a href=\"#Nginx的简介\" class=\"headerlink\" title=\"Nginx的简介\"></a>Nginx的简介</h1><p>官方网址：<a href=\"http://nginx.org/\" target=\"_blank\" rel=\"noopener\">http://nginx.org/</a>。 Nginx可以作为http服务器、反向代理服务器、邮件服务器和负载均衡服务器等功能，具有性能高、扩展灵活等特点，能够快速的响应静态网页的请求，支持FastCGI/SSL/Virtual Host/URL Rwrite/Gzip/HTTP Basic Auth等功能，并且支持丰富的第三方扩展功能。</p>\n<h1 id=\"Nginx的安装\"><a href=\"#Nginx的安装\" class=\"headerlink\" title=\"Nginx的安装\"></a>Nginx的安装</h1><p>该教程使用的Ubuntu版本是18.04.1版本，Ubuntu的安装教程参考<a href=\"/posts/VirtualBox安装Ubuntu教程/\" title=\"VirtualBox安装Ubuntu教程\">VirtualBox安装Ubuntu教程</a>。Nginx可以直接通过apt-get安装，也可以通过源码编译安装。</p>\n<h2 id=\"apt-get安装\"><a href=\"#apt-get安装\" class=\"headerlink\" title=\"apt-get安装\"></a>apt-get安装</h2><p>Ubuntu下执行<code>sudo apt-get install nginx</code>命令即可安装。</p>\n<p>通过<code>which nginx</code>可以看到Nginx是安装在<code>/usr/sbin/nginx</code>下，配置文件在<code>/etc/nginx/</code>目录下。</p>\n<h2 id=\"源码编译安装\"><a href=\"#源码编译安装\" class=\"headerlink\" title=\"源码编译安装\"></a>源码编译安装</h2><p>源码安装的脚本可以点击此处下载： <a href=\"/posts/Ubuntu下Nginx的安装与配置/nginx_install.sh\" title=\"nginx_install.sh\">nginx_install.sh</a>，下面对安装过程做一下说明。</p>\n<p>首先安装编译工具和openssl，下载Nginx源码并解压，然后执行源码编译三件套（<code>./configure &amp;&amp; make &amp;&amp; make install</code>），我们安装的目录为<code>/usr/local/nginx</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install build-essential libssl-dev <span class=\"comment\"># 安装编译工具和openssl依赖</span></span><br><span class=\"line\">sudo apt-get install zlib1g-dev</span><br><span class=\"line\">sudo apt-get install libpcre3 libpcre3-dev</span><br><span class=\"line\">wget http://nginx.org/download/nginx-1.15.4.tar.gz <span class=\"comment\"># 下载源码</span></span><br><span class=\"line\">tar -zxvf nginx-1.15.4.tar.gz <span class=\"comment\"># 解压源码</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> nginx-1.15.4/</span><br><span class=\"line\">./configure --prefix=/usr/<span class=\"built_in\">local</span>/nginx --with-http_stub_status_module --with-http_v2_module --with-http_gzip_static_module --with-http_sub_module --with-pcre --with-http_ssl_module <span class=\"comment\"># 配置nginx的安装参数，可以根据自己的需要进行调整</span></span><br><span class=\"line\">make <span class=\"comment\"># 编译源码</span></span><br><span class=\"line\">sudo make install <span class=\"comment\"># 安装到安装目录，需要使用root权限</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"Nginx的启动和关闭\"><a href=\"#Nginx的启动和关闭\" class=\"headerlink\" title=\"Nginx的启动和关闭\"></a>Nginx的启动和关闭</h1><p>Nginx的启动直接使用<code>/usr/local/nginx/sbin/nginx</code>, 在源码安装下使用的配置文件是<code>/usr/local/nginx/conf/nginx.conf</code>，通过<code>/usr/local/nginx/sbin/nginx -s reload</code>命令重新加载, 可以通过<code>/usr/local/nginx/sbin/nginx -s stop</code>停止进程</p>\n<h1 id=\"Nginx的开机启动\"><a href=\"#Nginx的开机启动\" class=\"headerlink\" title=\"Nginx的开机启动\"></a>Nginx的开机启动</h1><h2 id=\"方式1：rc-local\"><a href=\"#方式1：rc-local\" class=\"headerlink\" title=\"方式1：rc.local\"></a>方式1：rc.local</h2><p>编辑<code>sudo vim /etc/rc.local</code>, 在最下面添加<code>sudo /usr/local/nginx/sbin/nginx</code>语句即可。</p>\n<h2 id=\"方式2：systemctl\"><a href=\"#方式2：systemctl\" class=\"headerlink\" title=\"方式2：systemctl\"></a>方式2：systemctl</h2><p>我们还是采用systemd的方式添加到系统服务，执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(</span><br><span class=\"line\">cat &lt;&lt;EOF</span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Nginx Daemon</span><br><span class=\"line\">After=syslog.target network-online.target</span><br><span class=\"line\">Wants=network-online.target</span><br><span class=\"line\">ConditionFileNotEmpty=/usr/<span class=\"built_in\">local</span>/nginx/conf/nginx.conf</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=forking</span><br><span class=\"line\">KillMode=process</span><br><span class=\"line\">ExecStart=/usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx</span><br><span class=\"line\">ExecStop=/usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx -s stop</span><br><span class=\"line\">ExecReload=/usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx -s reload</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br><span class=\"line\">EOF</span><br><span class=\"line\">) &gt; nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\">sudo cp -a nginx.service /lib/systemd/system/nginx.service</span><br><span class=\"line\">sudo ln -s /lib/systemd/system/nginx.service /etc/systemd/system/multi-user.target.wants/nginx.service</span><br></pre></td></tr></table></figure>\n<p>启动Nginx进程，并设置为开机启动，通过<code>sudo systemctl status nginx</code>查看状态：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start nginx</span><br><span class=\"line\">sudo systemctl status nginx</span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">enable</span> nginx</span><br></pre></td></tr></table></figure>\n<h1 id=\"Nginx的配置\"><a href=\"#Nginx的配置\" class=\"headerlink\" title=\"Nginx的配置\"></a>Nginx的配置</h1><blockquote>\n<p>Nginx功能强大，配置无法简单描述，因此，下文仅以一个最简单的静态文件服务器为例进行说明验证，更多的应用场景将会在其他的文章中进行说明。</p>\n</blockquote>\n<p>配置文件是<code>/usr/local/nginx/conf/nginx.conf</code>，源码安装后默认的配置文件就已经提供了静态文件服务器的配置，我们增加<code>autoindex on;</code>参数以便后续更加方便的验证功能，如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker_processes  1;</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    worker_connections  1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            root   html; <span class=\"comment\"># 设置静态文件服务的本地目录为html目录</span></span><br><span class=\"line\">            autoindex on; <span class=\"comment\"># 增加该参数以便自动生成文件目录</span></span><br><span class=\"line\">            index  index.html index.htm; <span class=\"comment\"># 默认访问文件夹下的index.html</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page   500 502 503 504  /50x.html;</span><br><span class=\"line\">        location = /50x.html &#123;</span><br><span class=\"line\">            root   html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面的配置可以看出，配置文件包含全局的配置、<code>events</code>和<code>http</code>等几部分，其中<code>http</code>表示定义了一个HTTP服务器，其中包含一个<code>server</code>监听本地机器的80端口，<code>server</code>中的<code>location</code>用来定义网址路由，通过<code>root</code>用来定义静态文件服务的本地目录，此处指定的是nginx安装目录下的<code>html</code>目录<code>/usr/local/nginx/html/</code>.</p>\n<h1 id=\"Nginx的验证\"><a href=\"#Nginx的验证\" class=\"headerlink\" title=\"Nginx的验证\"></a>Nginx的验证</h1><p>采用nginx的默认配置启动nginx，此时通过浏览器访问80端口即可以看到如下的页面，即<code>/usr/local/nginx/html/index.html</code>的内容。<br><img src=\"/posts/Ubuntu下Nginx的安装与配置/2018-10-02-15-11-05.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>我们在<code>/usr/local/nginx/html/</code>下创建一些文件夹和文件<code>cd /usr/local/nginx/html/ &amp;&amp; sudo mkdir -p  aa/aa aa/bb aa/cc aa/dd &amp;&amp; sudo touch aa/a.txt</code>，可以通过浏览器看到对应的文件：<br><img src=\"/posts/Ubuntu下Nginx的安装与配置/2018-10-02-15-15-27.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/categories/环境搭建/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/tags/环境搭建/"}]},{"title":"阿里ACA认证学习记录","slug":"阿里ACA认证学习记录","date":"un55fin55","updated":"un44fin44","comments":true,"path":"posts/阿里ACA认证学习记录/","link":"","permalink":"http://ruanxinyu.github.io/posts/阿里ACA认证学习记录/","excerpt":"","keywords":"","text":"大数据概述大数据，指无法在可承受的时间范围内用常规软件工具进行捕捉，管理和处理的数据集合，是需要新处理模式才能具有更强的决策力，洞察发现力和流程优化能力的海量，高增长率和多样化的信息资产。 大数据的主要特征：4V 数据分析流程 Hadoop生态圈 阿里云大数据体系 数加的定位 统一的大数据计算平台 分析型数据库分析型数据库的介绍OLAP，OLTP，维度和度量，下钻，下图中时间，地区和产品就是维度，而销量和金额就是度量 MPP（大规模并行处理， Massive Parallel Processing） 分析型数据库：高并发在线分析（Realtime OLAP），与关系型数据库的区别是分析型数据库没有事务，是专门用于分析的，支持sql语句，但是跟关系型数据库没有什么关系 分析型数据库的基本概念表组 表组的特点 维表的特点，以空间换时间 事实表的特点 数据类型 多值列，不满足3范式，性能明显优于join 分析型数据库的基本操作DMS在表组中新建表 MaxComputeMaxCompute的介绍大数据计算服务 对象 分区 分区表 分区举例 其他概念， 执行sql都是task，是异步的 数据类型 阿里小贷 大数据架构 MaxCompute的架构介绍客户端 逻辑层 计算层 数据上传 数据下载 参数 分隔符 DDL的介绍创建表 表的生命周期，比如用来保持最近7天的数据 快捷建表 分区操作 修改表属性 视图操作 DML的介绍查询操作 更新数据 多路输出 表关联 MapJoin MapJoin举例 分支表达式 内置函数数学运算函数-1 数学运算函数-2 字符串处理函数 日期类型处理函数 窗口函数 聚合函数 其他函数 其他使用方式自定义函数 UDF开发流程 MapReduce介绍 MR框架 Graph 如何使用合适的方式 授权授权 添加用户授权 角色管理 DataIDEDataIDE介绍产品概述 开发流程-1 开发流程-2 应用场景 DataIDE基本概念概念 角色 多环境 数据集成数据集成支持两种开发模式 向导模式：选择来源 一键生成数据表 向导模式：选择目标 向导模式：字段映射 脚本模式： 数据开发脚本开发提供参数配置 执行脚本之前会提示费用情况 任务：节点任务支持调度，依赖管理，版本管理和参数配置 工作流任务支持编排 数据管理 数据表的信息在数据管理服务 数据表的创建支持DDL和图像化两个模式 运维中心介绍 任务管理 项目管理 QuickBI报表QuickBI的介绍产品概述 产品架构 角色定位 常见应用步骤 QuickBI的数据管理数据源管理 数据集管理 首页 新建数据源 表格分析 图表与门户-常见图标 图表 门户 DataV数据大屏产品介绍产品概述 特性1：多重场景模板 特性2：丰富开放的图表库 特性3：支持多种数据源 特性4：零门槛图形化界面设计 特性5，支持数据交互分析 特性6：支持适配与发布方式 DataV大屏介绍展示类大屏 展示类大屏示例 分析类大屏 分析类大屏示例 监控类大屏 监控类大屏示例 可视化大屏设计原则 大屏样例1 大屏样例2 DataV演示添加数据 视频和样例 创建大屏-1 创建大屏-2","raw":"---\ntitle: 阿里ACA认证学习记录\ntags: 大数据 学习记录\ncategories: 学习记录\ndate: 2018-09-28 15:23:31\n---\n\n# 大数据概述\n\n大数据，指无法在可承受的时间范围内用常规软件工具进行捕捉，管理和处理的数据集合，是需要新处理模式才能具有更强的决策力，洞察发现力和流程优化能力的海量，高增长率和多样化的信息资产。\n\n大数据的主要特征：4V\n{% asset_img 2018-09-28-15-39-47.png [blog.ruanxinyu.cn] %}\n\n{% asset_img 2018-09-28-15-40-26.png [blog.ruanxinyu.cn] %}\n\n数据分析流程\n{% asset_img 2018-09-28-15-41-31.png [blog.ruanxinyu.cn] %}\n\nHadoop生态圈\n{% asset_img 2018-09-28-15-43-04.png [blog.ruanxinyu.cn] %}\n\n阿里云大数据体系\n{% asset_img 2018-09-28-15-43-42.png [blog.ruanxinyu.cn] %}\n\n数加的定位\n{% asset_img 2018-09-28-15-44-21.png [blog.ruanxinyu.cn] %}\n\n统一的大数据计算平台\n{% asset_img 2018-09-28-15-45-11.png [blog.ruanxinyu.cn] %}\n\n# 分析型数据库\n\n## 分析型数据库的介绍\n\nOLAP，OLTP，维度和度量，下钻，下图中时间，地区和产品就是维度，而销量和金额就是度量\n{% asset_img 2018-09-28-15-47-20.png [blog.ruanxinyu.cn] %}\n\nMPP（大规模并行处理， Massive Parallel Processing）\n{% asset_img 2018-09-28-15-49-23.png [blog.ruanxinyu.cn] %}\n\n分析型数据库：高并发在线分析（Realtime OLAP），与关系型数据库的区别是分析型数据库没有事务，是专门用于分析的，支持sql语句，但是跟关系型数据库没有什么关系\n{% asset_img 2018-09-28-15-55-17.png [blog.ruanxinyu.cn] %}\n\n{% asset_img 2018-09-28-15-57-34.png [blog.ruanxinyu.cn] %}\n\n## 分析型数据库的基本概念\n\n表组\n{% asset_img 2018-09-28-16-13-05.png [blog.ruanxinyu.cn] %}\n\n表组的特点\n{% asset_img 2018-09-28-16-55-30.png [blog.ruanxinyu.cn] %}\n\n维表的特点，以空间换时间\n{% asset_img 2018-09-28-16-56-14.png [blog.ruanxinyu.cn] %}\n\n事实表的特点\n{% asset_img 2018-09-28-16-57-32.png [blog.ruanxinyu.cn] %}\n\n数据类型\n{% asset_img 2018-09-28-17-01-14.png [blog.ruanxinyu.cn] %}\n\n多值列，不满足3范式，性能明显优于join\n{% asset_img 2018-09-28-17-02-03.png [blog.ruanxinyu.cn] %}\n\n{% asset_img 2018-09-28-17-05-08.png [blog.ruanxinyu.cn] %}\n\n## 分析型数据库的基本操作\n\nDMS在表组中新建表\n{% asset_img 2018-09-28-17-17-52.png [blog.ruanxinyu.cn] %}\n\n# MaxCompute\n\n## MaxCompute的介绍\n\n大数据计算服务\n{% asset_img 2018-09-28-17-32-48.png [blog.ruanxinyu.cn] %}\n\n对象\n{% asset_img 2018-09-28-17-33-43.png [blog.ruanxinyu.cn] %}\n\n分区\n{% asset_img 2018-09-28-17-36-13.png [blog.ruanxinyu.cn] %}\n\n分区表\n{% asset_img 2018-09-28-17-36-38.png [blog.ruanxinyu.cn] %}\n\n分区举例\n{% asset_img 2018-09-28-17-39-09.png [blog.ruanxinyu.cn] %}\n\n其他概念， 执行sql都是task，是异步的\n{% asset_img 2018-09-28-17-40-15.png [blog.ruanxinyu.cn] %}\n\n数据类型\n{% asset_img 2018-09-28-17-41-46.png [blog.ruanxinyu.cn] %}\n\n阿里小贷\n{% asset_img 2018-09-28-17-42-31.png [blog.ruanxinyu.cn] %}\n\n大数据架构\n{% asset_img 2018-09-28-17-43-11.png [blog.ruanxinyu.cn] %}\n\n## MaxCompute的架构介绍\n\n客户端\n{% asset_img 2018-09-28-20-04-58.png [blog.ruanxinyu.cn] %}\n\n逻辑层\n{% asset_img 2018-09-28-20-08-24.png [blog.ruanxinyu.cn] %}\n\n计算层\n{% asset_img 2018-09-28-20-09-02.png [blog.ruanxinyu.cn] %}\n\n数据上传\n{% asset_img 2018-09-29-09-16-43.png [blog.ruanxinyu.cn] %}\n\n数据下载\n{% asset_img 2018-09-29-09-17-42.png [blog.ruanxinyu.cn] %}\n\n参数\n{% asset_img 2018-09-29-09-19-12.png [blog.ruanxinyu.cn] %}\n\n分隔符\n{% asset_img 2018-09-29-09-19-31.png [blog.ruanxinyu.cn] %}\n\n## DDL的介绍\n\n创建表\n{% asset_img 2018-09-29-09-23-24.png [blog.ruanxinyu.cn] %}\n\n表的生命周期，比如用来保持最近7天的数据\n{% asset_img 2018-09-29-09-26-16.png [blog.ruanxinyu.cn] %}\n\n快捷建表\n{% asset_img 2018-09-29-09-27-31.png [blog.ruanxinyu.cn] %}\n\n分区操作\n{% asset_img 2018-09-29-09-28-17.png [blog.ruanxinyu.cn] %}\n\n修改表属性\n{% asset_img 2018-09-29-09-29-08.png [blog.ruanxinyu.cn] %}\n\n视图操作\n{% asset_img 2018-09-29-09-29-42.png [blog.ruanxinyu.cn] %}\n\n## DML的介绍\n\n查询操作\n{% asset_img 2018-09-29-09-32-11.png [blog.ruanxinyu.cn] %}\n\n更新数据\n{% asset_img 2018-09-29-09-35-05.png [blog.ruanxinyu.cn] %}\n\n多路输出\n{% asset_img 2018-09-29-09-36-03.png [blog.ruanxinyu.cn] %}\n\n表关联\n{% asset_img 2018-09-29-09-37-37.png [blog.ruanxinyu.cn] %}\n\nMapJoin\n{% asset_img 2018-09-29-09-37-58.png [blog.ruanxinyu.cn] %}\n\nMapJoin举例\n{% asset_img 2018-09-29-09-38-17.png [blog.ruanxinyu.cn] %}\n\n分支表达式\n{% asset_img 2018-09-29-09-39-59.png [blog.ruanxinyu.cn] %}\n\n## 内置函数\n\n数学运算函数-1\n{% asset_img 2018-09-29-09-48-23.png [blog.ruanxinyu.cn] %}\n\n数学运算函数-2\n{% asset_img 2018-09-29-09-49-29.png [blog.ruanxinyu.cn] %}\n\n字符串处理函数\n{% asset_img 2018-09-29-09-49-48.png [blog.ruanxinyu.cn] %}\n\n日期类型处理函数\n{% asset_img 2018-09-29-09-57-01.png [blog.ruanxinyu.cn] %}\n\n窗口函数\n{% asset_img 2018-09-29-09-57-16.png [blog.ruanxinyu.cn] %}\n\n聚合函数\n{% asset_img 2018-09-29-09-57-50.png [blog.ruanxinyu.cn] %}\n\n其他函数\n{% asset_img 2018-09-29-09-58-28.png [blog.ruanxinyu.cn] %}\n\n## 其他使用方式\n\n自定义函数\n{% asset_img 2018-09-29-09-59-23.png [blog.ruanxinyu.cn] %}\n\nUDF开发流程\n{% asset_img 2018-09-29-10-01-12.png [blog.ruanxinyu.cn] %}\n\nMapReduce介绍\n{% asset_img 2018-09-29-10-02-44.png [blog.ruanxinyu.cn] %}\n\nMR框架\n{% asset_img 2018-09-29-10-04-46.png [blog.ruanxinyu.cn] %}\n\nGraph\n{% asset_img 2018-09-29-10-05-25.png [blog.ruanxinyu.cn] %}\n\n如何使用合适的方式\n{% asset_img 2018-09-29-10-06-11.png [blog.ruanxinyu.cn] %}\n\n## 授权\n\n授权\n{% asset_img 2018-09-29-10-08-40.png [blog.ruanxinyu.cn] %}\n\n添加用户授权\n{% asset_img 2018-09-29-10-28-41.png [blog.ruanxinyu.cn] %}\n\n角色管理\n{% asset_img 2018-09-29-10-29-26.png [blog.ruanxinyu.cn] %}\n\n# DataIDE\n\n## DataIDE介绍\n\n产品概述\n{% asset_img 2018-09-29-10-35-23.png [blog.ruanxinyu.cn] %}\n\n开发流程-1\n{% asset_img 2018-09-29-10-36-04.png [blog.ruanxinyu.cn] %}\n\n开发流程-2\n{% asset_img 2018-09-29-10-36-24.png [blog.ruanxinyu.cn] %}\n\n应用场景\n{% asset_img 2018-09-29-10-37-36.png [blog.ruanxinyu.cn] %}\n\n## DataIDE基本概念\n\n概念\n{% asset_img 2018-09-29-10-39-19.png [blog.ruanxinyu.cn] %}\n\n角色\n{% asset_img 2018-09-29-10-43-11.png [blog.ruanxinyu.cn] %}\n\n多环境\n{% asset_img 2018-09-29-10-45-07.png [blog.ruanxinyu.cn] %}\n\n## 数据集成\n\n数据集成支持两种开发模式\n{% asset_img 2018-10-11-15-25-52.png [blog.ruanxinyu.cn] %}\n\n向导模式：选择来源\n{% asset_img 2018-10-11-15-26-45.png [blog.ruanxinyu.cn] %}\n\n一键生成数据表\n{% asset_img 2018-10-11-15-27-31.png [blog.ruanxinyu.cn] %}\n\n向导模式：选择目标\n{% asset_img 2018-10-11-15-27-56.png [blog.ruanxinyu.cn] %}\n\n向导模式：字段映射\n{% asset_img 2018-10-11-15-28-34.png [blog.ruanxinyu.cn] %}\n\n脚本模式：\n{% asset_img 2018-10-11-15-31-05.png [blog.ruanxinyu.cn] %}\n\n## 数据开发\n\n### 脚本开发\n\n提供参数配置\n{% asset_img 2018-10-11-15-34-28.png [blog.ruanxinyu.cn] %}\n\n执行脚本之前会提示费用情况\n{% asset_img 2018-10-11-14-47-16.png [blog.ruanxinyu.cn] %}\n\n### 任务：节点任务\n\n支持调度，依赖管理，版本管理和参数配置\n{% asset_img 2018-10-11-15-38-08.png [blog.ruanxinyu.cn] %}\n\n### 工作流任务\n\n支持编排\n{% asset_img 2018-10-11-15-40-47.png [blog.ruanxinyu.cn] %}\n\n## 数据管理\n\n{% asset_img 2018-09-29-11-08-19.png [blog.ruanxinyu.cn] %}\n\n数据表的信息在数据管理服务\n{% asset_img 2018-10-11-15-21-48.png [blog.ruanxinyu.cn] %}\n\n数据表的创建支持DDL和图像化两个模式\n{% asset_img 2018-10-11-15-36-06.png [blog.ruanxinyu.cn] %}\n\n## 运维中心\n\n介绍\n{% asset_img 2018-10-11-16-06-43.png [blog.ruanxinyu.cn] %}\n\n任务管理\n{% asset_img 2018-09-29-11-09-04.png [blog.ruanxinyu.cn] %}\n\n## 项目管理\n\n{% asset_img 2018-09-29-11-10-24.png [blog.ruanxinyu.cn] %}\n\n# QuickBI报表\n\n## QuickBI的介绍\n\n产品概述\n{% asset_img 2018-09-29-14-41-54.png [blog.ruanxinyu.cn] %}\n\n产品架构\n{% asset_img 2018-09-29-14-42-18.png [blog.ruanxinyu.cn] %}\n\n角色定位\n{% asset_img 2018-09-29-14-44-45.png [blog.ruanxinyu.cn] %}\n\n常见应用步骤\n{% asset_img 2018-09-29-14-45-39.png [blog.ruanxinyu.cn] %}\n\n## QuickBI的数据管理\n\n数据源管理\n{% asset_img 2018-09-29-14-46-51.png [blog.ruanxinyu.cn] %}\n\n数据集管理\n{% asset_img 2018-09-29-14-51-55.png [blog.ruanxinyu.cn] %}\n\n首页\n{% asset_img 2018-09-29-15-03-22.png [blog.ruanxinyu.cn] %}\n\n新建数据源\n{% asset_img 2018-09-29-15-03-47.png [blog.ruanxinyu.cn] %}\n\n表格分析\n{% asset_img 2018-09-29-15-10-44.png [blog.ruanxinyu.cn] %}\n\n图表与门户-常见图标\n{% asset_img 2018-09-29-15-12-25.png [blog.ruanxinyu.cn] %}\n\n图表\n{% asset_img 2018-09-29-15-16-14.png [blog.ruanxinyu.cn] %}\n\n门户\n{% asset_img 2018-09-29-15-17-19.png [blog.ruanxinyu.cn] %}\n\n# DataV数据大屏\n\n## 产品介绍\n\n产品概述\n{% asset_img 2018-09-29-15-22-00.png [blog.ruanxinyu.cn] %}\n\n特性1：多重场景模板\n{% asset_img 2018-09-29-15-22-47.png [blog.ruanxinyu.cn] %}\n\n特性2：丰富开放的图表库\n{% asset_img 2018-09-29-15-23-21.png [blog.ruanxinyu.cn] %}\n\n特性3：支持多种数据源\n{% asset_img 2018-09-29-15-24-21.png [blog.ruanxinyu.cn] %}\n\n特性4：零门槛图形化界面设计\n{% asset_img 2018-09-29-15-25-13.png [blog.ruanxinyu.cn] %}\n\n特性5，支持数据交互分析\n{% asset_img 2018-09-29-15-26-53.png [blog.ruanxinyu.cn] %}\n\n特性6：支持适配与发布方式\n{% asset_img 2018-09-29-15-26-17.png [blog.ruanxinyu.cn] %}\n\n## DataV大屏介绍\n\n展示类大屏\n{% asset_img 2018-09-29-15-29-42.png [blog.ruanxinyu.cn] %}\n\n展示类大屏示例\n{% asset_img 2018-09-29-15-30-22.png [blog.ruanxinyu.cn] %}\n\n分析类大屏\n{% asset_img 2018-09-29-15-30-51.png [blog.ruanxinyu.cn] %}\n\n分析类大屏示例\n{% asset_img 2018-09-29-15-31-18.png [blog.ruanxinyu.cn] %}\n\n监控类大屏\n{% asset_img 2018-09-29-15-31-39.png [blog.ruanxinyu.cn] %}\n\n监控类大屏示例\n{% asset_img 2018-09-29-15-32-12.png [blog.ruanxinyu.cn] %}\n\n可视化大屏设计原则\n{% asset_img 2018-09-29-15-33-01.png [blog.ruanxinyu.cn] %}\n\n大屏样例1\n{% asset_img 2018-09-29-15-33-33.png [blog.ruanxinyu.cn] %}\n\n大屏样例2\n{% asset_img 2018-09-29-15-36-21.png [blog.ruanxinyu.cn] %}\n\n## DataV演示\n\n添加数据\n{% asset_img 2018-09-29-15-38-15.png [blog.ruanxinyu.cn] %}\n\n视频和样例\n{% asset_img 2018-09-29-15-38-33.png [blog.ruanxinyu.cn] %}\n\n创建大屏-1\n{% asset_img 2018-09-29-15-39-16.png [blog.ruanxinyu.cn] %}\n\n创建大屏-2\n{% asset_img 2018-09-29-15-39-37.png [blog.ruanxinyu.cn] %}","content":"<h1 id=\"大数据概述\"><a href=\"#大数据概述\" class=\"headerlink\" title=\"大数据概述\"></a>大数据概述</h1><p>大数据，指无法在可承受的时间范围内用常规软件工具进行捕捉，管理和处理的数据集合，是需要新处理模式才能具有更强的决策力，洞察发现力和流程优化能力的海量，高增长率和多样化的信息资产。</p>\n<p>大数据的主要特征：4V<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-15-39-47.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<img src=\"/posts/阿里ACA认证学习记录/2018-09-28-15-40-26.png\" title=\"[blog.ruanxinyu.cn]\">\n<p>数据分析流程<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-15-41-31.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>Hadoop生态圈<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-15-43-04.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>阿里云大数据体系<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-15-43-42.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>数加的定位<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-15-44-21.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>统一的大数据计算平台<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-15-45-11.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h1 id=\"分析型数据库\"><a href=\"#分析型数据库\" class=\"headerlink\" title=\"分析型数据库\"></a>分析型数据库</h1><h2 id=\"分析型数据库的介绍\"><a href=\"#分析型数据库的介绍\" class=\"headerlink\" title=\"分析型数据库的介绍\"></a>分析型数据库的介绍</h2><p>OLAP，OLTP，维度和度量，下钻，下图中时间，地区和产品就是维度，而销量和金额就是度量<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-15-47-20.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>MPP（大规模并行处理， Massive Parallel Processing）<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-15-49-23.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>分析型数据库：高并发在线分析（Realtime OLAP），与关系型数据库的区别是分析型数据库没有事务，是专门用于分析的，支持sql语句，但是跟关系型数据库没有什么关系<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-15-55-17.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<img src=\"/posts/阿里ACA认证学习记录/2018-09-28-15-57-34.png\" title=\"[blog.ruanxinyu.cn]\">\n<h2 id=\"分析型数据库的基本概念\"><a href=\"#分析型数据库的基本概念\" class=\"headerlink\" title=\"分析型数据库的基本概念\"></a>分析型数据库的基本概念</h2><p>表组<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-16-13-05.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>表组的特点<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-16-55-30.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>维表的特点，以空间换时间<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-16-56-14.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>事实表的特点<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-16-57-32.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>数据类型<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-17-01-14.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>多值列，不满足3范式，性能明显优于join<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-17-02-03.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<img src=\"/posts/阿里ACA认证学习记录/2018-09-28-17-05-08.png\" title=\"[blog.ruanxinyu.cn]\">\n<h2 id=\"分析型数据库的基本操作\"><a href=\"#分析型数据库的基本操作\" class=\"headerlink\" title=\"分析型数据库的基本操作\"></a>分析型数据库的基本操作</h2><p>DMS在表组中新建表<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-17-17-52.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h1 id=\"MaxCompute\"><a href=\"#MaxCompute\" class=\"headerlink\" title=\"MaxCompute\"></a>MaxCompute</h1><h2 id=\"MaxCompute的介绍\"><a href=\"#MaxCompute的介绍\" class=\"headerlink\" title=\"MaxCompute的介绍\"></a>MaxCompute的介绍</h2><p>大数据计算服务<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-17-32-48.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>对象<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-17-33-43.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>分区<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-17-36-13.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>分区表<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-17-36-38.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>分区举例<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-17-39-09.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>其他概念， 执行sql都是task，是异步的<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-17-40-15.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>数据类型<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-17-41-46.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>阿里小贷<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-17-42-31.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>大数据架构<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-17-43-11.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"MaxCompute的架构介绍\"><a href=\"#MaxCompute的架构介绍\" class=\"headerlink\" title=\"MaxCompute的架构介绍\"></a>MaxCompute的架构介绍</h2><p>客户端<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-20-04-58.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>逻辑层<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-20-08-24.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>计算层<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-28-20-09-02.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>数据上传<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-16-43.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>数据下载<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-17-42.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>参数<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-19-12.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>分隔符<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-19-31.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"DDL的介绍\"><a href=\"#DDL的介绍\" class=\"headerlink\" title=\"DDL的介绍\"></a>DDL的介绍</h2><p>创建表<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-23-24.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>表的生命周期，比如用来保持最近7天的数据<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-26-16.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>快捷建表<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-27-31.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>分区操作<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-28-17.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>修改表属性<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-29-08.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>视图操作<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-29-42.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"DML的介绍\"><a href=\"#DML的介绍\" class=\"headerlink\" title=\"DML的介绍\"></a>DML的介绍</h2><p>查询操作<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-32-11.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>更新数据<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-35-05.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>多路输出<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-36-03.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>表关联<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-37-37.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>MapJoin<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-37-58.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>MapJoin举例<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-38-17.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>分支表达式<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-39-59.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"内置函数\"><a href=\"#内置函数\" class=\"headerlink\" title=\"内置函数\"></a>内置函数</h2><p>数学运算函数-1<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-48-23.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>数学运算函数-2<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-49-29.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>字符串处理函数<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-49-48.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>日期类型处理函数<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-57-01.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>窗口函数<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-57-16.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>聚合函数<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-57-50.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>其他函数<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-58-28.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"其他使用方式\"><a href=\"#其他使用方式\" class=\"headerlink\" title=\"其他使用方式\"></a>其他使用方式</h2><p>自定义函数<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-09-59-23.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>UDF开发流程<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-10-01-12.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>MapReduce介绍<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-10-02-44.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>MR框架<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-10-04-46.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>Graph<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-10-05-25.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>如何使用合适的方式<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-10-06-11.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"授权\"><a href=\"#授权\" class=\"headerlink\" title=\"授权\"></a>授权</h2><p>授权<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-10-08-40.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>添加用户授权<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-10-28-41.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>角色管理<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-10-29-26.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h1 id=\"DataIDE\"><a href=\"#DataIDE\" class=\"headerlink\" title=\"DataIDE\"></a>DataIDE</h1><h2 id=\"DataIDE介绍\"><a href=\"#DataIDE介绍\" class=\"headerlink\" title=\"DataIDE介绍\"></a>DataIDE介绍</h2><p>产品概述<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-10-35-23.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>开发流程-1<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-10-36-04.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>开发流程-2<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-10-36-24.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>应用场景<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-10-37-36.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"DataIDE基本概念\"><a href=\"#DataIDE基本概念\" class=\"headerlink\" title=\"DataIDE基本概念\"></a>DataIDE基本概念</h2><p>概念<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-10-39-19.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>角色<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-10-43-11.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>多环境<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-10-45-07.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"数据集成\"><a href=\"#数据集成\" class=\"headerlink\" title=\"数据集成\"></a>数据集成</h2><p>数据集成支持两种开发模式<br><img src=\"/posts/阿里ACA认证学习记录/2018-10-11-15-25-52.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>向导模式：选择来源<br><img src=\"/posts/阿里ACA认证学习记录/2018-10-11-15-26-45.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>一键生成数据表<br><img src=\"/posts/阿里ACA认证学习记录/2018-10-11-15-27-31.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>向导模式：选择目标<br><img src=\"/posts/阿里ACA认证学习记录/2018-10-11-15-27-56.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>向导模式：字段映射<br><img src=\"/posts/阿里ACA认证学习记录/2018-10-11-15-28-34.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>脚本模式：<br><img src=\"/posts/阿里ACA认证学习记录/2018-10-11-15-31-05.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"数据开发\"><a href=\"#数据开发\" class=\"headerlink\" title=\"数据开发\"></a>数据开发</h2><h3 id=\"脚本开发\"><a href=\"#脚本开发\" class=\"headerlink\" title=\"脚本开发\"></a>脚本开发</h3><p>提供参数配置<br><img src=\"/posts/阿里ACA认证学习记录/2018-10-11-15-34-28.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>执行脚本之前会提示费用情况<br><img src=\"/posts/阿里ACA认证学习记录/2018-10-11-14-47-16.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h3 id=\"任务：节点任务\"><a href=\"#任务：节点任务\" class=\"headerlink\" title=\"任务：节点任务\"></a>任务：节点任务</h3><p>支持调度，依赖管理，版本管理和参数配置<br><img src=\"/posts/阿里ACA认证学习记录/2018-10-11-15-38-08.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h3 id=\"工作流任务\"><a href=\"#工作流任务\" class=\"headerlink\" title=\"工作流任务\"></a>工作流任务</h3><p>支持编排<br><img src=\"/posts/阿里ACA认证学习记录/2018-10-11-15-40-47.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"数据管理\"><a href=\"#数据管理\" class=\"headerlink\" title=\"数据管理\"></a>数据管理</h2><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-11-08-19.png\" title=\"[blog.ruanxinyu.cn]\">\n<p>数据表的信息在数据管理服务<br><img src=\"/posts/阿里ACA认证学习记录/2018-10-11-15-21-48.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>数据表的创建支持DDL和图像化两个模式<br><img src=\"/posts/阿里ACA认证学习记录/2018-10-11-15-36-06.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"运维中心\"><a href=\"#运维中心\" class=\"headerlink\" title=\"运维中心\"></a>运维中心</h2><p>介绍<br><img src=\"/posts/阿里ACA认证学习记录/2018-10-11-16-06-43.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>任务管理<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-11-09-04.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"项目管理\"><a href=\"#项目管理\" class=\"headerlink\" title=\"项目管理\"></a>项目管理</h2><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-11-10-24.png\" title=\"[blog.ruanxinyu.cn]\">\n<h1 id=\"QuickBI报表\"><a href=\"#QuickBI报表\" class=\"headerlink\" title=\"QuickBI报表\"></a>QuickBI报表</h1><h2 id=\"QuickBI的介绍\"><a href=\"#QuickBI的介绍\" class=\"headerlink\" title=\"QuickBI的介绍\"></a>QuickBI的介绍</h2><p>产品概述<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-14-41-54.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>产品架构<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-14-42-18.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>角色定位<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-14-44-45.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>常见应用步骤<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-14-45-39.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"QuickBI的数据管理\"><a href=\"#QuickBI的数据管理\" class=\"headerlink\" title=\"QuickBI的数据管理\"></a>QuickBI的数据管理</h2><p>数据源管理<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-14-46-51.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>数据集管理<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-14-51-55.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>首页<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-03-22.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>新建数据源<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-03-47.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>表格分析<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-10-44.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>图表与门户-常见图标<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-12-25.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>图表<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-16-14.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>门户<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-17-19.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h1 id=\"DataV数据大屏\"><a href=\"#DataV数据大屏\" class=\"headerlink\" title=\"DataV数据大屏\"></a>DataV数据大屏</h1><h2 id=\"产品介绍\"><a href=\"#产品介绍\" class=\"headerlink\" title=\"产品介绍\"></a>产品介绍</h2><p>产品概述<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-22-00.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>特性1：多重场景模板<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-22-47.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>特性2：丰富开放的图表库<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-23-21.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>特性3：支持多种数据源<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-24-21.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>特性4：零门槛图形化界面设计<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-25-13.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>特性5，支持数据交互分析<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-26-53.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>特性6：支持适配与发布方式<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-26-17.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"DataV大屏介绍\"><a href=\"#DataV大屏介绍\" class=\"headerlink\" title=\"DataV大屏介绍\"></a>DataV大屏介绍</h2><p>展示类大屏<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-29-42.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>展示类大屏示例<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-30-22.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>分析类大屏<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-30-51.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>分析类大屏示例<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-31-18.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>监控类大屏<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-31-39.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>监控类大屏示例<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-32-12.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>可视化大屏设计原则<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-33-01.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>大屏样例1<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-33-33.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>大屏样例2<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-36-21.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"DataV演示\"><a href=\"#DataV演示\" class=\"headerlink\" title=\"DataV演示\"></a>DataV演示</h2><p>添加数据<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-38-15.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>视频和样例<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-38-33.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>创建大屏-1<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-39-16.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>创建大屏-2<br><img src=\"/posts/阿里ACA认证学习记录/2018-09-29-15-39-37.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://ruanxinyu.github.io/categories/学习记录/"}],"tags":[{"name":"大数据 学习记录","slug":"大数据-学习记录","permalink":"http://ruanxinyu.github.io/tags/大数据-学习记录/"}]},{"title":"Ubuntu下搭建HAProxy+KeepAlived高可用集群","slug":"Ubuntu下搭建HAProxy-KeepAlived高可用集群","date":"un55fin55","updated":"un22fin22","comments":true,"path":"posts/Ubuntu下搭建HAProxy-KeepAlived高可用集群/","link":"","permalink":"http://ruanxinyu.github.io/posts/Ubuntu下搭建HAProxy-KeepAlived高可用集群/","excerpt":"","keywords":"","text":"环境说明本次教程搭建的架构图如下所示，通过KeepAlived实现HAProxy的高可用，通过HAProxy实现后端服务器App01和App02的高可用和负载均衡。HAPrxoy有两台，分别为192.168.1.102和192.168.1.103，VIP为192.168.1.104，通过8081端口访问App01的两台机器，通过8082端口访问App02的两台机器。 本教程使用Ubuntu 18.04.01系统，同时需要安装KeepAlived和HAProxy，相关的教程请参考： VirtualBox安装Ubuntu教程 Ubuntu下KeepAlived的安装与配置 Ubuntu下HAProxy的安装与配置 HAProxy的配置两台HAProxy的配置是相同的，通过8081端口访问App01的两台机器，通过8082端口访问App02的两台机器。为了简化配置过程，还是采用最简化的配置，如下所示： 12345678910111213141516171819202122232425262728293031global daemon # 配置为后台启动defaults mode http timeout connect 30s # 连接超时 timeout client 30s # 客户端超时 timeout server 30s # 服务器超时###########################################################frontend app01 bind *:8081 # 绑定端口 default_backend app01_backend # 默认的backend的名称backend app01_backend server web1 192.168.1.106:80 # 设置后端服务器 server web1 192.168.1.108:80 # 设置后端服务器###########################################################frontend app02 bind *:8082 # 绑定端口 default_backend app02_backend # 默认的backend的名称backend app02_backend server web1 192.168.1.107:80 # 设置后端服务器 server web1 192.168.1.109:80 # 设置后端服务器###########################################################listen stats bind *:8083 # 设置监控组的名称 stats refresh 30s # 统计页面自动刷新时间 stats uri /stats # 统计页面url KeepAlived的配置KeepAlived与HAProxy是在相同机器上，IP地址分别为主机haproxy_vm01（192.168.1.102）和备机haproxy_vm02（192.168.1.103）， VIP为192.168.1.104。因为KeepAlived是主备的，因此两台机器的配置是不一样的。 主机haproxy_vm01（192.168.1.102）的配置如下： 12345678910111213141516171819vrrp_script chk_service_ok &#123; script \"killall -0 haproxy\" interval 2&#125;vrrp_instance VI_1 &#123; interface enp0s3 state MASTER virtual_router_id 51 priority 100 virtual_ipaddress &#123; 192.168.1.104/25 &#125; track_script &#123; chk_service_ok &#125;&#125; 备机haproxy_vm02（192.168.1.103）的配置如下，相对于haproxy_vm01，只修改state和priority: 12345678910111213141516171819vrrp_script chk_service_ok &#123; script \"killall -0 haproxy\" interval 2&#125;vrrp_instance VI_1 &#123; interface enp0s3 state BACKUP virtual_router_id 51 priority 80 virtual_ipaddress &#123; 192.168.1.104/25 &#125; track_script &#123; chk_service_ok &#125;&#125; 通过上述配置可以看到，检查haproxy是否可用使用的是killall -0 haproxy命令来判断haproxy的进程是否存在。 App服务的配置我们后台采用apache，首先在每一台后台机器安装apache，我们使用Apache服务器来模拟HAProxy后端的服务器，sudo apt-get install apache2。 为了区分App01和App02，我们做如下操作： 在App01的两台机器执行sudo sh -c &#39;echo &quot;This is apache server 01&quot; &gt; /var/www/html/index.html&#39; 在App02的两台机器执行sudo sh -c &#39;echo &quot;This is apache server 02&quot; &gt; /var/www/html/index.html&#39; 高可用功能验证分别重新启动KeepAlived（sudo systemctl restart keepalived）和HAProxy（sudo systemctl restart haproxy）, 在HAProxy的两台机器上通过ip a命令，可以看到VIP（192.168.1.104）在haproxy_vm01（192.168.1.102）上. 通过VIP访问8081和8082端口，可以发现能够正常访问到后台的服务器，如下所示，此时我们关闭haproxy_vm01（192.168.1.102）上的HAproxy进程sudo killall haproxy，通过ip a可以看到VIP已经漂移到haproxy_vm02（192.168.1.103）上，但是通过VIP访问8081和8082端口，业务仍旧是正常的，说明HAProxy是高可用的。 我们关闭App01_vm01（192.168.1.106)，然后通过VIP访问8081端口，依旧可以正常访问，说明HAProxy已经保证后端App的高可用。","raw":"---\ntitle: Ubuntu下搭建HAProxy+KeepAlived高可用集群\ntags: 环境搭建\ncategories: 环境搭建\ndate: 2018-09-28 10:48:23\n---\n\n# 环境说明\n\n本次教程搭建的架构图如下所示，通过KeepAlived实现HAProxy的高可用，通过HAProxy实现后端服务器App01和App02的高可用和负载均衡。HAPrxoy有两台，分别为`192.168.1.102`和`192.168.1.103`，VIP为`192.168.1.104`，通过`8081`端口访问App01的两台机器，通过`8082`端口访问App02的两台机器。\n{% asset_img 2018-10-01-22-23-16.png [blog.ruanxinyu.cn] %}\n\n本教程使用Ubuntu 18.04.01系统，同时需要安装KeepAlived和HAProxy，相关的教程请参考：\n\n1. {% post_link VirtualBox安装Ubuntu教程 %}\n1. {% post_link Ubuntu下KeepAlived的安装与配置 %}\n1. {% post_link Ubuntu下HAProxy的安装与配置 %}\n\n# HAProxy的配置\n\n两台HAProxy的配置是相同的，通过`8081`端口访问App01的两台机器，通过`8082`端口访问App02的两台机器。为了简化配置过程，还是采用最简化的配置，如下所示：\n\n```bash\nglobal\n    daemon                          # 配置为后台启动\ndefaults\n    mode http\n    timeout connect 30s             # 连接超时\n    timeout client 30s              # 客户端超时\n    timeout server 30s              # 服务器超时\n\n###########################################################\nfrontend app01\n    bind *:8081                     # 绑定端口\n    default_backend app01_backend   # 默认的backend的名称\n\nbackend app01_backend\n    server web1 192.168.1.106:80    # 设置后端服务器\n    server web1 192.168.1.108:80    # 设置后端服务器\n\n###########################################################\nfrontend app02\n    bind *:8082                     # 绑定端口\n    default_backend app02_backend   # 默认的backend的名称\n\nbackend app02_backend\n    server web1 192.168.1.107:80    # 设置后端服务器\n    server web1 192.168.1.109:80    # 设置后端服务器\n\n###########################################################\nlisten stats\n    bind *:8083                     # 设置监控组的名称\n    stats refresh 30s               # 统计页面自动刷新时间\n    stats uri /stats                # 统计页面url\n```\n\n# KeepAlived的配置\n\nKeepAlived与HAProxy是在相同机器上，IP地址分别为主机haproxy_vm01（`192.168.1.102`）和备机haproxy_vm02（`192.168.1.103`）， VIP为`192.168.1.104`。因为KeepAlived是主备的，因此两台机器的配置是不一样的。\n\n1. 主机haproxy_vm01（`192.168.1.102`）的配置如下：\n\n```bash\nvrrp_script chk_service_ok {\n       script \"killall -0 haproxy\"\n       interval 2\n}\n\nvrrp_instance VI_1 {\n    interface enp0s3\n    state MASTER\n    virtual_router_id 51\n    priority 100\n\n    virtual_ipaddress {\n        192.168.1.104/25\n    }\n\n    track_script {\n       chk_service_ok\n    }\n}\n```\n\n1. 备机haproxy_vm02（`192.168.1.103`）的配置如下，相对于haproxy_vm01，只修改`state`和`priority`:\n\n```bash\nvrrp_script chk_service_ok {\n       script \"killall -0 haproxy\"\n       interval 2\n}\n\nvrrp_instance VI_1 {\n    interface enp0s3\n    state BACKUP\n    virtual_router_id 51\n    priority 80\n\n    virtual_ipaddress {\n        192.168.1.104/25\n    }\n\n    track_script {\n       chk_service_ok\n    }\n}\n```\n\n通过上述配置可以看到，检查haproxy是否可用使用的是`killall -0 haproxy`命令来判断haproxy的进程是否存在。\n\n# App服务的配置\n\n我们后台采用`apache`，首先在每一台后台机器安装apache，我们使用Apache服务器来模拟HAProxy后端的服务器，`sudo apt-get install apache2`。\n\n为了区分App01和App02，我们做如下操作：\n\n1. 在App01的两台机器执行`sudo sh -c 'echo \"This is apache server 01\" > /var/www/html/index.html'`\n1. 在App02的两台机器执行`sudo sh -c 'echo \"This is apache server 02\" > /var/www/html/index.html'`\n\n# 高可用功能验证\n\n分别重新启动KeepAlived（`sudo systemctl restart keepalived`）和HAProxy（`sudo systemctl restart haproxy`）, 在HAProxy的两台机器上通过`ip a`命令，可以看到VIP（`192.168.1.104`）在haproxy_vm01（`192.168.1.102`）上.\n{% asset_img 2018-10-01-22-31-44.png [blog.ruanxinyu.cn] %}\n\n通过VIP访问8081和8082端口，可以发现能够正常访问到后台的服务器，如下所示，此时我们关闭haproxy_vm01（`192.168.1.102`）上的HAproxy进程`sudo killall haproxy`，通过`ip a`可以看到VIP已经漂移到haproxy_vm02（`192.168.1.103`）上，但是通过VIP访问8081和8082端口，业务仍旧是正常的，说明HAProxy是高可用的。\n{% asset_img 2018-10-01-22-29-38.png [blog.ruanxinyu.cn] %}\n\n我们关闭App01_vm01（`192.168.1.106`)，然后通过VIP访问8081端口，依旧可以正常访问，说明HAProxy已经保证后端App的高可用。","content":"<h1 id=\"环境说明\"><a href=\"#环境说明\" class=\"headerlink\" title=\"环境说明\"></a>环境说明</h1><p>本次教程搭建的架构图如下所示，通过KeepAlived实现HAProxy的高可用，通过HAProxy实现后端服务器App01和App02的高可用和负载均衡。HAPrxoy有两台，分别为<code>192.168.1.102</code>和<code>192.168.1.103</code>，VIP为<code>192.168.1.104</code>，通过<code>8081</code>端口访问App01的两台机器，通过<code>8082</code>端口访问App02的两台机器。<br><img src=\"/posts/Ubuntu下搭建HAProxy-KeepAlived高可用集群/2018-10-01-22-23-16.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>本教程使用Ubuntu 18.04.01系统，同时需要安装KeepAlived和HAProxy，相关的教程请参考：</p>\n<ol>\n<li><a href=\"/posts/VirtualBox安装Ubuntu教程/\" title=\"VirtualBox安装Ubuntu教程\">VirtualBox安装Ubuntu教程</a></li>\n<li><a href=\"/posts/Ubuntu下KeepAlived的安装与配置/\" title=\"Ubuntu下KeepAlived的安装与配置\">Ubuntu下KeepAlived的安装与配置</a></li>\n<li><a href=\"/posts/Ubuntu下HAProxy的安装与配置/\" title=\"Ubuntu下HAProxy的安装与配置\">Ubuntu下HAProxy的安装与配置</a>\n</li>\n</ol>\n<h1 id=\"HAProxy的配置\"><a href=\"#HAProxy的配置\" class=\"headerlink\" title=\"HAProxy的配置\"></a>HAProxy的配置</h1><p>两台HAProxy的配置是相同的，通过<code>8081</code>端口访问App01的两台机器，通过<code>8082</code>端口访问App02的两台机器。为了简化配置过程，还是采用最简化的配置，如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">global</span><br><span class=\"line\">    daemon                          <span class=\"comment\"># 配置为后台启动</span></span><br><span class=\"line\">defaults</span><br><span class=\"line\">    mode http</span><br><span class=\"line\">    timeout connect 30s             <span class=\"comment\"># 连接超时</span></span><br><span class=\"line\">    timeout client 30s              <span class=\"comment\"># 客户端超时</span></span><br><span class=\"line\">    timeout server 30s              <span class=\"comment\"># 服务器超时</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###########################################################</span></span><br><span class=\"line\">frontend app01</span><br><span class=\"line\">    <span class=\"built_in\">bind</span> *:8081                     <span class=\"comment\"># 绑定端口</span></span><br><span class=\"line\">    default_backend app01_backend   <span class=\"comment\"># 默认的backend的名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">backend app01_backend</span><br><span class=\"line\">    server web1 192.168.1.106:80    <span class=\"comment\"># 设置后端服务器</span></span><br><span class=\"line\">    server web1 192.168.1.108:80    <span class=\"comment\"># 设置后端服务器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###########################################################</span></span><br><span class=\"line\">frontend app02</span><br><span class=\"line\">    <span class=\"built_in\">bind</span> *:8082                     <span class=\"comment\"># 绑定端口</span></span><br><span class=\"line\">    default_backend app02_backend   <span class=\"comment\"># 默认的backend的名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">backend app02_backend</span><br><span class=\"line\">    server web1 192.168.1.107:80    <span class=\"comment\"># 设置后端服务器</span></span><br><span class=\"line\">    server web1 192.168.1.109:80    <span class=\"comment\"># 设置后端服务器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###########################################################</span></span><br><span class=\"line\">listen stats</span><br><span class=\"line\">    <span class=\"built_in\">bind</span> *:8083                     <span class=\"comment\"># 设置监控组的名称</span></span><br><span class=\"line\">    stats refresh 30s               <span class=\"comment\"># 统计页面自动刷新时间</span></span><br><span class=\"line\">    stats uri /stats                <span class=\"comment\"># 统计页面url</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"KeepAlived的配置\"><a href=\"#KeepAlived的配置\" class=\"headerlink\" title=\"KeepAlived的配置\"></a>KeepAlived的配置</h1><p>KeepAlived与HAProxy是在相同机器上，IP地址分别为主机haproxy_vm01（<code>192.168.1.102</code>）和备机haproxy_vm02（<code>192.168.1.103</code>）， VIP为<code>192.168.1.104</code>。因为KeepAlived是主备的，因此两台机器的配置是不一样的。</p>\n<ol>\n<li>主机haproxy_vm01（<code>192.168.1.102</code>）的配置如下：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vrrp_script chk_service_ok &#123;</span><br><span class=\"line\">       script <span class=\"string\">\"killall -0 haproxy\"</span></span><br><span class=\"line\">       interval 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">vrrp_instance VI_1 &#123;</span><br><span class=\"line\">    interface enp0s3</span><br><span class=\"line\">    state MASTER</span><br><span class=\"line\">    virtual_router_id 51</span><br><span class=\"line\">    priority 100</span><br><span class=\"line\"></span><br><span class=\"line\">    virtual_ipaddress &#123;</span><br><span class=\"line\">        192.168.1.104/25</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    track_script &#123;</span><br><span class=\"line\">       chk_service_ok</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>备机haproxy_vm02（<code>192.168.1.103</code>）的配置如下，相对于haproxy_vm01，只修改<code>state</code>和<code>priority</code>:</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vrrp_script chk_service_ok &#123;</span><br><span class=\"line\">       script <span class=\"string\">\"killall -0 haproxy\"</span></span><br><span class=\"line\">       interval 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">vrrp_instance VI_1 &#123;</span><br><span class=\"line\">    interface enp0s3</span><br><span class=\"line\">    state BACKUP</span><br><span class=\"line\">    virtual_router_id 51</span><br><span class=\"line\">    priority 80</span><br><span class=\"line\"></span><br><span class=\"line\">    virtual_ipaddress &#123;</span><br><span class=\"line\">        192.168.1.104/25</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    track_script &#123;</span><br><span class=\"line\">       chk_service_ok</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上述配置可以看到，检查haproxy是否可用使用的是<code>killall -0 haproxy</code>命令来判断haproxy的进程是否存在。</p>\n<h1 id=\"App服务的配置\"><a href=\"#App服务的配置\" class=\"headerlink\" title=\"App服务的配置\"></a>App服务的配置</h1><p>我们后台采用<code>apache</code>，首先在每一台后台机器安装apache，我们使用Apache服务器来模拟HAProxy后端的服务器，<code>sudo apt-get install apache2</code>。</p>\n<p>为了区分App01和App02，我们做如下操作：</p>\n<ol>\n<li>在App01的两台机器执行<code>sudo sh -c &#39;echo &quot;This is apache server 01&quot; &gt; /var/www/html/index.html&#39;</code></li>\n<li>在App02的两台机器执行<code>sudo sh -c &#39;echo &quot;This is apache server 02&quot; &gt; /var/www/html/index.html&#39;</code></li>\n</ol>\n<h1 id=\"高可用功能验证\"><a href=\"#高可用功能验证\" class=\"headerlink\" title=\"高可用功能验证\"></a>高可用功能验证</h1><p>分别重新启动KeepAlived（<code>sudo systemctl restart keepalived</code>）和HAProxy（<code>sudo systemctl restart haproxy</code>）, 在HAProxy的两台机器上通过<code>ip a</code>命令，可以看到VIP（<code>192.168.1.104</code>）在haproxy_vm01（<code>192.168.1.102</code>）上.<br><img src=\"/posts/Ubuntu下搭建HAProxy-KeepAlived高可用集群/2018-10-01-22-31-44.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>通过VIP访问8081和8082端口，可以发现能够正常访问到后台的服务器，如下所示，此时我们关闭haproxy_vm01（<code>192.168.1.102</code>）上的HAproxy进程<code>sudo killall haproxy</code>，通过<code>ip a</code>可以看到VIP已经漂移到haproxy_vm02（<code>192.168.1.103</code>）上，但是通过VIP访问8081和8082端口，业务仍旧是正常的，说明HAProxy是高可用的。<br><img src=\"/posts/Ubuntu下搭建HAProxy-KeepAlived高可用集群/2018-10-01-22-29-38.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>我们关闭App01_vm01（<code>192.168.1.106</code>)，然后通过VIP访问8081端口，依旧可以正常访问，说明HAProxy已经保证后端App的高可用。</p>\n","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/categories/环境搭建/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/tags/环境搭建/"}]},{"title":"Ubuntu下HAProxy的安装与配置","slug":"Ubuntu下HAProxy的安装与配置","date":"un22fin22","updated":"un00fin00","comments":true,"path":"posts/Ubuntu下HAProxy的安装与配置/","link":"","permalink":"http://ruanxinyu.github.io/posts/Ubuntu下HAProxy的安装与配置/","excerpt":"","keywords":"","text":"HAProxy的简介HAProxy是一款提供高可用性、负载均衡以及基于TCP（第四层）和HTTP（第七层）应用的代理软件，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。 HAProxy实现了一种事件驱动、单一进程模型，此模型支持非常大的并发连接数，特别适用于那些负载特大的web站点，完全可以支持数以万计的并发连接，根据官方文档，haproxy可以跑满10Gbps。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中，同时可以保护你的web服务器不被暴露到网络上。 HAProxy支持全透明代理，可以用客户端IP地址或者任何其他地址来连接后端服务器，同时提供连接拒绝功能，可以有效的限制攻击蠕虫。 HAProxy的安装该教程使用的Ubuntu版本是18.04.1版本，Ubuntu的安装教程参考VirtualBox安装Ubuntu教程。HAProxy可以直接通过apt-get安装，也可以通过源码编译安装。 apt-get安装Ubuntu下执行sudo apt-get install haproxy命令即可安装。 通过which haproxy可以看到haproxy是安装在/usr/sbin/haproxy下，HAProxy的配置文件路径为：/etc/haproxy/haproxy.cfg 使用sudo haproxy -f /etc/haproxy/haproxy.cfg即可启动HAProxy。 源码编译安装源码安装的脚本可以点击此处下载： haproxy_install.sh，下面对安装过程做一下说明。 一般源码安装目录为/usr/local/haproxy，在源码目录中的README文件有安装说明，下面罗列出几点内容： 在执行make命令之前是不需要执行./configure命令的，因此执行的参数都在make命令中指定 我们操作系统为Ubuntu 18.04.1，不涉及嵌入式编译，因此使用TARGET=linux26 ARCH=x86_64参数 PCRE(Perl Compatible Regular Expressions)的速度是其他的2-10倍，因此添加USE_PCRE=1选项，但是前提需要安装libpcre3 libpcre3-dev 为支持HTTPS协议，我们需要添加USE_OPENSSL=1选项，但是前提需要安装libssl-dev 为支持HTTP的压缩功能，我们需要添加USE_ZLIB=1，但是前提需要安装zlib1g-dev 为了保证安装目录为/usr/local/haproxy，我们需要在make install命令中指定PREFIX参数 1234567891011sudo apt-get install build-essential libssl-dev # 安装编译工具和openssl依赖sudo apt-get install zlib1g-devsudo apt-get install libpcre3 libpcre3-devwget https://www.haproxy.org/download/1.8/src/haproxy-1.8.8.tar.gz # 下载源码tar -zxvf haproxy-1.8.8.tar.gz # 解压源码cd haproxy-1.8.8/make TARGET=linux26 ARCH=x86_64 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 # 编译源码，从README中可以看出如何编译sudo make install PREFIX=/usr/local/haproxy # 安装到安装目录，需要使用root权限sudo mkdir -p /etc/haproxysudo cp -a examples/transparent_proxy.cfg /etc/haproxy/haproxy.cfg 启动HAProxy: sudo /usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg 可能遇到的问题 提示make is not found 源码安装需要安装编译器将源码转换为二进制可执行文件，因此执行sudo apt-get install build-essential安装编译器即可 启动时提示parsing [/etc/haproxy/haproxy.cfg:12] : unknown keyword &#39;ca-base&#39; in &#39;global&#39; section 编译haproxy时没有使能openssl的支持，安装libssl-dev并在编译时指定USE_OPENSSL=1选项即可 开机启动方式1：rc.local编辑sudo vim /etc/rc.local, 在最下面添加sudo /usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg语句即可。 方式2：systemctl我们还是采用systemd的方式添加到系统服务，执行如下命令： 123456789101112131415161718192021(cat &lt;&lt;EOF[Unit]Description=HAproxy DaemonAfter=syslog.target network-online.targetWants=network-online.targetConditionFileNotEmpty=/etc/haproxy/haproxy.cfg[Service]Type=forkingKillMode=processExecStart=/usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfgExecReload=/bin/kill -HUP $MAINPID[Install]WantedBy=multi-user.targetEOF) &gt; haproxy.servicesudo cp -a haproxy.service /lib/systemd/system/haproxy.servicesudo ln -s /lib/systemd/system/haproxy.service /etc/systemd/system/multi-user.target.wants/haproxy.service 启动haproxy进程，并设置为开机启动，通过sudo systemctl status haproxy查看状态： 123sudo systemctl start haproxy # 注意： 如果配置文件不正确的话HPAProxy是启动不起来的sudo systemctl status haproxysudo systemctl enable haproxy HAProxy的配置下面我们以一个最简单的用例说明如何配置HAProxy，架构图如下，192.168.1.102上安装有HAProxy, 8081端口转向192.168.1.106服务器，8082端口转向192.168.1.107服务器。因为HAProxy是提供有统计功能的，因此打开该功能，并监听在8083端口。 配置HAProxy编辑sudo vim /etc/haproxy/haproxy.cfg文件，写入如下的内容： 1234567891011121314151617181920212223242526272829global daemon # 配置为后台启动defaults mode http timeout connect 30s # 连接超时 timeout client 30s # 客户端超时 timeout server 30s # 服务器超时###########################################################frontend app01 bind *:8081 # 绑定端口 default_backend app01_backend # 默认的backend的名称backend app01_backend server web1 192.168.1.106:80 # 设置后端服务器###########################################################frontend app02 bind *:8082 # 绑定端口 default_backend app02_backend # 默认的backend的名称backend app02_backend server web1 192.168.1.107:80 # 设置后端服务器###########################################################listen stats bind *:8083 # 设置监控组的名称 stats refresh 30s # 统计页面自动刷新时间 stats uri /stats # 统计页面url 然后执行sudo /usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg启动HAProxy，通过sudo netstat -lntp | grep haproxy，可以看出HAProxy已经监听配置文件中的三个端口： 可能遇到的问题 启动时提示unknown keyword，如下所示： 从错误信息中可以看出keyword前都多了好多空格，说明我们的配置文件没有正确的使用tab键 启动HAProxy后配置文件没有生效 因为之前启动的HAProxy进程没有关闭，可以执行sudo killall haproxy关闭进程。 搭建Apache服务器我们使用Apache服务器来模拟HAProxy后端的服务器，首先分别在192.168.1.106和192.168.1.107两台机器上执行sudo apt-get install apache2，完成后Apache会自动启动并监听80端口，此时在浏览器中访问对应机器，既可以看到Apache2的首页，默认使用的首页文件路径为/var/www/html/index.html。 为了对两台机器做一下区分，我们做如下操作： 在192.168.1.106执行sudo sh -c &#39;echo &quot;This is apache server 01&quot; &gt; /var/www/html/index.html&#39; 在192.168.1.107执行sudo sh -c &#39;echo &quot;This is apache server 02&quot; &gt; /var/www/html/index.html&#39; 此时分别访问http://192.168.1.106/和http://192.168.1.107/可以看到下面的界面： HAProxy的验证此时访问HAProxy（192.168.1.102）的8081和8082可以看到分别访问到后端的192.168.1.106和192.168.1.107的80端口，如下所示，说明HAProxy的功能已经生效。 访问HAProxy的8083端口：http://192.168.1.102:8083/stats，可以看到HAProxy自带的的统计数据页面，如下所示： HAProxy详细配置说明（高级）对于初级使用者可以不必详细掌握所有的配置，只需要在使用的时候能查到即可，因此将说明放置在此处，参数说明来源于https://www.linuxidc.com/Linux/2012-07/65350.htm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149####################全局配置信息###############################参数是进程级的，通常和操作系统（OS）相关#########global maxconn 20480 #默认最大连接数 log 127.0.0.1 local3 #[err warning info debug] chroot /var/haproxy #chroot运行的路径 uid 99 #所属运行的用户uid gid 99 #所属运行的用户组 daemon #以后台形式运行haproxy nbproc 1 #进程数量(可以设置多个进程提高性能) pidfile /var/run/haproxy.pid #haproxy的pid存放路径,启动进程的用户必须有权限访问此文件 ulimit-n 65535 #ulimit的数量限制#####################默认的全局设置########################这些参数可以被利用配置到frontend，backend，listen组件##defaults log global mode http #所处理的类别 (#7层 http;4层tcp ) maxconn 20480 #最大连接数 option httplog #日志类别http日志格式 option httpclose #每次请求完毕后主动关闭http通道 option dontlognull #不记录健康检查的日志信息 option forwardfor #如果后端服务器需要获得客户端真实ip需要配置的参数，可以从Http Header中获得客户端ip option redispatch #serverId对应的服务器挂掉后,强制定向到其他健康的服务器 option abortonclose #当服务器负载很高的时候，自动结束掉当前队列处理比较久的连接 stats refresh 30 #统计页面刷新间隔 retries 3 #3次连接失败就认为服务不可用，也可以通过后面设置 balance roundrobin #默认的负载均衡的方式,轮询方式 # balance source #默认的负载均衡的方式,类似nginx的ip_hash # balance leastconn #默认的负载均衡的方式,最小连接 contimeout 5000 #连接超时 clitimeout 50000 #客户端超时 srvtimeout 50000 #服务器超时 timeout check 2000 #心跳检测超时####################监控页面的设置#######################listen admin_status #Frontend和Backend的组合体,监控组的名称，按需自定义名称 bind 0.0.0.0:65532 #监听端口 mode http #http的7层模式 log 127.0.0.1 local3 err #错误日志记录 stats refresh 5s #每隔5秒自动刷新监控页面 stats uri /admin?stats #监控页面的url stats realm itnihao\\ itnihao #监控页面的提示信息 stats auth admin:admin #监控页面的用户和密码admin,可以设置多个用户名 stats auth admin1:admin1 #监控页面的用户和密码admin1 stats hide-version #隐藏统计页面上的HAproxy版本信息 stats admin if TRUE #手工启用/禁用,后端服务器(haproxy-1.4.9以后版本) rrorfile 403 /etc/haproxy/errorfiles/403.http rrorfile 500 /etc/haproxy/errorfiles/500.http rrorfile 502 /etc/haproxy/errorfiles/502.http rrorfile 503 /etc/haproxy/errorfiles/503.http rrorfile 504 /etc/haproxy/errorfiles/504.http#################HAProxy的日志记录内容设置################### capture request header Host len 40 capture request header Content-Length len 10 capture request header Referer len 200 capture response header Server len 40 capture response header Content-Length len 10 capture response header Cache-Control len 8#######################网站监测listen配置################################此用法主要是监控haproxy后端服务器的监控状态############listen site_status bind 0.0.0.0:1081 #监听端口 mode http #http的7层模式 log 127.0.0.1 local3 err #[err warning info debug] monitor-uri /site_status #网站健康检测URL，用来检测HAProxy管理的网站是否可以用，正常返回200，不正常返回503 acl site_dead nbsrv(server_web) lt 2 #定义网站down时的策略当挂在负载均衡上的指定backend的中有效机器数小于1台时返回true acl site_dead nbsrv(server_blog) lt 2 acl site_dead nbsrv(server_bbs) lt 2 monitor fail if site_dead #当满足策略的时候返回503，网上文档说的是500，实际测试为503 monitor-net 192.168.16.2/32 #来自192.168.16.2的日志信息不会被记录和转发 monitor-net 192.168.16.3/32########frontend配置#################注意，frontend配置里面可以定义多个acl进行匹配操作########frontend http_80_in bind 0.0.0.0:80 #监听端口，即haproxy提供web服务的端口，和lvs的vip端口类似 mode http #http的7层模式 log global #应用全局的日志配置 option httplog #启用http的log option httpclose #每次请求完毕后主动关闭http通道，HA-Proxy不支持keep-alive模式 option forwardfor #如果后端服务器需要获得客户端的真实IP需要配置次参数，将可以从Http Header中获得客户端IP ########acl策略配置############# acl itnihao_web hdr_reg(host) -i ^(www.itnihao.cn|ww1.itnihao.cn)$ #如果请求的域名满足正则表达式中的2个域名返回true -i是忽略大小写 acl itnihao_blog hdr_dom(host) -i blog.itnihao.cn #如果请求的域名满足www.itnihao.cn返回true -i是忽略大小写 #acl itnihao hdr(host) -i itnihao.cn #如果请求的域名满足itnihao.cn返回true -i是忽略大小写 #acl file_req url_sub -i killall= #在请求url中包含killall=，则此控制策略返回true,否则为false #acl dir_req url_dir -i allow #在请求url中存在allow作为部分地址路径，则此控制策略返回true,否则返回false #acl missing_cl hdr_cnt(Content-length) eq 0 #当请求的header中Content-length等于0时返回true########acl策略匹配相应############# #block if missing_cl #当请求中header中Content-length等于0阻止请求返回403 #block if !file_req || dir_req #block表示阻止请求，返回403错误，当前表示如果不满足策略file_req，或者满足策略dir_req，则阻止请求 use_backend server_web if itnihao_web #当满足itnihao_web的策略时使用server_web的backend use_backend server_blog if itnihao_blog #当满足itnihao_blog的策略时使用server_blog的backend #redirect prefix http://blog.itniaho.cn code 301 if itnihao #当访问itnihao.cn的时候，用http的301挑转到http://192.168.16.3 default_backend server_bbs #以上都不满足的时候使用默认server_bbs的backend##########backend的设置###############下面我将设置三组服务器 server_web，server_blog，server_bbs##################backend server_web####################backend server_web mode http #http的7层模式 balance roundrobin #负载均衡的方式，roundrobin平均方式 cookie SERVERID #允许插入serverid到cookie中，serverid后面可以定义 option httpchk GET /index.html #心跳检测的文件 server web1 192.168.16.2:80 cookie web1 check inter 1500 rise 3 fall 3 weight 1 #服务器定义，cookie 1表示serverid为web1，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用， #fall 3是3次失败认为服务器不可用，weight代表权重 server web2 192.168.16.3:80 cookie web2 check inter 1500 rise 3 fall 3 weight 2 #服务器定义，cookie 1表示serverid为web2，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用， #fall 3是3次失败认为服务器不可用，weight代表权重###################backend server_blog######################backend server_blog mode http #http的7层模式 balance roundrobin #负载均衡的方式，roundrobin平均方式 cookie SERVERID #允许插入serverid到cookie中，serverid后面可以定义 option httpchk GET /index.html #心跳检测的文件 server blog1 192.168.16.2:80 cookie blog1 check inter 1500 rise 3 fall 3 weight 1 #服务器定义，cookie 1表示serverid为blog1，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重 server blog2 192.168.16.3:80 cookie blog2 check inter 1500 rise 3 fall 3 weight 2 #服务器定义，cookie 1表示serverid为blog2，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重##################backend server_bbs########################backend server_bbs mode http #http的7层模式 balance roundrobin #负载均衡的方式，roundrobin平均方式 cookie SERVERID #允许插入serverid到cookie中，serverid后面可以定义 option httpchk GET /index.html #心跳检测的文件 server bbs1 192.168.16.2:80 cookie bbs1 check inter 1500 rise 3 fall 3 weight 1 #服务器定义，cookie 1表示serverid为bbs1，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重 server bbs2 192.168.16.3:80 cookie bbs2 check inter 1500 rise 3 fall 3 weight 2 #服务器定义，cookie 1表示serverid为bbs2，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重","raw":"---\ntitle: Ubuntu下HAProxy的安装与配置\ntags: 环境搭建\ncategories: 环境搭建\ndate: 2018-09-25 07:07:50\n---\n\n# HAProxy的简介\n\nHAProxy是一款提供高可用性、负载均衡以及基于TCP（第四层）和HTTP（第七层）应用的代理软件，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。\n\nHAProxy实现了一种事件驱动、单一进程模型，此模型支持非常大的并发连接数，特别适用于那些负载特大的web站点，完全可以支持数以万计的并发连接，根据官方文档，haproxy可以跑满10Gbps。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中，同时可以保护你的web服务器不被暴露到网络上。\n\nHAProxy支持全透明代理，可以用客户端IP地址或者任何其他地址来连接后端服务器，同时提供连接拒绝功能，可以有效的限制攻击蠕虫。\n\n# HAProxy的安装\n\n该教程使用的Ubuntu版本是18.04.1版本，Ubuntu的安装教程参考{% post_link VirtualBox安装Ubuntu教程 %}。HAProxy可以直接通过apt-get安装，也可以通过源码编译安装。\n\n## apt-get安装\n\nUbuntu下执行`sudo apt-get install haproxy`命令即可安装。\n\n通过`which haproxy`可以看到haproxy是安装在`/usr/sbin/haproxy`下，HAProxy的配置文件路径为：`/etc/haproxy/haproxy.cfg`\n\n使用`sudo haproxy -f /etc/haproxy/haproxy.cfg`即可启动HAProxy。\n\n## 源码编译安装\n\n源码安装的脚本可以点击此处下载： {% asset_link haproxy_install.sh haproxy_install.sh %}，下面对安装过程做一下说明。\n\n一般源码安装目录为`/usr/local/haproxy`，在源码目录中的`README`文件有安装说明，下面罗列出几点内容：\n\n1. 在执行make命令之前是不需要执行`./configure`命令的，因此执行的参数都在make命令中指定\n1. 我们操作系统为Ubuntu 18.04.1，不涉及嵌入式编译，因此使用`TARGET=linux26 ARCH=x86_64`参数\n1. PCRE(Perl Compatible Regular Expressions)的速度是其他的2-10倍，因此添加`USE_PCRE=1`选项，但是前提需要安装`libpcre3 libpcre3-dev`\n1. 为支持HTTPS协议，我们需要添加`USE_OPENSSL=1`选项，但是前提需要安装`libssl-dev`\n1. 为支持HTTP的压缩功能，我们需要添加`USE_ZLIB=1`，但是前提需要安装`zlib1g-dev`\n1. 为了保证安装目录为`/usr/local/haproxy`，我们需要在`make install`命令中指定`PREFIX`参数\n\n```bash\nsudo apt-get install build-essential libssl-dev # 安装编译工具和openssl依赖\nsudo apt-get install zlib1g-dev\nsudo apt-get install libpcre3 libpcre3-dev\nwget https://www.haproxy.org/download/1.8/src/haproxy-1.8.8.tar.gz # 下载源码\ntar -zxvf haproxy-1.8.8.tar.gz # 解压源码\ncd haproxy-1.8.8/\nmake TARGET=linux26 ARCH=x86_64 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 # 编译源码，从README中可以看出如何编译\nsudo make install PREFIX=/usr/local/haproxy # 安装到安装目录，需要使用root权限\n\nsudo mkdir -p /etc/haproxy\nsudo cp -a examples/transparent_proxy.cfg /etc/haproxy/haproxy.cfg\n```\n\n启动HAProxy: `sudo /usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg`\n\n**可能遇到的问题**\n\n1. 提示`make is not found`\n> 源码安装需要安装编译器将源码转换为二进制可执行文件，因此执行`sudo apt-get install build-essential`安装编译器即可\n\n1. 启动时提示`parsing [/etc/haproxy/haproxy.cfg:12] : unknown keyword 'ca-base' in 'global' section`\n> 编译haproxy时没有使能openssl的支持，安装`libssl-dev`并在编译时指定`USE_OPENSSL=1`选项即可\n\n## 开机启动\n\n### 方式1：rc.local\n\n编辑`sudo vim /etc/rc.local`, 在最下面添加`sudo /usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg`语句即可。\n\n### 方式2：systemctl\n\n我们还是采用systemd的方式添加到系统服务，执行如下命令：\n\n```bash\n(\ncat <<EOF\n[Unit]\nDescription=HAproxy Daemon\nAfter=syslog.target network-online.target\nWants=network-online.target\nConditionFileNotEmpty=/etc/haproxy/haproxy.cfg\n\n[Service]\nType=forking\nKillMode=process\nExecStart=/usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg\nExecReload=/bin/kill -HUP $MAINPID\n\n[Install]\nWantedBy=multi-user.target\nEOF\n) > haproxy.service\n\nsudo cp -a haproxy.service /lib/systemd/system/haproxy.service\nsudo ln -s /lib/systemd/system/haproxy.service /etc/systemd/system/multi-user.target.wants/haproxy.service\n```\n\n启动haproxy进程，并设置为开机启动，通过`sudo systemctl status haproxy`查看状态：\n\n```bash\nsudo systemctl start haproxy  # 注意： 如果配置文件不正确的话HPAProxy是启动不起来的\nsudo systemctl status haproxy\nsudo systemctl enable haproxy\n```\n\n# HAProxy的配置\n\n下面我们以一个最简单的用例说明如何配置HAProxy，架构图如下，`192.168.1.102`上安装有HAProxy, `8081`端口转向`192.168.1.106`服务器，`8082`端口转向`192.168.1.107`服务器。因为HAProxy是提供有统计功能的，因此打开该功能，并监听在`8083`端口。\n{% asset_img 2018-09-27-22-03-48.png [blog.ruanxinyu.cn] %}\n\n## 配置HAProxy\n\n编辑`sudo vim /etc/haproxy/haproxy.cfg`文件，写入如下的内容：\n\n```bash\nglobal\n    daemon                          # 配置为后台启动\ndefaults\n    mode http\n    timeout connect 30s             # 连接超时\n    timeout client 30s              # 客户端超时\n    timeout server 30s              # 服务器超时\n\n###########################################################\nfrontend app01\n    bind *:8081                     # 绑定端口\n    default_backend app01_backend   # 默认的backend的名称\n\nbackend app01_backend\n    server web1 192.168.1.106:80    # 设置后端服务器\n\n###########################################################\nfrontend app02\n    bind *:8082                     # 绑定端口\n    default_backend app02_backend   # 默认的backend的名称\n\nbackend app02_backend\n    server web1 192.168.1.107:80    # 设置后端服务器\n\n###########################################################\nlisten stats\n    bind *:8083                     # 设置监控组的名称\n    stats refresh 30s               # 统计页面自动刷新时间\n    stats uri /stats                # 统计页面url\n```\n\n然后执行`sudo /usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg`启动HAProxy，通过`sudo netstat -lntp | grep haproxy`，可以看出HAProxy已经监听配置文件中的三个端口：\n{% asset_img 2018-09-26-15-08-13.png [blog.ruanxinyu.cn] %}\n\n**可能遇到的问题**\n\n1. 启动时提示`unknown keyword`，如下所示：\n> 从错误信息中可以看出keyword前都多了好多空格，说明我们的配置文件没有正确的使用tab键\n{% asset_img 2018-09-26-13-22-19.png [blog.ruanxinyu.cn] %}\n\n1. 启动HAProxy后配置文件没有生效\n> 因为之前启动的HAProxy进程没有关闭，可以执行`sudo killall haproxy`关闭进程。\n\n## 搭建Apache服务器\n\n我们使用Apache服务器来模拟HAProxy后端的服务器，首先分别在`192.168.1.106`和`192.168.1.107`两台机器上执行`sudo apt-get install apache2`，完成后Apache会自动启动并监听80端口，此时在浏览器中访问对应机器，既可以看到Apache2的首页，默认使用的首页文件路径为`/var/www/html/index.html`。\n\n为了对两台机器做一下区分，我们做如下操作：\n\n1. 在`192.168.1.106`执行`sudo sh -c 'echo \"This is apache server 01\" > /var/www/html/index.html'`\n1. 在`192.168.1.107`执行`sudo sh -c 'echo \"This is apache server 02\" > /var/www/html/index.html'`\n\n此时分别访问`http://192.168.1.106/`和`http://192.168.1.107/`可以看到下面的界面：\n{% asset_img 2018-09-27-22-18-00.png [blog.ruanxinyu.cn] %}\n\n# HAProxy的验证\n\n此时访问HAProxy（`192.168.1.102`）的`8081`和`8082`可以看到分别访问到后端的`192.168.1.106`和`192.168.1.107`的`80`端口，如下所示，说明HAProxy的功能已经生效。\n{% asset_img 2018-09-27-22-19-32.png [blog.ruanxinyu.cn] %}\n\n访问HAProxy的`8083`端口：`http://192.168.1.102:8083/stats`，可以看到HAProxy自带的的统计数据页面，如下所示：\n{% asset_img 2018-09-27-22-20-09.png [blog.ruanxinyu.cn] %}\n\n# HAProxy详细配置说明（高级）\n\n对于初级使用者可以不必详细掌握所有的配置，只需要在使用的时候能查到即可，因此将说明放置在此处，参数说明来源于`https://www.linuxidc.com/Linux/2012-07/65350.htm`\n\n```bash\n####################全局配置信息########################\n#######参数是进程级的，通常和操作系统（OS）相关#########\nglobal\n  maxconn 20480 #默认最大连接数\n  log 127.0.0.1 local3 #[err warning info debug]\n  chroot /var/haproxy #chroot运行的路径\n  uid 99 #所属运行的用户uid\n  gid 99 #所属运行的用户组\n  daemon #以后台形式运行haproxy\n  nbproc 1 #进程数量(可以设置多个进程提高性能)\n  pidfile /var/run/haproxy.pid #haproxy的pid存放路径,启动进程的用户必须有权限访问此文件\n  ulimit-n 65535 #ulimit的数量限制\n\n#####################默认的全局设置######################\n##这些参数可以被利用配置到frontend，backend，listen组件##\ndefaults\n  log global\n  mode http #所处理的类别 (#7层 http;4层tcp )\n  maxconn 20480 #最大连接数\n  option httplog #日志类别http日志格式\n  option httpclose #每次请求完毕后主动关闭http通道\n  option dontlognull #不记录健康检查的日志信息\n  option forwardfor #如果后端服务器需要获得客户端真实ip需要配置的参数，可以从Http Header中获得客户端ip\n  option redispatch #serverId对应的服务器挂掉后,强制定向到其他健康的服务器\n  option abortonclose #当服务器负载很高的时候，自动结束掉当前队列处理比较久的连接\n  stats refresh 30 #统计页面刷新间隔\n  retries 3 #3次连接失败就认为服务不可用，也可以通过后面设置\n  balance roundrobin #默认的负载均衡的方式,轮询方式\n  # balance source #默认的负载均衡的方式,类似nginx的ip_hash\n  # balance leastconn #默认的负载均衡的方式,最小连接\n  contimeout 5000 #连接超时\n  clitimeout 50000 #客户端超时\n  srvtimeout 50000 #服务器超时\n  timeout check 2000 #心跳检测超时\n\n####################监控页面的设置#######################\nlisten admin_status #Frontend和Backend的组合体,监控组的名称，按需自定义名称\n  bind 0.0.0.0:65532 #监听端口\n  mode http #http的7层模式\n  log 127.0.0.1 local3 err #错误日志记录\n  stats refresh 5s #每隔5秒自动刷新监控页面\n  stats uri /admin?stats #监控页面的url\n  stats realm itnihao\\ itnihao #监控页面的提示信息\n  stats auth admin:admin #监控页面的用户和密码admin,可以设置多个用户名\n  stats auth admin1:admin1 #监控页面的用户和密码admin1\n  stats hide-version #隐藏统计页面上的HAproxy版本信息\n  stats admin if TRUE #手工启用/禁用,后端服务器(haproxy-1.4.9以后版本)\n\n  rrorfile 403 /etc/haproxy/errorfiles/403.http\n  rrorfile 500 /etc/haproxy/errorfiles/500.http\n  rrorfile 502 /etc/haproxy/errorfiles/502.http\n  rrorfile 503 /etc/haproxy/errorfiles/503.http\n  rrorfile 504 /etc/haproxy/errorfiles/504.http\n\n#################HAProxy的日志记录内容设置###################\n  capture request header Host len 40\n  capture request header Content-Length len 10\n  capture request header Referer len 200\n  capture response header Server len 40\n  capture response header Content-Length len 10\n  capture response header Cache-Control len 8\n\n#######################网站监测listen配置#####################\n###########此用法主要是监控haproxy后端服务器的监控状态############\nlisten site_status\n  bind 0.0.0.0:1081 #监听端口\n  mode http #http的7层模式\n  log 127.0.0.1 local3 err #[err warning info debug]\n  monitor-uri /site_status #网站健康检测URL，用来检测HAProxy管理的网站是否可以用，正常返回200，不正常返回503\n  acl site_dead nbsrv(server_web) lt 2 #定义网站down时的策略当挂在负载均衡上的指定backend的中有效机器数小于1台时返回true\n  acl site_dead nbsrv(server_blog) lt 2\n  acl site_dead nbsrv(server_bbs) lt 2\n  monitor fail if site_dead #当满足策略的时候返回503，网上文档说的是500，实际测试为503\n  monitor-net 192.168.16.2/32 #来自192.168.16.2的日志信息不会被记录和转发\n  monitor-net 192.168.16.3/32\n\n########frontend配置############\n#####注意，frontend配置里面可以定义多个acl进行匹配操作########\nfrontend http_80_in\n  bind 0.0.0.0:80 #监听端口，即haproxy提供web服务的端口，和lvs的vip端口类似\n  mode http #http的7层模式\n  log global #应用全局的日志配置\n  option httplog #启用http的log\n  option httpclose #每次请求完毕后主动关闭http通道，HA-Proxy不支持keep-alive模式\n  option forwardfor #如果后端服务器需要获得客户端的真实IP需要配置次参数，将可以从Http Header中获得客户端IP\n  ########acl策略配置#############\n  acl itnihao_web hdr_reg(host) -i ^(www.itnihao.cn|ww1.itnihao.cn)$\n  #如果请求的域名满足正则表达式中的2个域名返回true -i是忽略大小写\n  acl itnihao_blog hdr_dom(host) -i blog.itnihao.cn\n  #如果请求的域名满足www.itnihao.cn返回true -i是忽略大小写\n  #acl itnihao hdr(host) -i itnihao.cn\n  #如果请求的域名满足itnihao.cn返回true -i是忽略大小写\n  #acl file_req url_sub -i killall=\n  #在请求url中包含killall=，则此控制策略返回true,否则为false\n  #acl dir_req url_dir -i allow\n  #在请求url中存在allow作为部分地址路径，则此控制策略返回true,否则返回false\n  #acl missing_cl hdr_cnt(Content-length) eq 0\n  #当请求的header中Content-length等于0时返回true\n\n########acl策略匹配相应#############\n  #block if missing_cl\n  #当请求中header中Content-length等于0阻止请求返回403\n  #block if !file_req || dir_req\n  #block表示阻止请求，返回403错误，当前表示如果不满足策略file_req，或者满足策略dir_req，则阻止请求\n  use_backend server_web if itnihao_web\n  #当满足itnihao_web的策略时使用server_web的backend\n  use_backend server_blog if itnihao_blog\n  #当满足itnihao_blog的策略时使用server_blog的backend\n  #redirect prefix http://blog.itniaho.cn code 301 if itnihao\n  #当访问itnihao.cn的时候，用http的301挑转到http://192.168.16.3\n  default_backend server_bbs\n  #以上都不满足的时候使用默认server_bbs的backend\n\n##########backend的设置##############\n#下面我将设置三组服务器 server_web，server_blog，server_bbs\n##################backend server_web####################\nbackend server_web\n  mode http #http的7层模式\n  balance roundrobin #负载均衡的方式，roundrobin平均方式\n  cookie SERVERID #允许插入serverid到cookie中，serverid后面可以定义\n  option httpchk GET /index.html #心跳检测的文件\n  server web1 192.168.16.2:80 cookie web1 check inter 1500 rise 3 fall 3 weight 1\n  #服务器定义，cookie 1表示serverid为web1，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，\n  #fall 3是3次失败认为服务器不可用，weight代表权重\n  server web2 192.168.16.3:80 cookie web2 check inter 1500 rise 3 fall 3 weight 2\n  #服务器定义，cookie 1表示serverid为web2，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，\n  #fall 3是3次失败认为服务器不可用，weight代表权重\n\n###################backend server_blog######################\nbackend server_blog\n  mode http #http的7层模式\n  balance roundrobin #负载均衡的方式，roundrobin平均方式\n  cookie SERVERID #允许插入serverid到cookie中，serverid后面可以定义\n  option httpchk GET /index.html #心跳检测的文件\n  server blog1 192.168.16.2:80 cookie blog1 check inter 1500 rise 3 fall 3 weight 1\n  #服务器定义，cookie 1表示serverid为blog1，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重\n  server blog2 192.168.16.3:80 cookie blog2 check inter 1500 rise 3 fall 3 weight 2\n  #服务器定义，cookie 1表示serverid为blog2，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重\n\n##################backend server_bbs########################\nbackend server_bbs\n  mode http #http的7层模式\n  balance roundrobin #负载均衡的方式，roundrobin平均方式\n  cookie SERVERID #允许插入serverid到cookie中，serverid后面可以定义\n  option httpchk GET /index.html #心跳检测的文件\n  server bbs1 192.168.16.2:80 cookie bbs1 check inter 1500 rise 3 fall 3 weight 1\n  #服务器定义，cookie 1表示serverid为bbs1，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重\n  server bbs2 192.168.16.3:80 cookie bbs2 check inter 1500 rise 3 fall 3 weight 2\n  #服务器定义，cookie 1表示serverid为bbs2，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重\n```","content":"<h1 id=\"HAProxy的简介\"><a href=\"#HAProxy的简介\" class=\"headerlink\" title=\"HAProxy的简介\"></a>HAProxy的简介</h1><p>HAProxy是一款提供高可用性、负载均衡以及基于TCP（第四层）和HTTP（第七层）应用的代理软件，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。</p>\n<p>HAProxy实现了一种事件驱动、单一进程模型，此模型支持非常大的并发连接数，特别适用于那些负载特大的web站点，完全可以支持数以万计的并发连接，根据官方文档，haproxy可以跑满10Gbps。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中，同时可以保护你的web服务器不被暴露到网络上。</p>\n<p>HAProxy支持全透明代理，可以用客户端IP地址或者任何其他地址来连接后端服务器，同时提供连接拒绝功能，可以有效的限制攻击蠕虫。</p>\n<h1 id=\"HAProxy的安装\"><a href=\"#HAProxy的安装\" class=\"headerlink\" title=\"HAProxy的安装\"></a>HAProxy的安装</h1><p>该教程使用的Ubuntu版本是18.04.1版本，Ubuntu的安装教程参考<a href=\"/posts/VirtualBox安装Ubuntu教程/\" title=\"VirtualBox安装Ubuntu教程\">VirtualBox安装Ubuntu教程</a>。HAProxy可以直接通过apt-get安装，也可以通过源码编译安装。</p>\n<h2 id=\"apt-get安装\"><a href=\"#apt-get安装\" class=\"headerlink\" title=\"apt-get安装\"></a>apt-get安装</h2><p>Ubuntu下执行<code>sudo apt-get install haproxy</code>命令即可安装。</p>\n<p>通过<code>which haproxy</code>可以看到haproxy是安装在<code>/usr/sbin/haproxy</code>下，HAProxy的配置文件路径为：<code>/etc/haproxy/haproxy.cfg</code></p>\n<p>使用<code>sudo haproxy -f /etc/haproxy/haproxy.cfg</code>即可启动HAProxy。</p>\n<h2 id=\"源码编译安装\"><a href=\"#源码编译安装\" class=\"headerlink\" title=\"源码编译安装\"></a>源码编译安装</h2><p>源码安装的脚本可以点击此处下载： <a href=\"/posts/Ubuntu下HAProxy的安装与配置/haproxy_install.sh\" title=\"haproxy_install.sh\">haproxy_install.sh</a>，下面对安装过程做一下说明。</p>\n<p>一般源码安装目录为<code>/usr/local/haproxy</code>，在源码目录中的<code>README</code>文件有安装说明，下面罗列出几点内容：</p>\n<ol>\n<li>在执行make命令之前是不需要执行<code>./configure</code>命令的，因此执行的参数都在make命令中指定</li>\n<li>我们操作系统为Ubuntu 18.04.1，不涉及嵌入式编译，因此使用<code>TARGET=linux26 ARCH=x86_64</code>参数</li>\n<li>PCRE(Perl Compatible Regular Expressions)的速度是其他的2-10倍，因此添加<code>USE_PCRE=1</code>选项，但是前提需要安装<code>libpcre3 libpcre3-dev</code></li>\n<li>为支持HTTPS协议，我们需要添加<code>USE_OPENSSL=1</code>选项，但是前提需要安装<code>libssl-dev</code></li>\n<li>为支持HTTP的压缩功能，我们需要添加<code>USE_ZLIB=1</code>，但是前提需要安装<code>zlib1g-dev</code></li>\n<li>为了保证安装目录为<code>/usr/local/haproxy</code>，我们需要在<code>make install</code>命令中指定<code>PREFIX</code>参数</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install build-essential libssl-dev <span class=\"comment\"># 安装编译工具和openssl依赖</span></span><br><span class=\"line\">sudo apt-get install zlib1g-dev</span><br><span class=\"line\">sudo apt-get install libpcre3 libpcre3-dev</span><br><span class=\"line\">wget https://www.haproxy.org/download/1.8/src/haproxy-1.8.8.tar.gz <span class=\"comment\"># 下载源码</span></span><br><span class=\"line\">tar -zxvf haproxy-1.8.8.tar.gz <span class=\"comment\"># 解压源码</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> haproxy-1.8.8/</span><br><span class=\"line\">make TARGET=linux26 ARCH=x86_64 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 <span class=\"comment\"># 编译源码，从README中可以看出如何编译</span></span><br><span class=\"line\">sudo make install PREFIX=/usr/<span class=\"built_in\">local</span>/haproxy <span class=\"comment\"># 安装到安装目录，需要使用root权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">sudo mkdir -p /etc/haproxy</span><br><span class=\"line\">sudo cp -a examples/transparent_proxy.cfg /etc/haproxy/haproxy.cfg</span><br></pre></td></tr></table></figure>\n<p>启动HAProxy: <code>sudo /usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg</code></p>\n<p><strong>可能遇到的问题</strong></p>\n<ol>\n<li><p>提示<code>make is not found</code></p>\n<blockquote>\n<p>源码安装需要安装编译器将源码转换为二进制可执行文件，因此执行<code>sudo apt-get install build-essential</code>安装编译器即可</p>\n</blockquote>\n</li>\n<li><p>启动时提示<code>parsing [/etc/haproxy/haproxy.cfg:12] : unknown keyword &#39;ca-base&#39; in &#39;global&#39; section</code></p>\n<blockquote>\n<p>编译haproxy时没有使能openssl的支持，安装<code>libssl-dev</code>并在编译时指定<code>USE_OPENSSL=1</code>选项即可</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"开机启动\"><a href=\"#开机启动\" class=\"headerlink\" title=\"开机启动\"></a>开机启动</h2><h3 id=\"方式1：rc-local\"><a href=\"#方式1：rc-local\" class=\"headerlink\" title=\"方式1：rc.local\"></a>方式1：rc.local</h3><p>编辑<code>sudo vim /etc/rc.local</code>, 在最下面添加<code>sudo /usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg</code>语句即可。</p>\n<h3 id=\"方式2：systemctl\"><a href=\"#方式2：systemctl\" class=\"headerlink\" title=\"方式2：systemctl\"></a>方式2：systemctl</h3><p>我们还是采用systemd的方式添加到系统服务，执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(</span><br><span class=\"line\">cat &lt;&lt;EOF</span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=HAproxy Daemon</span><br><span class=\"line\">After=syslog.target network-online.target</span><br><span class=\"line\">Wants=network-online.target</span><br><span class=\"line\">ConditionFileNotEmpty=/etc/haproxy/haproxy.cfg</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=forking</span><br><span class=\"line\">KillMode=process</span><br><span class=\"line\">ExecStart=/usr/<span class=\"built_in\">local</span>/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg</span><br><span class=\"line\">ExecReload=/bin/<span class=\"built_in\">kill</span> -HUP <span class=\"variable\">$MAINPID</span></span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br><span class=\"line\">EOF</span><br><span class=\"line\">) &gt; haproxy.service</span><br><span class=\"line\"></span><br><span class=\"line\">sudo cp -a haproxy.service /lib/systemd/system/haproxy.service</span><br><span class=\"line\">sudo ln -s /lib/systemd/system/haproxy.service /etc/systemd/system/multi-user.target.wants/haproxy.service</span><br></pre></td></tr></table></figure>\n<p>启动haproxy进程，并设置为开机启动，通过<code>sudo systemctl status haproxy</code>查看状态：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start haproxy  <span class=\"comment\"># 注意： 如果配置文件不正确的话HPAProxy是启动不起来的</span></span><br><span class=\"line\">sudo systemctl status haproxy</span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">enable</span> haproxy</span><br></pre></td></tr></table></figure>\n<h1 id=\"HAProxy的配置\"><a href=\"#HAProxy的配置\" class=\"headerlink\" title=\"HAProxy的配置\"></a>HAProxy的配置</h1><p>下面我们以一个最简单的用例说明如何配置HAProxy，架构图如下，<code>192.168.1.102</code>上安装有HAProxy, <code>8081</code>端口转向<code>192.168.1.106</code>服务器，<code>8082</code>端口转向<code>192.168.1.107</code>服务器。因为HAProxy是提供有统计功能的，因此打开该功能，并监听在<code>8083</code>端口。<br><img src=\"/posts/Ubuntu下HAProxy的安装与配置/2018-09-27-22-03-48.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"配置HAProxy\"><a href=\"#配置HAProxy\" class=\"headerlink\" title=\"配置HAProxy\"></a>配置HAProxy</h2><p>编辑<code>sudo vim /etc/haproxy/haproxy.cfg</code>文件，写入如下的内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">global</span><br><span class=\"line\">    daemon                          <span class=\"comment\"># 配置为后台启动</span></span><br><span class=\"line\">defaults</span><br><span class=\"line\">    mode http</span><br><span class=\"line\">    timeout connect 30s             <span class=\"comment\"># 连接超时</span></span><br><span class=\"line\">    timeout client 30s              <span class=\"comment\"># 客户端超时</span></span><br><span class=\"line\">    timeout server 30s              <span class=\"comment\"># 服务器超时</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###########################################################</span></span><br><span class=\"line\">frontend app01</span><br><span class=\"line\">    <span class=\"built_in\">bind</span> *:8081                     <span class=\"comment\"># 绑定端口</span></span><br><span class=\"line\">    default_backend app01_backend   <span class=\"comment\"># 默认的backend的名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">backend app01_backend</span><br><span class=\"line\">    server web1 192.168.1.106:80    <span class=\"comment\"># 设置后端服务器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###########################################################</span></span><br><span class=\"line\">frontend app02</span><br><span class=\"line\">    <span class=\"built_in\">bind</span> *:8082                     <span class=\"comment\"># 绑定端口</span></span><br><span class=\"line\">    default_backend app02_backend   <span class=\"comment\"># 默认的backend的名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">backend app02_backend</span><br><span class=\"line\">    server web1 192.168.1.107:80    <span class=\"comment\"># 设置后端服务器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###########################################################</span></span><br><span class=\"line\">listen stats</span><br><span class=\"line\">    <span class=\"built_in\">bind</span> *:8083                     <span class=\"comment\"># 设置监控组的名称</span></span><br><span class=\"line\">    stats refresh 30s               <span class=\"comment\"># 统计页面自动刷新时间</span></span><br><span class=\"line\">    stats uri /stats                <span class=\"comment\"># 统计页面url</span></span><br></pre></td></tr></table></figure>\n<p>然后执行<code>sudo /usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg</code>启动HAProxy，通过<code>sudo netstat -lntp | grep haproxy</code>，可以看出HAProxy已经监听配置文件中的三个端口：<br><img src=\"/posts/Ubuntu下HAProxy的安装与配置/2018-09-26-15-08-13.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p><strong>可能遇到的问题</strong></p>\n<ol>\n<li><p>启动时提示<code>unknown keyword</code>，如下所示：</p>\n<blockquote>\n<p>从错误信息中可以看出keyword前都多了好多空格，说明我们的配置文件没有正确的使用tab键</p>\n<img src=\"/posts/Ubuntu下HAProxy的安装与配置/2018-09-26-13-22-19.png\" title=\"[blog.ruanxinyu.cn]\">\n</blockquote>\n</li>\n<li><p>启动HAProxy后配置文件没有生效</p>\n<blockquote>\n<p>因为之前启动的HAProxy进程没有关闭，可以执行<code>sudo killall haproxy</code>关闭进程。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"搭建Apache服务器\"><a href=\"#搭建Apache服务器\" class=\"headerlink\" title=\"搭建Apache服务器\"></a>搭建Apache服务器</h2><p>我们使用Apache服务器来模拟HAProxy后端的服务器，首先分别在<code>192.168.1.106</code>和<code>192.168.1.107</code>两台机器上执行<code>sudo apt-get install apache2</code>，完成后Apache会自动启动并监听80端口，此时在浏览器中访问对应机器，既可以看到Apache2的首页，默认使用的首页文件路径为<code>/var/www/html/index.html</code>。</p>\n<p>为了对两台机器做一下区分，我们做如下操作：</p>\n<ol>\n<li>在<code>192.168.1.106</code>执行<code>sudo sh -c &#39;echo &quot;This is apache server 01&quot; &gt; /var/www/html/index.html&#39;</code></li>\n<li>在<code>192.168.1.107</code>执行<code>sudo sh -c &#39;echo &quot;This is apache server 02&quot; &gt; /var/www/html/index.html&#39;</code></li>\n</ol>\n<p>此时分别访问<code>http://192.168.1.106/</code>和<code>http://192.168.1.107/</code>可以看到下面的界面：<br><img src=\"/posts/Ubuntu下HAProxy的安装与配置/2018-09-27-22-18-00.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h1 id=\"HAProxy的验证\"><a href=\"#HAProxy的验证\" class=\"headerlink\" title=\"HAProxy的验证\"></a>HAProxy的验证</h1><p>此时访问HAProxy（<code>192.168.1.102</code>）的<code>8081</code>和<code>8082</code>可以看到分别访问到后端的<code>192.168.1.106</code>和<code>192.168.1.107</code>的<code>80</code>端口，如下所示，说明HAProxy的功能已经生效。<br><img src=\"/posts/Ubuntu下HAProxy的安装与配置/2018-09-27-22-19-32.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>访问HAProxy的<code>8083</code>端口：<code>http://192.168.1.102:8083/stats</code>，可以看到HAProxy自带的的统计数据页面，如下所示：<br><img src=\"/posts/Ubuntu下HAProxy的安装与配置/2018-09-27-22-20-09.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h1 id=\"HAProxy详细配置说明（高级）\"><a href=\"#HAProxy详细配置说明（高级）\" class=\"headerlink\" title=\"HAProxy详细配置说明（高级）\"></a>HAProxy详细配置说明（高级）</h1><p>对于初级使用者可以不必详细掌握所有的配置，只需要在使用的时候能查到即可，因此将说明放置在此处，参数说明来源于<code>https://www.linuxidc.com/Linux/2012-07/65350.htm</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">####################全局配置信息########################</span></span><br><span class=\"line\"><span class=\"comment\">#######参数是进程级的，通常和操作系统（OS）相关#########</span></span><br><span class=\"line\">global</span><br><span class=\"line\">  maxconn 20480 <span class=\"comment\">#默认最大连接数</span></span><br><span class=\"line\">  <span class=\"built_in\">log</span> 127.0.0.1 local3 <span class=\"comment\">#[err warning info debug]</span></span><br><span class=\"line\">  chroot /var/haproxy <span class=\"comment\">#chroot运行的路径</span></span><br><span class=\"line\">  uid 99 <span class=\"comment\">#所属运行的用户uid</span></span><br><span class=\"line\">  gid 99 <span class=\"comment\">#所属运行的用户组</span></span><br><span class=\"line\">  daemon <span class=\"comment\">#以后台形式运行haproxy</span></span><br><span class=\"line\">  nbproc 1 <span class=\"comment\">#进程数量(可以设置多个进程提高性能)</span></span><br><span class=\"line\">  pidfile /var/run/haproxy.pid <span class=\"comment\">#haproxy的pid存放路径,启动进程的用户必须有权限访问此文件</span></span><br><span class=\"line\">  <span class=\"built_in\">ulimit</span>-n 65535 <span class=\"comment\">#ulimit的数量限制</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#####################默认的全局设置######################</span></span><br><span class=\"line\"><span class=\"comment\">##这些参数可以被利用配置到frontend，backend，listen组件##</span></span><br><span class=\"line\">defaults</span><br><span class=\"line\">  <span class=\"built_in\">log</span> global</span><br><span class=\"line\">  mode http <span class=\"comment\">#所处理的类别 (#7层 http;4层tcp )</span></span><br><span class=\"line\">  maxconn 20480 <span class=\"comment\">#最大连接数</span></span><br><span class=\"line\">  option httplog <span class=\"comment\">#日志类别http日志格式</span></span><br><span class=\"line\">  option httpclose <span class=\"comment\">#每次请求完毕后主动关闭http通道</span></span><br><span class=\"line\">  option dontlognull <span class=\"comment\">#不记录健康检查的日志信息</span></span><br><span class=\"line\">  option forwardfor <span class=\"comment\">#如果后端服务器需要获得客户端真实ip需要配置的参数，可以从Http Header中获得客户端ip</span></span><br><span class=\"line\">  option redispatch <span class=\"comment\">#serverId对应的服务器挂掉后,强制定向到其他健康的服务器</span></span><br><span class=\"line\">  option abortonclose <span class=\"comment\">#当服务器负载很高的时候，自动结束掉当前队列处理比较久的连接</span></span><br><span class=\"line\">  stats refresh 30 <span class=\"comment\">#统计页面刷新间隔</span></span><br><span class=\"line\">  retries 3 <span class=\"comment\">#3次连接失败就认为服务不可用，也可以通过后面设置</span></span><br><span class=\"line\">  balance roundrobin <span class=\"comment\">#默认的负载均衡的方式,轮询方式</span></span><br><span class=\"line\">  <span class=\"comment\"># balance source #默认的负载均衡的方式,类似nginx的ip_hash</span></span><br><span class=\"line\">  <span class=\"comment\"># balance leastconn #默认的负载均衡的方式,最小连接</span></span><br><span class=\"line\">  contimeout 5000 <span class=\"comment\">#连接超时</span></span><br><span class=\"line\">  clitimeout 50000 <span class=\"comment\">#客户端超时</span></span><br><span class=\"line\">  srvtimeout 50000 <span class=\"comment\">#服务器超时</span></span><br><span class=\"line\">  timeout check 2000 <span class=\"comment\">#心跳检测超时</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">####################监控页面的设置#######################</span></span><br><span class=\"line\">listen admin_status <span class=\"comment\">#Frontend和Backend的组合体,监控组的名称，按需自定义名称</span></span><br><span class=\"line\">  <span class=\"built_in\">bind</span> 0.0.0.0:65532 <span class=\"comment\">#监听端口</span></span><br><span class=\"line\">  mode http <span class=\"comment\">#http的7层模式</span></span><br><span class=\"line\">  <span class=\"built_in\">log</span> 127.0.0.1 local3 err <span class=\"comment\">#错误日志记录</span></span><br><span class=\"line\">  stats refresh 5s <span class=\"comment\">#每隔5秒自动刷新监控页面</span></span><br><span class=\"line\">  stats uri /admin?stats <span class=\"comment\">#监控页面的url</span></span><br><span class=\"line\">  stats realm itnihao\\ itnihao <span class=\"comment\">#监控页面的提示信息</span></span><br><span class=\"line\">  stats auth admin:admin <span class=\"comment\">#监控页面的用户和密码admin,可以设置多个用户名</span></span><br><span class=\"line\">  stats auth admin1:admin1 <span class=\"comment\">#监控页面的用户和密码admin1</span></span><br><span class=\"line\">  stats hide-version <span class=\"comment\">#隐藏统计页面上的HAproxy版本信息</span></span><br><span class=\"line\">  stats admin <span class=\"keyword\">if</span> TRUE <span class=\"comment\">#手工启用/禁用,后端服务器(haproxy-1.4.9以后版本)</span></span><br><span class=\"line\"></span><br><span class=\"line\">  rrorfile 403 /etc/haproxy/errorfiles/403.http</span><br><span class=\"line\">  rrorfile 500 /etc/haproxy/errorfiles/500.http</span><br><span class=\"line\">  rrorfile 502 /etc/haproxy/errorfiles/502.http</span><br><span class=\"line\">  rrorfile 503 /etc/haproxy/errorfiles/503.http</span><br><span class=\"line\">  rrorfile 504 /etc/haproxy/errorfiles/504.http</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#################HAProxy的日志记录内容设置###################</span></span><br><span class=\"line\">  capture request header Host len 40</span><br><span class=\"line\">  capture request header Content-Length len 10</span><br><span class=\"line\">  capture request header Referer len 200</span><br><span class=\"line\">  capture response header Server len 40</span><br><span class=\"line\">  capture response header Content-Length len 10</span><br><span class=\"line\">  capture response header Cache-Control len 8</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#######################网站监测listen配置#####################</span></span><br><span class=\"line\"><span class=\"comment\">###########此用法主要是监控haproxy后端服务器的监控状态############</span></span><br><span class=\"line\">listen site_status</span><br><span class=\"line\">  <span class=\"built_in\">bind</span> 0.0.0.0:1081 <span class=\"comment\">#监听端口</span></span><br><span class=\"line\">  mode http <span class=\"comment\">#http的7层模式</span></span><br><span class=\"line\">  <span class=\"built_in\">log</span> 127.0.0.1 local3 err <span class=\"comment\">#[err warning info debug]</span></span><br><span class=\"line\">  monitor-uri /site_status <span class=\"comment\">#网站健康检测URL，用来检测HAProxy管理的网站是否可以用，正常返回200，不正常返回503</span></span><br><span class=\"line\">  acl site_dead nbsrv(server_web) lt 2 <span class=\"comment\">#定义网站down时的策略当挂在负载均衡上的指定backend的中有效机器数小于1台时返回true</span></span><br><span class=\"line\">  acl site_dead nbsrv(server_blog) lt 2</span><br><span class=\"line\">  acl site_dead nbsrv(server_bbs) lt 2</span><br><span class=\"line\">  monitor fail <span class=\"keyword\">if</span> site_dead <span class=\"comment\">#当满足策略的时候返回503，网上文档说的是500，实际测试为503</span></span><br><span class=\"line\">  monitor-net 192.168.16.2/32 <span class=\"comment\">#来自192.168.16.2的日志信息不会被记录和转发</span></span><br><span class=\"line\">  monitor-net 192.168.16.3/32</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">########frontend配置############</span></span><br><span class=\"line\"><span class=\"comment\">#####注意，frontend配置里面可以定义多个acl进行匹配操作########</span></span><br><span class=\"line\">frontend http_80_in</span><br><span class=\"line\">  <span class=\"built_in\">bind</span> 0.0.0.0:80 <span class=\"comment\">#监听端口，即haproxy提供web服务的端口，和lvs的vip端口类似</span></span><br><span class=\"line\">  mode http <span class=\"comment\">#http的7层模式</span></span><br><span class=\"line\">  <span class=\"built_in\">log</span> global <span class=\"comment\">#应用全局的日志配置</span></span><br><span class=\"line\">  option httplog <span class=\"comment\">#启用http的log</span></span><br><span class=\"line\">  option httpclose <span class=\"comment\">#每次请求完毕后主动关闭http通道，HA-Proxy不支持keep-alive模式</span></span><br><span class=\"line\">  option forwardfor <span class=\"comment\">#如果后端服务器需要获得客户端的真实IP需要配置次参数，将可以从Http Header中获得客户端IP</span></span><br><span class=\"line\">  <span class=\"comment\">########acl策略配置#############</span></span><br><span class=\"line\">  acl itnihao_web hdr_reg(host) -i ^(www.itnihao.cn|ww1.itnihao.cn)$</span><br><span class=\"line\">  <span class=\"comment\">#如果请求的域名满足正则表达式中的2个域名返回true -i是忽略大小写</span></span><br><span class=\"line\">  acl itnihao_blog hdr_dom(host) -i blog.itnihao.cn</span><br><span class=\"line\">  <span class=\"comment\">#如果请求的域名满足www.itnihao.cn返回true -i是忽略大小写</span></span><br><span class=\"line\">  <span class=\"comment\">#acl itnihao hdr(host) -i itnihao.cn</span></span><br><span class=\"line\">  <span class=\"comment\">#如果请求的域名满足itnihao.cn返回true -i是忽略大小写</span></span><br><span class=\"line\">  <span class=\"comment\">#acl file_req url_sub -i killall=</span></span><br><span class=\"line\">  <span class=\"comment\">#在请求url中包含killall=，则此控制策略返回true,否则为false</span></span><br><span class=\"line\">  <span class=\"comment\">#acl dir_req url_dir -i allow</span></span><br><span class=\"line\">  <span class=\"comment\">#在请求url中存在allow作为部分地址路径，则此控制策略返回true,否则返回false</span></span><br><span class=\"line\">  <span class=\"comment\">#acl missing_cl hdr_cnt(Content-length) eq 0</span></span><br><span class=\"line\">  <span class=\"comment\">#当请求的header中Content-length等于0时返回true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">########acl策略匹配相应#############</span></span><br><span class=\"line\">  <span class=\"comment\">#block if missing_cl</span></span><br><span class=\"line\">  <span class=\"comment\">#当请求中header中Content-length等于0阻止请求返回403</span></span><br><span class=\"line\">  <span class=\"comment\">#block if !file_req || dir_req</span></span><br><span class=\"line\">  <span class=\"comment\">#block表示阻止请求，返回403错误，当前表示如果不满足策略file_req，或者满足策略dir_req，则阻止请求</span></span><br><span class=\"line\">  use_backend server_web <span class=\"keyword\">if</span> itnihao_web</span><br><span class=\"line\">  <span class=\"comment\">#当满足itnihao_web的策略时使用server_web的backend</span></span><br><span class=\"line\">  use_backend server_blog <span class=\"keyword\">if</span> itnihao_blog</span><br><span class=\"line\">  <span class=\"comment\">#当满足itnihao_blog的策略时使用server_blog的backend</span></span><br><span class=\"line\">  <span class=\"comment\">#redirect prefix http://blog.itniaho.cn code 301 if itnihao</span></span><br><span class=\"line\">  <span class=\"comment\">#当访问itnihao.cn的时候，用http的301挑转到http://192.168.16.3</span></span><br><span class=\"line\">  default_backend server_bbs</span><br><span class=\"line\">  <span class=\"comment\">#以上都不满足的时候使用默认server_bbs的backend</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##########backend的设置##############</span></span><br><span class=\"line\"><span class=\"comment\">#下面我将设置三组服务器 server_web，server_blog，server_bbs</span></span><br><span class=\"line\"><span class=\"comment\">##################backend server_web####################</span></span><br><span class=\"line\">backend server_web</span><br><span class=\"line\">  mode http <span class=\"comment\">#http的7层模式</span></span><br><span class=\"line\">  balance roundrobin <span class=\"comment\">#负载均衡的方式，roundrobin平均方式</span></span><br><span class=\"line\">  cookie SERVERID <span class=\"comment\">#允许插入serverid到cookie中，serverid后面可以定义</span></span><br><span class=\"line\">  option httpchk GET /index.html <span class=\"comment\">#心跳检测的文件</span></span><br><span class=\"line\">  server web1 192.168.16.2:80 cookie web1 check inter 1500 rise 3 fall 3 weight 1</span><br><span class=\"line\">  <span class=\"comment\">#服务器定义，cookie 1表示serverid为web1，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，</span></span><br><span class=\"line\">  <span class=\"comment\">#fall 3是3次失败认为服务器不可用，weight代表权重</span></span><br><span class=\"line\">  server web2 192.168.16.3:80 cookie web2 check inter 1500 rise 3 fall 3 weight 2</span><br><span class=\"line\">  <span class=\"comment\">#服务器定义，cookie 1表示serverid为web2，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，</span></span><br><span class=\"line\">  <span class=\"comment\">#fall 3是3次失败认为服务器不可用，weight代表权重</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###################backend server_blog######################</span></span><br><span class=\"line\">backend server_blog</span><br><span class=\"line\">  mode http <span class=\"comment\">#http的7层模式</span></span><br><span class=\"line\">  balance roundrobin <span class=\"comment\">#负载均衡的方式，roundrobin平均方式</span></span><br><span class=\"line\">  cookie SERVERID <span class=\"comment\">#允许插入serverid到cookie中，serverid后面可以定义</span></span><br><span class=\"line\">  option httpchk GET /index.html <span class=\"comment\">#心跳检测的文件</span></span><br><span class=\"line\">  server blog1 192.168.16.2:80 cookie blog1 check inter 1500 rise 3 fall 3 weight 1</span><br><span class=\"line\">  <span class=\"comment\">#服务器定义，cookie 1表示serverid为blog1，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重</span></span><br><span class=\"line\">  server blog2 192.168.16.3:80 cookie blog2 check inter 1500 rise 3 fall 3 weight 2</span><br><span class=\"line\">  <span class=\"comment\">#服务器定义，cookie 1表示serverid为blog2，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##################backend server_bbs########################</span></span><br><span class=\"line\">backend server_bbs</span><br><span class=\"line\">  mode http <span class=\"comment\">#http的7层模式</span></span><br><span class=\"line\">  balance roundrobin <span class=\"comment\">#负载均衡的方式，roundrobin平均方式</span></span><br><span class=\"line\">  cookie SERVERID <span class=\"comment\">#允许插入serverid到cookie中，serverid后面可以定义</span></span><br><span class=\"line\">  option httpchk GET /index.html <span class=\"comment\">#心跳检测的文件</span></span><br><span class=\"line\">  server bbs1 192.168.16.2:80 cookie bbs1 check inter 1500 rise 3 fall 3 weight 1</span><br><span class=\"line\">  <span class=\"comment\">#服务器定义，cookie 1表示serverid为bbs1，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重</span></span><br><span class=\"line\">  server bbs2 192.168.16.3:80 cookie bbs2 check inter 1500 rise 3 fall 3 weight 2</span><br><span class=\"line\">  <span class=\"comment\">#服务器定义，cookie 1表示serverid为bbs2，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重</span></span><br></pre></td></tr></table></figure>","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/categories/环境搭建/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/tags/环境搭建/"}]},{"title":"Linux初始化init系统：Sysvinit、Upstart和Systemd","slug":"Linux初始化init系统","date":"un66fin66","updated":"un11fin11","comments":true,"path":"posts/Linux初始化init系统/","link":"","permalink":"http://ruanxinyu.github.io/posts/Linux初始化init系统/","excerpt":"","keywords":"","text":"init系统介绍Linux操作系统的启动首先从BIOS开始，接下来进入bootloader，由bootloader载入内核，进行内核初始化。内核初始化的最后一步就是启动pid为1的init进程。init以守护进程方式存在，是系统的第一个进程,，是所有其他进程的祖先。 Init系统能够定义、管理和控制 init进程的行为。它负责组织和运行许多独立的或相关的始化工作(因此被称为init系统)，从而让计算机系统进入某种用户预订的运行模式。 Linux初始化init系统包括：Sysvinit、Upstart和Systemd，它们在Ubuntu系统下的演化如下： Ubuntu 6.10及以前版本使用Sysvinit。 Ubuntu 14.10及以前版本使用Upstart，通过与Sysvinit并存。 Ubuntu 15.04开始默认使用Systemd，不能与Sysvinit或Upstart并存 Sysvinit介绍 Sysvinit就是System V风格的init系统，顾名思义，它源于System V系列UNIX。 运行级别Sysvinit用术语runlevel来定义”预订的运行模式”，默认的运行模式定义在/etc/inittab文件的initdefault项。如果没有默认的运行模式，那么用户将进入系统控制台，手动决定进入何种运行模式。 Sysvinit中运行模式描述了系统各种预订的运行模式。通常会有8种运行模式，即运行模式0-6和S。其中0表示关机，1表示单用户模式，3为命令行模式，5为GUI模式，6表示重启，1和S等往往用于系统故障之后的排错和恢复。可以看出每一种运行模式所作的初始化工作是不一样的。 Sysvinit执行顺序 /etc/rc.d/rc.sysinit /etc/rc.d/rc 和/etc/rc.d/rcX.d/ (X 代表运行级别 0-6) /etc/rc.d/rc.local X Display Manager（可选） 首先，运行rc.sysinit以便执行一些重要的系统初始化任务。 然后，Sysvinit开始运行/etc/rc.d/rc脚本。根据不同的runlevel，rc脚本将执行/etc/rc.d/rcX.d(X就是runlevel)目录下的所有启动脚本。当所有的初始化脚本执行完毕。该目录下有多个脚本，为了保证系统正常关闭，脚本是要按照顺序执行的在该目录下所有以K开头的脚本都将在关闭系统时调用，字母K之后的数字定义了它们的执行顺序。 然后，Sysvinit运行/etc/rc.d/rc.local脚本。rc.local是Linux 留给用户进行个性化设置的地方。 Sysvinit优缺点Sysvinit的优点： 是概念简单，开发人员只需要编写启动和停止脚本，概念非常清楚 确定的执行顺序，脚本严格按照启动数字的大小顺序执行，一个执行完毕再执行下一个，这非常有益于错误排查 Sysvinit的缺点： 串行地执行脚本导致Sysvinit运行效率较慢 对动态设备加载等Linux新特性支持不友好 Upstart介绍开发UpStart的缘由当Linux内核进入2.6时代时，系统支持热插拔功能，一旦新外设连接到系统，内核便可以自动实时地发现它们，并初始化这些设备，进而使用它们。这为便携式设备用户提供了很大的灵活性。 Sysvinit启动时必须一次性把所有可能用到的服务都启动起来，即使该设备没有连接，因此会造成浪费，比如为了管理打印任务，系统需要启动CUPS等服务。 UpStart基于事件机制，比如U盘插入USB接口后，udev得到内核通知，发现该设备，这就是一个新的事件。UpStart在感知到该事件之后触发相应的等待任务，比如处理/etc/fstab 中存在的挂载点。采用这种事件驱动的模式，upstart 完美地解决了即插即用设备带来的新问题。 UpStart相对于Sysvinit具有如下的优势： 更快地启动系统 当新硬件被发现时动态启动服务 硬件被拔除时动态停止服务 UpStart的原理Upstart的基本概念和设计清晰明确。UpStart主要的概念是job和event。Job就是一个工作单元，用来完成一件工作，比如启动一个后台服务，或者运行一个配置命令。每个Job都等待一个或多个事件，一旦事件发生，upstart就触发该 job 完成相应的工作。 Job包括包括TaskJob，SeriveJob和AbstractJob。其中SeriveJob代表后台服务进程，一旦开始运行就成为一个后台进程，由init进程管理。 事件是个非常抽象的概念，下面我罗列出一些常见的事件，希望可以帮助您进一步了解事件的含义： 系统上电启动，init 进程会发送”start”事件 根文件系统可写时，相应 job 会发送文件系统就绪的事件 一个块设备被发现并初始化完成，发送相应的事件 某个文件系统被挂载，发送相应的事件 类似 atd 和 cron，可以在某个时间点，或者周期的时间点发送事件 另外一个 job 开始或结束时，发送相应的事件 一个磁盘文件被修改时，可以发出相应的事件 一个网络设备被发现时，可以发出相应的事件 缺省路由被添加或删除时，可以发出相应的事件 系统初始化的过程是在工作和事件的相互协作下完成的，可以大致描述如下: 系统初始化时，init 进程开始运行，init 进程自身会发出不同的事件，这些最初的事件会触发一些工作运行。每个工作运行过程中会释放不同的事件，这些事件又将触发新的工作运行。如此反复，直到整个系统正常运行起来。 UpStart是兼容SysvInit的runlevel的，通过触发执行/etc/init/rc.conf来执行/etc/rc$.d/目录下的所有脚本。 Systemd介绍Systemd提供了和Sysvinit以及LSBinitscripts兼容的特性。系统中已经存在的服务和进程无需修改。这降低了系统向systemd 迁移的成本，使得Systemd替换现有初始化系统成为可能。 Systemd的启动速度更快，提供了比UpStart更激进的并行启动能力，采用了socket/D-Bus Activation等技术启动服务，提供按需启动的能力，只有在某个服务被真正请求的时候才启动它，当该服务结束，systemd 可以关闭它，等待下次需要时再次启动它。 Systemd还提供如下等特性: 和init比起来引导过程简化了很多 Systemd支持并发引导过程从而可以更快启动 通过控制组来追踪进程，而不是PID 优化了处理引导过程和服务之间依赖的方式 支持系统快照和恢复 监控已启动的服务；也支持重启已崩溃服务 包含了systemd-login模块用于控制用户登录 支持加载和卸载组件 低内存使用痕迹以及任务调度能力 记录事件的Journald模块和记录系统日志的syslogd模块 Systemd的单元概念系统初始化需要执行的任务非常多。每一个任务都被Systemd 抽象为一个配置单元，即unit。当前单元类型如下： service：代表一个后台服务进程，比如 mysqld。这是最常用的一类。 socket：此类配置单元封装系统和互联网中的一个 套接字 。当下，systemd 支持流式、数据报和连续包的 AF_INET、AF_INET6、AF_UNIX socket 。每一个套接字配置单元都有一个相应的服务配置单元 。相应的服务在第一个”连接”进入套接字时就会启动(例如：nscd.socket 在有新连接后便启动 nscd.service)。 device：此类配置单元封装一个存在于 Linux 设备树中的设备。每一个使用 udev 规则标记的设备都将会在 systemd 中作为一个设备配置单元出现。 mount：此类配置单元封装文件系统结构层次中的一个挂载点。Systemd 将对这个挂载点进行监控和管理。比如可以在启动时自动将其挂载；可以在某些条件下自动卸载。Systemd 会将/etc/fstab 中的条目都转换为挂载点，并在开机时处理。 automount：此类配置单元封装系统结构层次中的一个自挂载点。每一个自挂载配置单元对应一个挂载配置单元 ，当该自动挂载点被访问时，systemd 执行挂载点中定义的挂载行为。 swap: 和挂载配置单元类似，交换配置单元用来管理交换分区。用户可以用交换配置单元来定义系统中的交换分区，可以让这些交换分区在启动时被激活。 target：此类配置单元为其他配置单元进行逻辑分组。它们本身实际上并不做什么，只是引用其他配置单元而已。这样便可以对配置单元做一个统一的控制。这样就可以实现大家都已经非常熟悉的运行级别概念。比如想让系统进入图形化模式，需要运行许多服务和配置命令，这些操作都由一个个的配置单元表示，将所有这些配置单元组合为一个目标(target)，就表示需要将这些配置单元全部执行一遍以便进入目标所代表的系统运行状态。 (例如：multi-user.target 相当于在传统使用 SysV 的系统中运行级别 5) timer：定时器配置单元用来定时触发用户定义的操作，这类配置单元取代了 atd、crond 等传统的定时服务。 snapshot：与 target 配置单元相似，快照是一组配置单元。它保存了系统当前的运行状态。 Systemd的Target和运行级别systemd使用目标（target）替代了运行级别的概念，提供了更大的灵活性，如您可以继承一个已有的目标，并添加其它服务，来创建自己的目标。通过target文件夹的命令也可以看出对应的runlevel： Sysvinit运行级别 Systemd目标 备注 0 poweroff.target 关闭系统 1,s rescue.target 单用户模式 2,4 multi-user.target 多用户，非图形化 3 multi-user.target 多用户，非图形化 5 graphical.target 多用户，图形化 6 reboot.target 重启 使用C/C++开发新的系统服务使用C/C++开发新的系统服务可能需要关注如下的内容： 后台服务进程代码不需要执行两次派生来实现后台精灵进程，只需要实现服务本身的主循环即可。 不要调用 setsid()，交给 systemd 处理 不再需要维护 pid 文件。 Systemd 提供了日志功能，服务进程只需要输出到 stderr 即可，无需使用 syslog。 处理信号 SIGTERM，这个信号的唯一正确作用就是停止当前服务，不要做其他的事情。 SIGHUP 信号的作用是重启服务。 需要套接字的服务，不要自己创建套接字，让 systemd 传入套接字。 使用 sd_notify()函数通知 systemd 服务自己的状态改变。一般地，当服务初始化结束，进入服务就绪状态时，可以调用它。 Unit文件的编写服务配置单元文件以.service为文件名后缀，默认时存放在/lib/systemd/system/目录下，然后链接到/etc/systemd/system/对应的目录下。下面以sshd的为例/etc/system/system/sshd.service： 123456789101112[Unit]Description=OpenSSH server daemon[Service]EnvironmentFile=/etc/sysconfig/sshd #设置环境变量ExecStartPre=/usr/sbin/sshd-keygenExecStart=/usrsbin/sshd –D $OPTIONSExecReload=/bin/kill –HUP $MAINPIDKillMode=processRestart=on-failureRestartSec=42s[Install]WantedBy=multi-user.target #系统以该形式运行时，服务方可启动 文件分为三个小节，其中[Unit]段和[Install]段是所有Unit文件通用的，用于配置服务的描述、依赖和随系统启动方式，而[Service]断则是服务类型的Unit文件（后缀为.service)特有的，用于定义服务的具体管理和操作方法。 在/etc/systemd/system 目录下还可以看到诸如*.wants 的目录，放在该目录下的配置单元文件等同于在[Unit]小节中的 wants关键字，即本单元启动时，还需要启动这些单元。比如您可以简单地把您自己写的 foo.service 文件放入 multi-user.target.wants 目录下，这样每次都会被默认启动了。 [Unit]参数 Description： 一段描述这个Unit文件的文字，通常只是简短的一句话。 Documentation：指定服务的文档，可以是一个或多个文档的URL路径。 Requires：依赖的其他Unit列表，列在其中的Unit模块会在这个服务启动的同时被启动。 Wants：与Requires相似，但只是在被配置的这个Unit启动时，触发启动列出的每个Unit模块，而不去考虑这些模块启动时候是否成功。 After：与Requires相似，但是在后面列出的所有模块启动完成以后，才会启动当前的服务。与Requires不同的是，After不会因为依赖程序在运行过程中停止运行，导致当前服务也停止。 Before：与After相反，在启动指定的任意一个模块之前，都会首先确保当前服务已经运行。 BindsTo：与Requires非常相似，但是一种更强的关联。启动这个服务时会同时启动列出的所有模块，当有模块启动失败时终止当前服务。反之，只要列出的模块全部启动以后，就会自动启动当前服务。并且，这些模块中有任意一个出现意外结束或重启，这个服务会跟着终止或重启。 PartOf：这是一个BindsTo作用的子集，仅在列出的任何模块失败或重启时，终止或重启当前服务，而不会随列出模块的启动而启动。 OnFailure：当这个模块启动失败时，就自动启动列出的每个模块。 Conflicts：与这个模块有冲突的模块，如果列出的模块中有已经在运行的，则会将已启动的冲突模块停止，并启动当前模块；反过来，冲突模块启动时会把当前模块停止。 上面的这些配置，除了Description外，其他都可以被添加多次。比如After参数，可以使用多个After参数，也可以在一行内使用空格分割，写多个依赖模块。 [install]参数 WantedBy：和前面Wants作用相似，但此处表示当前模块被依赖。 RequiredBy：和前面的Requires作用相似，但此处表示当前模块被依赖。 Also：当这个服务被enable/disable时，将自动enable/disable后面列出的每个模块。 [service]参数服务生命周期控制相关的参数 Type：服务的类型，常用的有simple（默认类型）和forking，默认的simple类型可以适用于绝大多数场景，因此一般可以忽略者这个参数的配置。对于服务进程启动后通过fork系统调用创建子进程，然后关闭应用程序本身进程的情况，则应该将Type的值设置为forking；否则Systemd将不会跟踪子进程的行为，而认为服务已经退出。 RemainAfterExit：指为true或false（也可以写yes或no），默认为false。当配置为true时，Systemd只会负责启动服务进程，之后即便服务进程退出了，Systemd也仍然会认为这个服务还在运行中。这个配置主要是提供给一些并非常驻内存，而是启动注册后立即退出，然后等待消息按需启动的特殊类型服务使用的。 ExecStart：这个参数是几乎每个“.service”文件都会有的，指定服务启动的主要命令，在每个配置文件中只能使用一次. ExecStartPre：指定在启动执行ExecStart命令前的准备工作，在同一个配置文件中可以有多个，所有命令会按照文件中书写的顺序依次被执行。 ExecStartPost：指定在启动执行ExecStart命令后的收尾工作，在同一个配置文件中也可有多个。 TimeoutSec：快速设置TimeoutStartSec和TimeoutStopSec参数成指定值。（另外，关于默认时间设定都在systemd配置文件中的DefaultTimeoutStartSec、DefaultTimeoutStopSec和DefaultRestartSec字段进行配置，如果这些字段缺省，DefaultTimeoutStartSec和DefaultTimeoutStopSec的默认指为90s，DefaultRestartSec默认为100ms） TimeoutStartSec：启动服务时的等待秒数，如果超出这个时间服务仍然没有执行完所有的启动命令，则Systemd会认为服务自动失败。这一配置对于使用Docker容器托管的应用十分重要。由于Docker第一次运行时可能会需要从网络上下载服务的镜像文件，因此造成比较严重的延时，容易被Systemd误判断为启动失败而杀死。通常，对于这种服务，需要将TimeoutStartSec设置为0，关闭超时检测。 ExecStop：停止服务所需要执行的主要命令，在每个配置文件中只能够有一个。 ExecStopPost：指定在ExecStop命令执行后的收尾工作，在同一配置文件中可以有多个。 TimeoutStopSec：停止服务时的等待秒数，如果超过这个时间服务仍然没有停止，Systemd会使用SIGKILL信号强行干掉服务进程。 Restart：这个值用于指定在什么情况下需要重启服务进程。常用的值有：no、no-success、on-failure、on-abnormal、on-abort和always。默认值为no，即不会自动重启服务。这些不同的值分别表示在哪些情况下，服务会重新启动。 RestartSec：如果服务需要被重启，这个参数的值为服务被重启前的等待秒数。默认为100ms。 ExecReload：重新加载服务所需执行的主要命令。 服务上下文配置相关的参数 Environment：为服务添加环境变量，格式直接为Environment=“foo=bar”（看了一下Systemd的手册，这个参数所接受的格式有些奇葩，建议是直接“foo=bar”，取的时候使用${foo}进行获取） EnvironmentFile：指定加载一个包含服务所需的环境变量列表的文件，文件中的每一行都是一个环境变量的定义。顺便提一下，建议使用的时候将=换成=-，如EnvironmentFile=-/etc/my.env，和=的区别是，使用=-时，假如/etc/my.env文件不在也不会报错。 Nice：服务的进程优先级，指越小优先级越高，默认为0，。其中-20为最高优先级，19为最低优先级。 WorkingDirectory：指定当前服务的工作目录。 RootDirectory：指定当前服务进程的根目录（/目录）。如果配置了这个参数，服务将无法访问指定目录外的任何文件。 User：指定运行服务的用户，会影响服务对本地文件系统的访问权限。 Group：指定运行服务的用户组，会影响服务对本地文件系统的访问权限。 MountFlags：这个值其实是服务的Mount Namespace的配置，会影响服务进程上下文中挂载点的信息，即服务是否会继承主机上已有的挂载点，以及如果服务运行时执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为shared、slave和private，具体作用如下表所示： LimitCPU/LimitSTACK/LimitNOFILE/LimitNPROC等：限定服务可用的系统资源量，CPU、程序堆栈、文件句柄数量、子进程数量等 Systemd命令行工具的使用systemd 的主要命令行工具是systemctl，可以替换service、chkconfig以及telinit命令的使用。 Systemd命令和sysvinit命令的对照表 Sysvinit命令 Systemd命令 备注 service foo start systemctl start foo.service 用来启动一个服务 (并不会重启现有的) service foo stop systemctl stop foo.service 用来停止一个服务 (并不会重启现有的) service foo restart systemctl restart foo.service 用来停止并启动一个服务 service foo reload systemctl reload foo.service 当支持时，重新装载配置文件而不中断等待操作 service foo condrestart systemctl condrestart foo.service 如果服务正在运行那么重启它 service foo status systemctl status foo.service 汇报服务是否正在运行 ls /etc/rc.d/init.d/ systemctl list-unit-files –type=service 用来列出可以启动或停止的服务列表 chkconfig foo on systemctl enable foo.service 在下次启动时或满足其他触发条件时设置服务为启用 chkconfig foo off systemctl disable foo.service 在下次启动时或满足其他触发条件时设置服务为禁用 chkconfig foo systemctl is-enabled foo.service 用来检查一个服务在当前环境下被配置为启用还是禁用 chkconfig –list systemctl list-unit-files –type=service 输出在各个运行级别下服务的启用和禁用情况 chkconfig foo –list ls /etc/systemd/system/*.wants/foo.service 用来列出该服务在哪些运行级别下启用和禁用 chkconfig foo –add systemctl daemon-reload 当您创建新服务文件或者变更设置时使用 telinit 3 systemctl isolate multi-user.target (OR systemctl isolate runlevel3.target OR telinit 3) 改变至多用户运行级别 systemd电源管理命令 命令 操作 systemctl reboot 重启机器 systemctl poweroff 关机 systemctl suspend 待机 systemctl hibernate 休眠 systemctl hybrid-sleep 混合休眠模式（同时休眠到硬盘并待机）","raw":"---\ntitle: Linux初始化init系统：Sysvinit、Upstart和Systemd\ntags: Linux\ncategories: Linux\ndate: 2018-09-22 15:04:38\n---\n\n# init系统介绍\n\nLinux操作系统的启动首先从BIOS开始，接下来进入bootloader，由bootloader载入内核，进行内核初始化。内核初始化的最后一步就是启动`pid`为`1`的`init进程`。init以守护进程方式存在，是系统的第一个进程,，是所有其他进程的祖先。\n\nInit系统能够定义、管理和控制 init进程的行为。它负责组织和运行许多独立的或相关的始化工作(因此被称为init系统)，从而让计算机系统进入某种用户预订的运行模式。\n\nLinux初始化init系统包括：`Sysvinit`、`Upstart`和`Systemd`，它们在Ubuntu系统下的演化如下：\n\n1. `Ubuntu 6.10`及以前版本使用Sysvinit。\n1. `Ubuntu 14.10`及以前版本使用Upstart，通过与Sysvinit并存。\n1. `Ubuntu 15.04`开始默认使用Systemd，不能与Sysvinit或Upstart并存\n\n# Sysvinit介绍\n\n> Sysvinit就是System V风格的init系统，顾名思义，它源于System V系列UNIX。\n\n## 运行级别\n\nSysvinit用术语`runlevel`来定义\"预订的运行模式\"，默认的运行模式定义在`/etc/inittab`文件的`initdefault`项。如果没有默认的运行模式，那么用户将进入系统控制台，手动决定进入何种运行模式。\n\nSysvinit中运行模式描述了系统各种预订的运行模式。通常会有8种运行模式，即运行模式`0-6和S`。其中`0`表示关机，`1`表示单用户模式，`3`为命令行模式，`5`为GUI模式，`6`表示重启，`1和S`等往往用于系统故障之后的排错和恢复。可以看出每一种运行模式所作的初始化工作是不一样的。\n\n## Sysvinit执行顺序\n\n+ /etc/rc.d/rc.sysinit\n+ /etc/rc.d/rc 和/etc/rc.d/rcX.d/ (X 代表运行级别 0-6)\n+ /etc/rc.d/rc.local\n+ X Display Manager（可选）\n\n首先，运行`rc.sysinit`以便执行一些重要的系统初始化任务。\n\n然后，Sysvinit开始运行`/etc/rc.d/rc`脚本。根据不同的runlevel，rc脚本将执行`/etc/rc.d/rcX.d`(X就是runlevel)目录下的所有启动脚本。当所有的初始化脚本执行完毕。该目录下有多个脚本，为了保证系统正常关闭，脚本是要按照顺序执行的在该目录下所有以`K`开头的脚本都将在关闭系统时调用，字母`K`之后的数字定义了它们的执行顺序。\n\n然后，Sysvinit运行`/etc/rc.d/rc.local`脚本。rc.local是Linux 留给用户进行个性化设置的地方。\n\n## Sysvinit优缺点\n\nSysvinit的优点：\n\n1. 是概念简单，开发人员只需要编写启动和停止脚本，概念非常清楚\n1. 确定的执行顺序，脚本严格按照启动数字的大小顺序执行，一个执行完毕再执行下一个，这非常有益于错误排查\n\nSysvinit的缺点：\n\n1. 串行地执行脚本导致Sysvinit运行效率较慢\n1. 对动态设备加载等Linux新特性支持不友好\n\n# Upstart介绍\n\n## 开发UpStart的缘由\n\n当Linux内核进入2.6时代时，系统支持热插拔功能，一旦新外设连接到系统，内核便可以自动实时地发现它们，并初始化这些设备，进而使用它们。这为便携式设备用户提供了很大的灵活性。\n\nSysvinit启动时必须一次性把所有可能用到的服务都启动起来，即使该设备没有连接，因此会造成浪费，比如为了管理打印任务，系统需要启动CUPS等服务。\n\nUpStart基于事件机制，比如U盘插入USB接口后，udev得到内核通知，发现该设备，这就是一个新的事件。UpStart在感知到该事件之后触发相应的等待任务，比如处理/etc/fstab 中存在的挂载点。采用这种事件驱动的模式，upstart 完美地解决了即插即用设备带来的新问题。\n\nUpStart相对于Sysvinit具有如下的优势：\n\n+ 更快地启动系统\n+ 当新硬件被发现时动态启动服务\n+ 硬件被拔除时动态停止服务\n\n## UpStart的原理\n\nUpstart的基本概念和设计清晰明确。UpStart主要的概念是job和event。Job就是一个工作单元，用来完成一件工作，比如启动一个后台服务，或者运行一个配置命令。每个Job都等待一个或多个事件，一旦事件发生，upstart就触发该 job 完成相应的工作。\n\nJob包括包括`TaskJob`，`SeriveJob`和`AbstractJob`。其中SeriveJob代表后台服务进程，一旦开始运行就成为一个后台进程，由init进程管理。\n\n事件是个非常抽象的概念，下面我罗列出一些常见的事件，希望可以帮助您进一步了解事件的含义：\n\n+ 系统上电启动，init 进程会发送\"start\"事件\n+ 根文件系统可写时，相应 job 会发送文件系统就绪的事件\n+ 一个块设备被发现并初始化完成，发送相应的事件\n+ 某个文件系统被挂载，发送相应的事件\n+ 类似 atd 和 cron，可以在某个时间点，或者周期的时间点发送事件\n+ 另外一个 job 开始或结束时，发送相应的事件\n+ 一个磁盘文件被修改时，可以发出相应的事件\n+ 一个网络设备被发现时，可以发出相应的事件\n+ 缺省路由被添加或删除时，可以发出相应的事件\n\n系统初始化的过程是在工作和事件的相互协作下完成的，可以大致描述如下:\n> 系统初始化时，init 进程开始运行，init 进程自身会发出不同的事件，这些最初的事件会触发一些工作运行。每个工作运行过程中会释放不同的事件，这些事件又将触发新的工作运行。如此反复，直到整个系统正常运行起来。\n\nUpStart是兼容SysvInit的runlevel的，通过触发执行`/etc/init/rc.conf`来执行`/etc/rc$.d/`目录下的所有脚本。\n\n\n# Systemd介绍\n\nSystemd提供了和Sysvinit以及LSBinitscripts兼容的特性。系统中已经存在的服务和进程无需修改。这降低了系统向systemd 迁移的成本，使得Systemd替换现有初始化系统成为可能。\n\nSystemd的启动速度更快，提供了比UpStart更激进的并行启动能力，采用了socket/D-Bus Activation等技术启动服务，提供按需启动的能力，只有在某个服务被真正请求的时候才启动它，当该服务结束，systemd 可以关闭它，等待下次需要时再次启动它。\n\nSystemd还提供如下等特性:\n\n+ 和init比起来引导过程简化了很多\n+ Systemd支持并发引导过程从而可以更快启动\n+ 通过控制组来追踪进程，而不是PID\n+ 优化了处理引导过程和服务之间依赖的方式\n+ 支持系统快照和恢复\n+ 监控已启动的服务；也支持重启已崩溃服务\n+ 包含了systemd-login模块用于控制用户登录\n+ 支持加载和卸载组件\n+ 低内存使用痕迹以及任务调度能力\n+ 记录事件的Journald模块和记录系统日志的syslogd模块\n\n## Systemd的单元概念\n\n系统初始化需要执行的任务非常多。每一个任务都被Systemd 抽象为一个配置单元，即unit。当前单元类型如下：\n\n+ **service**：代表一个后台服务进程，比如 mysqld。这是最常用的一类。\n+ **socket**：此类配置单元封装系统和互联网中的一个 套接字 。当下，systemd 支持流式、数据报和连续包的 AF_INET、AF_INET6、AF_UNIX socket 。每一个套接字配置单元都有一个相应的服务配置单元 。相应的服务在第一个\"连接\"进入套接字时就会启动(例如：nscd.socket 在有新连接后便启动 nscd.service)。\n+ **device**：此类配置单元封装一个存在于 Linux 设备树中的设备。每一个使用 udev 规则标记的设备都将会在 systemd 中作为一个设备配置单元出现。\n+ **mount**：此类配置单元封装文件系统结构层次中的一个挂载点。Systemd 将对这个挂载点进行监控和管理。比如可以在启动时自动将其挂载；可以在某些条件下自动卸载。Systemd 会将/etc/fstab 中的条目都转换为挂载点，并在开机时处理。\n+ **automount**：此类配置单元封装系统结构层次中的一个自挂载点。每一个自挂载配置单元对应一个挂载配置单元 ，当该自动挂载点被访问时，systemd 执行挂载点中定义的挂载行为。\n+ **swap**: 和挂载配置单元类似，交换配置单元用来管理交换分区。用户可以用交换配置单元来定义系统中的交换分区，可以让这些交换分区在启动时被激活。\n+ **target**：此类配置单元为其他配置单元进行逻辑分组。它们本身实际上并不做什么，只是引用其他配置单元而已。这样便可以对配置单元做一个统一的控制。这样就可以实现大家都已经非常熟悉的运行级别概念。比如想让系统进入图形化模式，需要运行许多服务和配置命令，这些操作都由一个个的配置单元表示，将所有这些配置单元组合为一个目标(target)，就表示需要将这些配置单元全部执行一遍以便进入目标所代表的系统运行状态。 (例如：multi-user.target 相当于在传统使用 SysV 的系统中运行级别 5)\n+ **timer**：定时器配置单元用来定时触发用户定义的操作，这类配置单元取代了 atd、crond 等传统的定时服务。\n+ **snapshot**：与 target 配置单元相似，快照是一组配置单元。它保存了系统当前的运行状态。\n\n## Systemd的Target和运行级别\n\nsystemd使用目标（target）替代了运行级别的概念，提供了更大的灵活性，如您可以继承一个已有的目标，并添加其它服务，来创建自己的目标。通过target文件夹的命令也可以看出对应的runlevel：\n\n| Sysvinit运行级别 | Systemd目标 | 备注 |\n| --- | --- | --- |\n| 0 | poweroff.target | 关闭系统 |\n| 1,s | rescue.target | 单用户模式 |\n| 2,4 | multi-user.target | 多用户，非图形化 |\n| 3 | multi-user.target | 多用户，非图形化 |\n| 5 | graphical.target | 多用户，图形化 |\n| 6 | reboot.target | 重启 |\n\n{% asset_img 2018-09-22-16-29-55.png [blog.ruanxinyu.cn] %}\n\n## 使用C/C++开发新的系统服务\n\n使用C/C++开发新的系统服务可能需要关注如下的内容：\n\n1. 后台服务进程代码不需要执行两次派生来实现后台精灵进程，只需要实现服务本身的主循环即可。\n1. 不要调用 setsid()，交给 systemd 处理\n1. 不再需要维护 pid 文件。\n1. Systemd 提供了日志功能，服务进程只需要输出到 stderr 即可，无需使用 syslog。\n1. 处理信号 SIGTERM，这个信号的唯一正确作用就是停止当前服务，不要做其他的事情。\n1. SIGHUP 信号的作用是重启服务。\n1. 需要套接字的服务，不要自己创建套接字，让 systemd 传入套接字。\n1. 使用 sd_notify()函数通知 systemd 服务自己的状态改变。一般地，当服务初始化结束，进入服务就绪状态时，可以调用它。\n\n## Unit文件的编写\n\n服务配置单元文件以`.service`为文件名后缀，默认时存放在`/lib/systemd/system/`目录下，然后链接到`/etc/systemd/system/`对应的目录下。下面以sshd的为例`/etc/system/system/sshd.service`：\n\n```bash\n[Unit]\nDescription=OpenSSH server daemon\n[Service]\nEnvironmentFile=/etc/sysconfig/sshd #设置环境变量\nExecStartPre=/usr/sbin/sshd-keygen\nExecStart=/usrsbin/sshd –D $OPTIONS\nExecReload=/bin/kill –HUP $MAINPID\nKillMode=process\nRestart=on-failure\nRestartSec=42s\n[Install]\nWantedBy=multi-user.target  #系统以该形式运行时，服务方可启动\n```\n\n文件分为三个小节，其中`[Unit]`段和`[Install]`段是所有Unit文件通用的，用于配置服务的描述、依赖和随系统启动方式，而`[Service]`断则是服务类型的Unit文件（后缀为.service)特有的，用于定义服务的具体管理和操作方法。\n\n在/etc/systemd/system 目录下还可以看到诸如*.wants 的目录，放在该目录下的配置单元文件等同于在`[Unit]`小节中的 wants关键字，即本单元启动时，还需要启动这些单元。比如您可以简单地把您自己写的 foo.service 文件放入 multi-user.target.wants 目录下，这样每次都会被默认启动了。\n\n### [Unit]参数\n\n+ **Description**： 一段描述这个Unit文件的文字，通常只是简短的一句话。\n+ **Documentation**：指定服务的文档，可以是一个或多个文档的URL路径。\n+ **Requires**：依赖的其他Unit列表，列在其中的Unit模块会在这个服务启动的同时被启动。\n+ **Wants**：与Requires相似，但只是在被配置的这个Unit启动时，触发启动列出的每个Unit模块，而不去考虑这些模块启动时候是否成功。\n+ **After**：与Requires相似，但是在后面列出的所有模块启动完成以后，才会启动当前的服务。与Requires不同的是，After不会因为依赖程序在运行过程中停止运行，导致当前服务也停止。\n+ **Before**：与After相反，在启动指定的任意一个模块之前，都会首先确保当前服务已经运行。\n+ **BindsTo**：与Requires非常相似，但是一种更强的关联。启动这个服务时会同时启动列出的所有模块，当有模块启动失败时终止当前服务。反之，只要列出的模块全部启动以后，就会自动启动当前服务。并且，这些模块中有任意一个出现意外结束或重启，这个服务会跟着终止或重启。\n+ **PartOf**：这是一个BindsTo作用的子集，仅在列出的任何模块失败或重启时，终止或重启当前服务，而不会随列出模块的启动而启动。\n+ **OnFailure**：当这个模块启动失败时，就自动启动列出的每个模块。\n+ **Conflicts**：与这个模块有冲突的模块，如果列出的模块中有已经在运行的，则会将已启动的冲突模块停止，并启动当前模块；反过来，冲突模块启动时会把当前模块停止。\n\n> 上面的这些配置，除了Description外，其他都可以被添加多次。比如After参数，可以使用多个After参数，也可以在一行内使用空格分割，写多个依赖模块。\n\n### [install]参数\n\n+ **WantedBy**：和前面Wants作用相似，但此处表示当前模块被依赖。\n+ **RequiredBy**：和前面的Requires作用相似，但此处表示当前模块被依赖。\n+ **Also**：当这个服务被enable/disable时，将自动enable/disable后面列出的每个模块。\n\n### [service]参数\n\n#### 服务生命周期控制相关的参数\n\n+ **Type**：服务的类型，常用的有simple（默认类型）和forking，默认的simple类型可以适用于绝大多数场景，因此一般可以忽略者这个参数的配置。对于服务进程启动后通过fork系统调用创建子进程，然后关闭应用程序本身进程的情况，则应该将Type的值设置为forking；否则Systemd将不会跟踪子进程的行为，而认为服务已经退出。\n+ **RemainAfterExit**：指为true或false（也可以写yes或no），默认为false。当配置为true时，Systemd只会负责启动服务进程，之后即便服务进程退出了，Systemd也仍然会认为这个服务还在运行中。这个配置主要是提供给一些并非常驻内存，而是启动注册后立即退出，然后等待消息按需启动的特殊类型服务使用的。\n+ **ExecStart**：这个参数是几乎每个“.service”文件都会有的，指定服务启动的主要命令，在每个配置文件中只能使用一次.\n+ **ExecStartPre**：指定在启动执行ExecStart命令前的准备工作，在同一个配置文件中可以有多个，所有命令会按照文件中书写的顺序依次被执行。\n+ **ExecStartPost**：指定在启动执行ExecStart命令后的收尾工作，在同一个配置文件中也可有多个。\n+ **TimeoutSec**：快速设置TimeoutStartSec和TimeoutStopSec参数成指定值。（另外，关于默认时间设定都在systemd配置文件中的DefaultTimeoutStartSec、DefaultTimeoutStopSec和DefaultRestartSec字段进行配置，如果这些字段缺省，DefaultTimeoutStartSec和DefaultTimeoutStopSec的默认指为90s，DefaultRestartSec默认为100ms）\n+ **TimeoutStartSec**：启动服务时的等待秒数，如果超出这个时间服务仍然没有执行完所有的启动命令，则Systemd会认为服务自动失败。这一配置对于使用Docker容器托管的应用十分重要。由于Docker第一次运行时可能会需要从网络上下载服务的镜像文件，因此造成比较严重的延时，容易被Systemd误判断为启动失败而杀死。通常，对于这种服务，需要将TimeoutStartSec设置为0，关闭超时检测。\n+ **ExecStop**：停止服务所需要执行的主要命令，在每个配置文件中只能够有一个。\n+ **ExecStopPost**：指定在ExecStop命令执行后的收尾工作，在同一配置文件中可以有多个。\n+ **TimeoutStopSec**：停止服务时的等待秒数，如果超过这个时间服务仍然没有停止，Systemd会使用SIGKILL信号强行干掉服务进程。\n+ **Restart**：这个值用于指定在什么情况下需要重启服务进程。常用的值有：no、no-success、on-failure、on-abnormal、on-abort和always。默认值为no，即不会自动重启服务。这些不同的值分别表示在哪些情况下，服务会重新启动。\n+ **RestartSec**：如果服务需要被重启，这个参数的值为服务被重启前的等待秒数。默认为100ms。\n+ **ExecReload**：重新加载服务所需执行的主要命令。\n\n#### 服务上下文配置相关的参数\n\n+ **Environment**：为服务添加环境变量，格式直接为Environment=“foo=bar”（看了一下Systemd的手册，这个参数所接受的格式有些奇葩，建议是直接“foo=bar”，取的时候使用${foo}进行获取）\n+ **EnvironmentFile**：指定加载一个包含服务所需的环境变量列表的文件，文件中的每一行都是一个环境变量的定义。顺便提一下，建议使用的时候将=换成=-，如EnvironmentFile=-/etc/my.env，和=的区别是，使用=-时，假如/etc/my.env文件不在也不会报错。\n+ **Nice**：服务的进程优先级，指越小优先级越高，默认为0，。其中-20为最高优先级，19为最低优先级。\n+ **WorkingDirectory**：指定当前服务的工作目录。\n+ **RootDirectory**：指定当前服务进程的根目录（/目录）。如果配置了这个参数，服务将无法访问指定目录外的任何文件。\n+ **User**：指定运行服务的用户，会影响服务对本地文件系统的访问权限。\n+ **Group**：指定运行服务的用户组，会影响服务对本地文件系统的访问权限。\n+ **MountFlags**：这个值其实是服务的Mount Namespace的配置，会影响服务进程上下文中挂载点的信息，即服务是否会继承主机上已有的挂载点，以及如果服务运行时执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为shared、slave和private，具体作用如下表所示：\n+ **LimitCPU/LimitSTACK/LimitNOFILE/LimitNPROC等**：限定服务可用的系统资源量，CPU、程序堆栈、文件句柄数量、子进程数量等\n\n## Systemd命令行工具的使用\n\nsystemd 的主要命令行工具是`systemctl`，可以替换`service`、`chkconfig`以及`telinit`命令的使用。\n\n### Systemd命令和sysvinit命令的对照表\n\n| Sysvinit命令 | Systemd命令 | 备注 |\n| --- | --- | --- |\n| service foo start | systemctl start foo.service | 用来启动一个服务 (并不会重启现有的) |\n| service foo stop | systemctl stop foo.service | 用来停止一个服务 (并不会重启现有的) |\n| service foo restart | systemctl restart foo.service | 用来停止并启动一个服务 |\n| service foo reload | systemctl reload foo.service | 当支持时，重新装载配置文件而不中断等待操作 |\n| service foo condrestart | systemctl condrestart foo.service | 如果服务正在运行那么重启它 |\n| service foo status | systemctl status foo.service | 汇报服务是否正在运行 |\n| ls /etc/rc.d/init.d/ | systemctl list-unit-files --type=service | 用来列出可以启动或停止的服务列表 |\n| chkconfig foo on | systemctl enable foo.service | 在下次启动时或满足其他触发条件时设置服务为启用 |\n| chkconfig foo off | systemctl disable foo.service | 在下次启动时或满足其他触发条件时设置服务为禁用 |\n| chkconfig foo | systemctl is-enabled foo.service | 用来检查一个服务在当前环境下被配置为启用还是禁用 |\n| chkconfig –list | systemctl list-unit-files --type=service | 输出在各个运行级别下服务的启用和禁用情况 |\n| chkconfig foo –list | ls /etc/systemd/system/*.wants/foo.service | 用来列出该服务在哪些运行级别下启用和禁用 |\n| chkconfig foo –add | systemctl daemon-reload | 当您创建新服务文件或者变更设置时使用 |\n| telinit 3 | systemctl isolate multi-user.target (OR systemctl isolate runlevel3.target OR telinit 3) | 改变至多用户运行级别 |\n\n### systemd电源管理命令\n\n| 命令 | 操作 |\n| --- | --- |\n| systemctl reboot | 重启机器 |\n| systemctl poweroff | 关机 |\n| systemctl suspend | 待机 |\n| systemctl hibernate | 休眠 |\n| systemctl hybrid-sleep | 混合休眠模式（同时休眠到硬盘并待机） |","content":"<h1 id=\"init系统介绍\"><a href=\"#init系统介绍\" class=\"headerlink\" title=\"init系统介绍\"></a>init系统介绍</h1><p>Linux操作系统的启动首先从BIOS开始，接下来进入bootloader，由bootloader载入内核，进行内核初始化。内核初始化的最后一步就是启动<code>pid</code>为<code>1</code>的<code>init进程</code>。init以守护进程方式存在，是系统的第一个进程,，是所有其他进程的祖先。</p>\n<p>Init系统能够定义、管理和控制 init进程的行为。它负责组织和运行许多独立的或相关的始化工作(因此被称为init系统)，从而让计算机系统进入某种用户预订的运行模式。</p>\n<p>Linux初始化init系统包括：<code>Sysvinit</code>、<code>Upstart</code>和<code>Systemd</code>，它们在Ubuntu系统下的演化如下：</p>\n<ol>\n<li><code>Ubuntu 6.10</code>及以前版本使用Sysvinit。</li>\n<li><code>Ubuntu 14.10</code>及以前版本使用Upstart，通过与Sysvinit并存。</li>\n<li><code>Ubuntu 15.04</code>开始默认使用Systemd，不能与Sysvinit或Upstart并存</li>\n</ol>\n<h1 id=\"Sysvinit介绍\"><a href=\"#Sysvinit介绍\" class=\"headerlink\" title=\"Sysvinit介绍\"></a>Sysvinit介绍</h1><blockquote>\n<p>Sysvinit就是System V风格的init系统，顾名思义，它源于System V系列UNIX。</p>\n</blockquote>\n<h2 id=\"运行级别\"><a href=\"#运行级别\" class=\"headerlink\" title=\"运行级别\"></a>运行级别</h2><p>Sysvinit用术语<code>runlevel</code>来定义”预订的运行模式”，默认的运行模式定义在<code>/etc/inittab</code>文件的<code>initdefault</code>项。如果没有默认的运行模式，那么用户将进入系统控制台，手动决定进入何种运行模式。</p>\n<p>Sysvinit中运行模式描述了系统各种预订的运行模式。通常会有8种运行模式，即运行模式<code>0-6和S</code>。其中<code>0</code>表示关机，<code>1</code>表示单用户模式，<code>3</code>为命令行模式，<code>5</code>为GUI模式，<code>6</code>表示重启，<code>1和S</code>等往往用于系统故障之后的排错和恢复。可以看出每一种运行模式所作的初始化工作是不一样的。</p>\n<h2 id=\"Sysvinit执行顺序\"><a href=\"#Sysvinit执行顺序\" class=\"headerlink\" title=\"Sysvinit执行顺序\"></a>Sysvinit执行顺序</h2><ul>\n<li>/etc/rc.d/rc.sysinit</li>\n<li>/etc/rc.d/rc 和/etc/rc.d/rcX.d/ (X 代表运行级别 0-6)</li>\n<li>/etc/rc.d/rc.local</li>\n<li>X Display Manager（可选）</li>\n</ul>\n<p>首先，运行<code>rc.sysinit</code>以便执行一些重要的系统初始化任务。</p>\n<p>然后，Sysvinit开始运行<code>/etc/rc.d/rc</code>脚本。根据不同的runlevel，rc脚本将执行<code>/etc/rc.d/rcX.d</code>(X就是runlevel)目录下的所有启动脚本。当所有的初始化脚本执行完毕。该目录下有多个脚本，为了保证系统正常关闭，脚本是要按照顺序执行的在该目录下所有以<code>K</code>开头的脚本都将在关闭系统时调用，字母<code>K</code>之后的数字定义了它们的执行顺序。</p>\n<p>然后，Sysvinit运行<code>/etc/rc.d/rc.local</code>脚本。rc.local是Linux 留给用户进行个性化设置的地方。</p>\n<h2 id=\"Sysvinit优缺点\"><a href=\"#Sysvinit优缺点\" class=\"headerlink\" title=\"Sysvinit优缺点\"></a>Sysvinit优缺点</h2><p>Sysvinit的优点：</p>\n<ol>\n<li>是概念简单，开发人员只需要编写启动和停止脚本，概念非常清楚</li>\n<li>确定的执行顺序，脚本严格按照启动数字的大小顺序执行，一个执行完毕再执行下一个，这非常有益于错误排查</li>\n</ol>\n<p>Sysvinit的缺点：</p>\n<ol>\n<li>串行地执行脚本导致Sysvinit运行效率较慢</li>\n<li>对动态设备加载等Linux新特性支持不友好</li>\n</ol>\n<h1 id=\"Upstart介绍\"><a href=\"#Upstart介绍\" class=\"headerlink\" title=\"Upstart介绍\"></a>Upstart介绍</h1><h2 id=\"开发UpStart的缘由\"><a href=\"#开发UpStart的缘由\" class=\"headerlink\" title=\"开发UpStart的缘由\"></a>开发UpStart的缘由</h2><p>当Linux内核进入2.6时代时，系统支持热插拔功能，一旦新外设连接到系统，内核便可以自动实时地发现它们，并初始化这些设备，进而使用它们。这为便携式设备用户提供了很大的灵活性。</p>\n<p>Sysvinit启动时必须一次性把所有可能用到的服务都启动起来，即使该设备没有连接，因此会造成浪费，比如为了管理打印任务，系统需要启动CUPS等服务。</p>\n<p>UpStart基于事件机制，比如U盘插入USB接口后，udev得到内核通知，发现该设备，这就是一个新的事件。UpStart在感知到该事件之后触发相应的等待任务，比如处理/etc/fstab 中存在的挂载点。采用这种事件驱动的模式，upstart 完美地解决了即插即用设备带来的新问题。</p>\n<p>UpStart相对于Sysvinit具有如下的优势：</p>\n<ul>\n<li>更快地启动系统</li>\n<li>当新硬件被发现时动态启动服务</li>\n<li>硬件被拔除时动态停止服务</li>\n</ul>\n<h2 id=\"UpStart的原理\"><a href=\"#UpStart的原理\" class=\"headerlink\" title=\"UpStart的原理\"></a>UpStart的原理</h2><p>Upstart的基本概念和设计清晰明确。UpStart主要的概念是job和event。Job就是一个工作单元，用来完成一件工作，比如启动一个后台服务，或者运行一个配置命令。每个Job都等待一个或多个事件，一旦事件发生，upstart就触发该 job 完成相应的工作。</p>\n<p>Job包括包括<code>TaskJob</code>，<code>SeriveJob</code>和<code>AbstractJob</code>。其中SeriveJob代表后台服务进程，一旦开始运行就成为一个后台进程，由init进程管理。</p>\n<p>事件是个非常抽象的概念，下面我罗列出一些常见的事件，希望可以帮助您进一步了解事件的含义：</p>\n<ul>\n<li>系统上电启动，init 进程会发送”start”事件</li>\n<li>根文件系统可写时，相应 job 会发送文件系统就绪的事件</li>\n<li>一个块设备被发现并初始化完成，发送相应的事件</li>\n<li>某个文件系统被挂载，发送相应的事件</li>\n<li>类似 atd 和 cron，可以在某个时间点，或者周期的时间点发送事件</li>\n<li>另外一个 job 开始或结束时，发送相应的事件</li>\n<li>一个磁盘文件被修改时，可以发出相应的事件</li>\n<li>一个网络设备被发现时，可以发出相应的事件</li>\n<li>缺省路由被添加或删除时，可以发出相应的事件</li>\n</ul>\n<p>系统初始化的过程是在工作和事件的相互协作下完成的，可以大致描述如下:</p>\n<blockquote>\n<p>系统初始化时，init 进程开始运行，init 进程自身会发出不同的事件，这些最初的事件会触发一些工作运行。每个工作运行过程中会释放不同的事件，这些事件又将触发新的工作运行。如此反复，直到整个系统正常运行起来。</p>\n</blockquote>\n<p>UpStart是兼容SysvInit的runlevel的，通过触发执行<code>/etc/init/rc.conf</code>来执行<code>/etc/rc$.d/</code>目录下的所有脚本。</p>\n<h1 id=\"Systemd介绍\"><a href=\"#Systemd介绍\" class=\"headerlink\" title=\"Systemd介绍\"></a>Systemd介绍</h1><p>Systemd提供了和Sysvinit以及LSBinitscripts兼容的特性。系统中已经存在的服务和进程无需修改。这降低了系统向systemd 迁移的成本，使得Systemd替换现有初始化系统成为可能。</p>\n<p>Systemd的启动速度更快，提供了比UpStart更激进的并行启动能力，采用了socket/D-Bus Activation等技术启动服务，提供按需启动的能力，只有在某个服务被真正请求的时候才启动它，当该服务结束，systemd 可以关闭它，等待下次需要时再次启动它。</p>\n<p>Systemd还提供如下等特性:</p>\n<ul>\n<li>和init比起来引导过程简化了很多</li>\n<li>Systemd支持并发引导过程从而可以更快启动</li>\n<li>通过控制组来追踪进程，而不是PID</li>\n<li>优化了处理引导过程和服务之间依赖的方式</li>\n<li>支持系统快照和恢复</li>\n<li>监控已启动的服务；也支持重启已崩溃服务</li>\n<li>包含了systemd-login模块用于控制用户登录</li>\n<li>支持加载和卸载组件</li>\n<li>低内存使用痕迹以及任务调度能力</li>\n<li>记录事件的Journald模块和记录系统日志的syslogd模块</li>\n</ul>\n<h2 id=\"Systemd的单元概念\"><a href=\"#Systemd的单元概念\" class=\"headerlink\" title=\"Systemd的单元概念\"></a>Systemd的单元概念</h2><p>系统初始化需要执行的任务非常多。每一个任务都被Systemd 抽象为一个配置单元，即unit。当前单元类型如下：</p>\n<ul>\n<li><strong>service</strong>：代表一个后台服务进程，比如 mysqld。这是最常用的一类。</li>\n<li><strong>socket</strong>：此类配置单元封装系统和互联网中的一个 套接字 。当下，systemd 支持流式、数据报和连续包的 AF_INET、AF_INET6、AF_UNIX socket 。每一个套接字配置单元都有一个相应的服务配置单元 。相应的服务在第一个”连接”进入套接字时就会启动(例如：nscd.socket 在有新连接后便启动 nscd.service)。</li>\n<li><strong>device</strong>：此类配置单元封装一个存在于 Linux 设备树中的设备。每一个使用 udev 规则标记的设备都将会在 systemd 中作为一个设备配置单元出现。</li>\n<li><strong>mount</strong>：此类配置单元封装文件系统结构层次中的一个挂载点。Systemd 将对这个挂载点进行监控和管理。比如可以在启动时自动将其挂载；可以在某些条件下自动卸载。Systemd 会将/etc/fstab 中的条目都转换为挂载点，并在开机时处理。</li>\n<li><strong>automount</strong>：此类配置单元封装系统结构层次中的一个自挂载点。每一个自挂载配置单元对应一个挂载配置单元 ，当该自动挂载点被访问时，systemd 执行挂载点中定义的挂载行为。</li>\n<li><strong>swap</strong>: 和挂载配置单元类似，交换配置单元用来管理交换分区。用户可以用交换配置单元来定义系统中的交换分区，可以让这些交换分区在启动时被激活。</li>\n<li><strong>target</strong>：此类配置单元为其他配置单元进行逻辑分组。它们本身实际上并不做什么，只是引用其他配置单元而已。这样便可以对配置单元做一个统一的控制。这样就可以实现大家都已经非常熟悉的运行级别概念。比如想让系统进入图形化模式，需要运行许多服务和配置命令，这些操作都由一个个的配置单元表示，将所有这些配置单元组合为一个目标(target)，就表示需要将这些配置单元全部执行一遍以便进入目标所代表的系统运行状态。 (例如：multi-user.target 相当于在传统使用 SysV 的系统中运行级别 5)</li>\n<li><strong>timer</strong>：定时器配置单元用来定时触发用户定义的操作，这类配置单元取代了 atd、crond 等传统的定时服务。</li>\n<li><strong>snapshot</strong>：与 target 配置单元相似，快照是一组配置单元。它保存了系统当前的运行状态。</li>\n</ul>\n<h2 id=\"Systemd的Target和运行级别\"><a href=\"#Systemd的Target和运行级别\" class=\"headerlink\" title=\"Systemd的Target和运行级别\"></a>Systemd的Target和运行级别</h2><p>systemd使用目标（target）替代了运行级别的概念，提供了更大的灵活性，如您可以继承一个已有的目标，并添加其它服务，来创建自己的目标。通过target文件夹的命令也可以看出对应的runlevel：</p>\n<table>\n<thead>\n<tr>\n<th>Sysvinit运行级别</th>\n<th>Systemd目标</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>poweroff.target</td>\n<td>关闭系统</td>\n</tr>\n<tr>\n<td>1,s</td>\n<td>rescue.target</td>\n<td>单用户模式</td>\n</tr>\n<tr>\n<td>2,4</td>\n<td>multi-user.target</td>\n<td>多用户，非图形化</td>\n</tr>\n<tr>\n<td>3</td>\n<td>multi-user.target</td>\n<td>多用户，非图形化</td>\n</tr>\n<tr>\n<td>5</td>\n<td>graphical.target</td>\n<td>多用户，图形化</td>\n</tr>\n<tr>\n<td>6</td>\n<td>reboot.target</td>\n<td>重启</td>\n</tr>\n</tbody>\n</table>\n<img src=\"/posts/Linux初始化init系统/2018-09-22-16-29-55.png\" title=\"[blog.ruanxinyu.cn]\">\n<h2 id=\"使用C-C-开发新的系统服务\"><a href=\"#使用C-C-开发新的系统服务\" class=\"headerlink\" title=\"使用C/C++开发新的系统服务\"></a>使用C/C++开发新的系统服务</h2><p>使用C/C++开发新的系统服务可能需要关注如下的内容：</p>\n<ol>\n<li>后台服务进程代码不需要执行两次派生来实现后台精灵进程，只需要实现服务本身的主循环即可。</li>\n<li>不要调用 setsid()，交给 systemd 处理</li>\n<li>不再需要维护 pid 文件。</li>\n<li>Systemd 提供了日志功能，服务进程只需要输出到 stderr 即可，无需使用 syslog。</li>\n<li>处理信号 SIGTERM，这个信号的唯一正确作用就是停止当前服务，不要做其他的事情。</li>\n<li>SIGHUP 信号的作用是重启服务。</li>\n<li>需要套接字的服务，不要自己创建套接字，让 systemd 传入套接字。</li>\n<li>使用 sd_notify()函数通知 systemd 服务自己的状态改变。一般地，当服务初始化结束，进入服务就绪状态时，可以调用它。</li>\n</ol>\n<h2 id=\"Unit文件的编写\"><a href=\"#Unit文件的编写\" class=\"headerlink\" title=\"Unit文件的编写\"></a>Unit文件的编写</h2><p>服务配置单元文件以<code>.service</code>为文件名后缀，默认时存放在<code>/lib/systemd/system/</code>目录下，然后链接到<code>/etc/systemd/system/</code>对应的目录下。下面以sshd的为例<code>/etc/system/system/sshd.service</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=OpenSSH server daemon</span><br><span class=\"line\">[Service]</span><br><span class=\"line\">EnvironmentFile=/etc/sysconfig/sshd <span class=\"comment\">#设置环境变量</span></span><br><span class=\"line\">ExecStartPre=/usr/sbin/sshd-keygen</span><br><span class=\"line\">ExecStart=/usrsbin/sshd –D <span class=\"variable\">$OPTIONS</span></span><br><span class=\"line\">ExecReload=/bin/<span class=\"built_in\">kill</span> –HUP <span class=\"variable\">$MAINPID</span></span><br><span class=\"line\">KillMode=process</span><br><span class=\"line\">Restart=on-failure</span><br><span class=\"line\">RestartSec=42s</span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target  <span class=\"comment\">#系统以该形式运行时，服务方可启动</span></span><br></pre></td></tr></table></figure>\n<p>文件分为三个小节，其中<code>[Unit]</code>段和<code>[Install]</code>段是所有Unit文件通用的，用于配置服务的描述、依赖和随系统启动方式，而<code>[Service]</code>断则是服务类型的Unit文件（后缀为.service)特有的，用于定义服务的具体管理和操作方法。</p>\n<p>在/etc/systemd/system 目录下还可以看到诸如*.wants 的目录，放在该目录下的配置单元文件等同于在<code>[Unit]</code>小节中的 wants关键字，即本单元启动时，还需要启动这些单元。比如您可以简单地把您自己写的 foo.service 文件放入 multi-user.target.wants 目录下，这样每次都会被默认启动了。</p>\n<h3 id=\"Unit-参数\"><a href=\"#Unit-参数\" class=\"headerlink\" title=\"[Unit]参数\"></a>[Unit]参数</h3><ul>\n<li><strong>Description</strong>： 一段描述这个Unit文件的文字，通常只是简短的一句话。</li>\n<li><strong>Documentation</strong>：指定服务的文档，可以是一个或多个文档的URL路径。</li>\n<li><strong>Requires</strong>：依赖的其他Unit列表，列在其中的Unit模块会在这个服务启动的同时被启动。</li>\n<li><strong>Wants</strong>：与Requires相似，但只是在被配置的这个Unit启动时，触发启动列出的每个Unit模块，而不去考虑这些模块启动时候是否成功。</li>\n<li><strong>After</strong>：与Requires相似，但是在后面列出的所有模块启动完成以后，才会启动当前的服务。与Requires不同的是，After不会因为依赖程序在运行过程中停止运行，导致当前服务也停止。</li>\n<li><strong>Before</strong>：与After相反，在启动指定的任意一个模块之前，都会首先确保当前服务已经运行。</li>\n<li><strong>BindsTo</strong>：与Requires非常相似，但是一种更强的关联。启动这个服务时会同时启动列出的所有模块，当有模块启动失败时终止当前服务。反之，只要列出的模块全部启动以后，就会自动启动当前服务。并且，这些模块中有任意一个出现意外结束或重启，这个服务会跟着终止或重启。</li>\n<li><strong>PartOf</strong>：这是一个BindsTo作用的子集，仅在列出的任何模块失败或重启时，终止或重启当前服务，而不会随列出模块的启动而启动。</li>\n<li><strong>OnFailure</strong>：当这个模块启动失败时，就自动启动列出的每个模块。</li>\n<li><strong>Conflicts</strong>：与这个模块有冲突的模块，如果列出的模块中有已经在运行的，则会将已启动的冲突模块停止，并启动当前模块；反过来，冲突模块启动时会把当前模块停止。</li>\n</ul>\n<blockquote>\n<p>上面的这些配置，除了Description外，其他都可以被添加多次。比如After参数，可以使用多个After参数，也可以在一行内使用空格分割，写多个依赖模块。</p>\n</blockquote>\n<h3 id=\"install-参数\"><a href=\"#install-参数\" class=\"headerlink\" title=\"[install]参数\"></a>[install]参数</h3><ul>\n<li><strong>WantedBy</strong>：和前面Wants作用相似，但此处表示当前模块被依赖。</li>\n<li><strong>RequiredBy</strong>：和前面的Requires作用相似，但此处表示当前模块被依赖。</li>\n<li><strong>Also</strong>：当这个服务被enable/disable时，将自动enable/disable后面列出的每个模块。</li>\n</ul>\n<h3 id=\"service-参数\"><a href=\"#service-参数\" class=\"headerlink\" title=\"[service]参数\"></a>[service]参数</h3><h4 id=\"服务生命周期控制相关的参数\"><a href=\"#服务生命周期控制相关的参数\" class=\"headerlink\" title=\"服务生命周期控制相关的参数\"></a>服务生命周期控制相关的参数</h4><ul>\n<li><strong>Type</strong>：服务的类型，常用的有simple（默认类型）和forking，默认的simple类型可以适用于绝大多数场景，因此一般可以忽略者这个参数的配置。对于服务进程启动后通过fork系统调用创建子进程，然后关闭应用程序本身进程的情况，则应该将Type的值设置为forking；否则Systemd将不会跟踪子进程的行为，而认为服务已经退出。</li>\n<li><strong>RemainAfterExit</strong>：指为true或false（也可以写yes或no），默认为false。当配置为true时，Systemd只会负责启动服务进程，之后即便服务进程退出了，Systemd也仍然会认为这个服务还在运行中。这个配置主要是提供给一些并非常驻内存，而是启动注册后立即退出，然后等待消息按需启动的特殊类型服务使用的。</li>\n<li><strong>ExecStart</strong>：这个参数是几乎每个“.service”文件都会有的，指定服务启动的主要命令，在每个配置文件中只能使用一次.</li>\n<li><strong>ExecStartPre</strong>：指定在启动执行ExecStart命令前的准备工作，在同一个配置文件中可以有多个，所有命令会按照文件中书写的顺序依次被执行。</li>\n<li><strong>ExecStartPost</strong>：指定在启动执行ExecStart命令后的收尾工作，在同一个配置文件中也可有多个。</li>\n<li><strong>TimeoutSec</strong>：快速设置TimeoutStartSec和TimeoutStopSec参数成指定值。（另外，关于默认时间设定都在systemd配置文件中的DefaultTimeoutStartSec、DefaultTimeoutStopSec和DefaultRestartSec字段进行配置，如果这些字段缺省，DefaultTimeoutStartSec和DefaultTimeoutStopSec的默认指为90s，DefaultRestartSec默认为100ms）</li>\n<li><strong>TimeoutStartSec</strong>：启动服务时的等待秒数，如果超出这个时间服务仍然没有执行完所有的启动命令，则Systemd会认为服务自动失败。这一配置对于使用Docker容器托管的应用十分重要。由于Docker第一次运行时可能会需要从网络上下载服务的镜像文件，因此造成比较严重的延时，容易被Systemd误判断为启动失败而杀死。通常，对于这种服务，需要将TimeoutStartSec设置为0，关闭超时检测。</li>\n<li><strong>ExecStop</strong>：停止服务所需要执行的主要命令，在每个配置文件中只能够有一个。</li>\n<li><strong>ExecStopPost</strong>：指定在ExecStop命令执行后的收尾工作，在同一配置文件中可以有多个。</li>\n<li><strong>TimeoutStopSec</strong>：停止服务时的等待秒数，如果超过这个时间服务仍然没有停止，Systemd会使用SIGKILL信号强行干掉服务进程。</li>\n<li><strong>Restart</strong>：这个值用于指定在什么情况下需要重启服务进程。常用的值有：no、no-success、on-failure、on-abnormal、on-abort和always。默认值为no，即不会自动重启服务。这些不同的值分别表示在哪些情况下，服务会重新启动。</li>\n<li><strong>RestartSec</strong>：如果服务需要被重启，这个参数的值为服务被重启前的等待秒数。默认为100ms。</li>\n<li><strong>ExecReload</strong>：重新加载服务所需执行的主要命令。</li>\n</ul>\n<h4 id=\"服务上下文配置相关的参数\"><a href=\"#服务上下文配置相关的参数\" class=\"headerlink\" title=\"服务上下文配置相关的参数\"></a>服务上下文配置相关的参数</h4><ul>\n<li><strong>Environment</strong>：为服务添加环境变量，格式直接为Environment=“foo=bar”（看了一下Systemd的手册，这个参数所接受的格式有些奇葩，建议是直接“foo=bar”，取的时候使用${foo}进行获取）</li>\n<li><strong>EnvironmentFile</strong>：指定加载一个包含服务所需的环境变量列表的文件，文件中的每一行都是一个环境变量的定义。顺便提一下，建议使用的时候将=换成=-，如EnvironmentFile=-/etc/my.env，和=的区别是，使用=-时，假如/etc/my.env文件不在也不会报错。</li>\n<li><strong>Nice</strong>：服务的进程优先级，指越小优先级越高，默认为0，。其中-20为最高优先级，19为最低优先级。</li>\n<li><strong>WorkingDirectory</strong>：指定当前服务的工作目录。</li>\n<li><strong>RootDirectory</strong>：指定当前服务进程的根目录（/目录）。如果配置了这个参数，服务将无法访问指定目录外的任何文件。</li>\n<li><strong>User</strong>：指定运行服务的用户，会影响服务对本地文件系统的访问权限。</li>\n<li><strong>Group</strong>：指定运行服务的用户组，会影响服务对本地文件系统的访问权限。</li>\n<li><strong>MountFlags</strong>：这个值其实是服务的Mount Namespace的配置，会影响服务进程上下文中挂载点的信息，即服务是否会继承主机上已有的挂载点，以及如果服务运行时执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为shared、slave和private，具体作用如下表所示：</li>\n<li><strong>LimitCPU/LimitSTACK/LimitNOFILE/LimitNPROC等</strong>：限定服务可用的系统资源量，CPU、程序堆栈、文件句柄数量、子进程数量等</li>\n</ul>\n<h2 id=\"Systemd命令行工具的使用\"><a href=\"#Systemd命令行工具的使用\" class=\"headerlink\" title=\"Systemd命令行工具的使用\"></a>Systemd命令行工具的使用</h2><p>systemd 的主要命令行工具是<code>systemctl</code>，可以替换<code>service</code>、<code>chkconfig</code>以及<code>telinit</code>命令的使用。</p>\n<h3 id=\"Systemd命令和sysvinit命令的对照表\"><a href=\"#Systemd命令和sysvinit命令的对照表\" class=\"headerlink\" title=\"Systemd命令和sysvinit命令的对照表\"></a>Systemd命令和sysvinit命令的对照表</h3><table>\n<thead>\n<tr>\n<th>Sysvinit命令</th>\n<th>Systemd命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>service foo start</td>\n<td>systemctl start foo.service</td>\n<td>用来启动一个服务 (并不会重启现有的)</td>\n</tr>\n<tr>\n<td>service foo stop</td>\n<td>systemctl stop foo.service</td>\n<td>用来停止一个服务 (并不会重启现有的)</td>\n</tr>\n<tr>\n<td>service foo restart</td>\n<td>systemctl restart foo.service</td>\n<td>用来停止并启动一个服务</td>\n</tr>\n<tr>\n<td>service foo reload</td>\n<td>systemctl reload foo.service</td>\n<td>当支持时，重新装载配置文件而不中断等待操作</td>\n</tr>\n<tr>\n<td>service foo condrestart</td>\n<td>systemctl condrestart foo.service</td>\n<td>如果服务正在运行那么重启它</td>\n</tr>\n<tr>\n<td>service foo status</td>\n<td>systemctl status foo.service</td>\n<td>汇报服务是否正在运行</td>\n</tr>\n<tr>\n<td>ls /etc/rc.d/init.d/</td>\n<td>systemctl list-unit-files –type=service</td>\n<td>用来列出可以启动或停止的服务列表</td>\n</tr>\n<tr>\n<td>chkconfig foo on</td>\n<td>systemctl enable foo.service</td>\n<td>在下次启动时或满足其他触发条件时设置服务为启用</td>\n</tr>\n<tr>\n<td>chkconfig foo off</td>\n<td>systemctl disable foo.service</td>\n<td>在下次启动时或满足其他触发条件时设置服务为禁用</td>\n</tr>\n<tr>\n<td>chkconfig foo</td>\n<td>systemctl is-enabled foo.service</td>\n<td>用来检查一个服务在当前环境下被配置为启用还是禁用</td>\n</tr>\n<tr>\n<td>chkconfig –list</td>\n<td>systemctl list-unit-files –type=service</td>\n<td>输出在各个运行级别下服务的启用和禁用情况</td>\n</tr>\n<tr>\n<td>chkconfig foo –list</td>\n<td>ls /etc/systemd/system/*.wants/foo.service</td>\n<td>用来列出该服务在哪些运行级别下启用和禁用</td>\n</tr>\n<tr>\n<td>chkconfig foo –add</td>\n<td>systemctl daemon-reload</td>\n<td>当您创建新服务文件或者变更设置时使用</td>\n</tr>\n<tr>\n<td>telinit 3</td>\n<td>systemctl isolate multi-user.target (OR systemctl isolate runlevel3.target OR telinit 3)</td>\n<td>改变至多用户运行级别</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"systemd电源管理命令\"><a href=\"#systemd电源管理命令\" class=\"headerlink\" title=\"systemd电源管理命令\"></a>systemd电源管理命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>systemctl reboot</td>\n<td>重启机器</td>\n</tr>\n<tr>\n<td>systemctl poweroff</td>\n<td>关机</td>\n</tr>\n<tr>\n<td>systemctl suspend</td>\n<td>待机</td>\n</tr>\n<tr>\n<td>systemctl hibernate</td>\n<td>休眠</td>\n</tr>\n<tr>\n<td>systemctl hybrid-sleep</td>\n<td>混合休眠模式（同时休眠到硬盘并待机）</td>\n</tr>\n</tbody>\n</table>\n","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ruanxinyu.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://ruanxinyu.github.io/tags/Linux/"}]},{"title":"Ubuntu下KeepAlived的安装与配置","slug":"Ubuntu下KeepAlived的安装与配置","date":"un22fin22","updated":"un55fin55","comments":true,"path":"posts/Ubuntu下KeepAlived的安装与配置/","link":"","permalink":"http://ruanxinyu.github.io/posts/Ubuntu下KeepAlived的安装与配置/","excerpt":"","keywords":"","text":"KeepAlived介绍Keepalived是一个基于VRRP协议来实现的服务高可用方案，可以利用其来避免IP单点故障，一般与其它负载均衡技术（如lvs、haproxy、nginx）一起工作来达到集群的高可用。 健康检查和失败切换是keepalived的两大核心功能。 keepalived的健康检查支持tcp三次握手、icmp请求、http请求、udp和echo请求等方式对负载均衡器后面的实际的服务器)进行保活，具体采用哪种检查方式可以根据自己的业务需要进行选择； 失败切换主要是应用于配置了主备模式的负载均衡器， 由VRRP(虚拟路由冗余协议）协议实现，对外提供一个VIP（虚拟IP），VIP在其中master机器上，当该机器出现故障时，VIP会自动漂移到slave的机器上，从而保证对外的功能是正常的。如果mastr机器功能正常之后，会自动加入到服务器集群中，无需人工干预，只需要人工做修复故障的服务器。 VRRP协议介绍VRRP（虚拟路由协议，virtual redundant routing protocol)是为消除网络设备单点故障而设计的主备模式的协议，使得在发生故障时，可以在不影响内外数据通信，不修改内部网络的网络参数的情况下切换设备。 VRRP协议通过配置虚拟路由ID(VRID)来将两台或多台设备虚拟成一个虚拟设备，对外提供一个或多个虚拟IP(VIP)和虚拟的MAC地址（VMC），通过该VIP和VMC对外提供服务，可以保证在设备切换时网络参数不变。所以当VIP在哪一台设备上，则该设备为master节点对外提供服务，其他的节点为backup节点不实际对外提供服务。 VRRP协议通过心跳算法自动选举哪个节点为master节点，默认使用多播数据来传输VRRP数据。通过配置文件可以指定每个设备的优先级，所以在初始状态时，优先级最大的为master节点。VRRP运行时只有MASTER路由器定时发送VRRP通告信息，表示master工作正常，backup只接收VRRP数据，不发送数据，如果一定时间内没有接收到master的通告信息，各backup将宣告自己成为master，发送通告信息，重新进行master选举状态。 KeepAlived的安装该教程使用的Ubuntu版本是18.04.1版本，Ubuntu的安装教程参考VirtualBox安装Ubuntu教程。KeepAlived可以直接通过apt-get安装，也可以通过源码编译安装。 apt-get安装Ubuntu下执行sudo apt-get install keepalived命令即可安装。 通过which keepalived可以看到KeepAlived是安装在/usr/sbin/keepalived下。 使用sudo service keepalived start即可启动KeepAlived。 源码编译安装源码安装的脚本可以点击此处下载： keepalived_install.sh，下面对安装过程做一下说明。 首先安装编译工具和openssl，下载KeepAlived源码并解压，然后执行源码编译三件套（./configure &amp;&amp; make &amp;&amp; make install），我们安装的目录为/usr/local/keepalived： 1234567sudo apt-get install build-essential libssl-dev # 安装编译工具和openssl依赖wget http://www.keepalived.org/software/keepalived-2.0.7.tar.gz # 下载源码tar -zxvf keepalived-2.0.7.tar.gz # 解压源码cd keepalived-2.0.7/./configure --prefix=/usr/local/keepalived # 配置keepalived的安装目录make # 编译源码sudo make install # 安装到安装目录，需要使用root权限 可能遇到的问题 执行./configure时提示g++ is not found 源码安装需要安装编译器将源码转换为二进制可执行文件，因此执行sudo apt-get install build-essential安装编译器即可 执行./configure时提示OpenSSL is not properly installed on your system 你的系统没有安装openssl，执行sudo apt-get install libssl-dev即可 守护进程和开机启动由于Ubunt 18.04.1默认使用Systemd作为init程序，因此设置守护进程也采用该方式，了解详细请参考Linux初始化init系统：Sysvinit、Upstart和Systemd 首先，创建相关文件的链接： 1234sudo mkdir -p /etc/keepalivedsudo ln -s /usr/local/keepalived/sbin/keepalived /usr/sbin/sudo ln -s /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/keepalived.confsudo ln -s /usr/local/keepalived/etc/sysconfig/keepalived /etc/default/keepalived 我们还是采用systemd的方式添加到系统服务，执行如下命令： 123456789101112131415161718192021222324(cat &lt;&lt;EOF[Unit]Description=Keepalive Daemon (LVS and VRRP)After=syslog.target network-online.targetWants=network-online.target# Only start if there is a configuration fileConditionFileNotEmpty=/etc/keepalived/keepalived.conf[Service]Type=forkingKillMode=process# Read configuration variable file if it is presentEnvironmentFile=-/etc/default/keepalivedExecStart=/usr/sbin/keepalived $KEEPALIVED_OPTIONSExecReload=/bin/kill -HUP $MAINPID[Install]WantedBy=multi-user.targetEOF) &gt; keepalived.servicesudo cp -a keepalived.service /lib/systemd/system/keepalived.servicesudo ln -s /lib/systemd/system/keepalived.service /etc/systemd/system/multi-user.target.wants/keepalived.service 启动keepalived进程，并设置为开机启动，通过sudo systemctl status keepalived查看状态： 123sudo systemctl start keepalivedsudo systemctl status keepalivedsudo systemctl enable keepalived KeepAlive的配置keepalived.conf在keepalived的安装目录/usr/local/keepalived/etc/keepalived/samples/有很多样例配置，每一种配置对应的都是一种使用场景，后续会做详细说明，因此在此处不做过多的分析。 此处使用最简单的配置入门，假设我们以/tmp/目录下是否存在service_ok这个文件来判断服务是否可用。可参考样例/usr/local/keepalived/etc/keepalived/samples/keepalived.conf.vrrp.localcheck 12345678910111213141516171819vrrp_script chk_service_ok &#123; script \"ls /tmp/service_ok\" # 检查文件是否存在 interval 2 # 每两秒钟检查一次&#125;vrrp_instance VI_1 &#123; interface enp0s3 # 指定网卡 state MASTER # 角色，主机为MASTER，备机为BACKUP virtual_router_id 51 # 虚拟路由Id，相同的ID表示在相同的组 priority 100 # 优先级，MASTER的优先级要比BACKUP的大 virtual_ipaddress &#123; # 虚拟IP地址，即VIP 192.168.42.23/25 &#125; track_script &#123; # 设置vrrp检查脚本的名称 chk_service_ok &#125;&#125; KeepAlived的验证我们使用两台虚拟机，IP地址分别为主机vm01（192.168.42.21）和备机vm02（192.168.42.22）， VIP为192.168.42.23。安装好KeepAlived后, 编辑配置文件sudo vim /etc/keepalived/keepalived.conf 主机vm01（192.168.42.21）的配置如下： 12345678910111213141516171819vrrp_script chk_service_ok &#123; script \"ls /tmp/service_ok\" interval 2&#125;vrrp_instance VI_1 &#123; interface enp0s3 state MASTER virtual_router_id 51 priority 100 virtual_ipaddress &#123; 192.168.42.23/25 &#125; track_script &#123; chk_service_ok &#125;&#125; 备机vm02（192.168.42.22）的配置如下，相对于vm01，只修改state和priority: 12345678910111213141516171819vrrp_script chk_service_ok &#123; script \"ls /tmp/service_ok\" interval 2&#125;vrrp_instance VI_1 &#123; interface enp0s3 state BACKUP virtual_router_id 51 priority 80 virtual_ipaddress &#123; 192.168.42.23/25 &#125; track_script &#123; chk_service_ok &#125;&#125; 首先，我们在两台机器上都创建一个system_ok文件，表示机器是OK的，touch /tmp/service_ok。然后执行sudo systemctl restart keepalived重新启动两台机器的keepalived。 分别在两台机器上执行ip a查看机器的网络信息，可以发现VIP（192.168.42.23）已经在主机vm01上，我们通过ssh ruan@192.168.42.23登陆到的也是主机vm01。 我们删除主机vm01上的/tmp/service_ok文件，然后重新执行ip a，发现VIP（192.168.42.23）已经漂移到备机vm02上，此时我们通过ssh ruan@192.168.42.23登陆则是备机vm02。即当主机故障时，业务可以自动切换至备机。 我们重新创建主机vm01上的/tmp/service_ok文件，，然后重新执行ip a，发现VIP（192.168.42.23）已经重新漂移到备机vm01上，此时我们通过ssh ruan@192.168.42.23登陆重新回到主机vm01。即当主机恢复时，可以自动将该主机加入到服务器群提供服务。","raw":"---\ntitle: Ubuntu下KeepAlived的安装与配置\ntags: 环境搭建\ncategories: 环境搭建\ndate: 2018-09-18 20:42:46\n---\n\n# KeepAlived介绍\n\nKeepalived是一个基于VRRP协议来实现的服务高可用方案，可以利用其来避免IP单点故障，一般与其它负载均衡技术（如lvs、haproxy、nginx）一起工作来达到集群的高可用。\n\n健康检查和失败切换是keepalived的两大核心功能。\n\nkeepalived的健康检查支持tcp三次握手、icmp请求、http请求、udp和echo请求等方式对负载均衡器后面的实际的服务器)进行保活，具体采用哪种检查方式可以根据自己的业务需要进行选择；\n\n失败切换主要是应用于配置了主备模式的负载均衡器， 由VRRP(虚拟路由冗余协议）协议实现，对外提供一个VIP（虚拟IP），VIP在其中master机器上，当该机器出现故障时，VIP会自动漂移到slave的机器上，从而保证对外的功能是正常的。如果mastr机器功能正常之后，会自动加入到服务器集群中，无需人工干预，只需要人工做修复故障的服务器。\n\n# VRRP协议介绍\n\nVRRP（虚拟路由协议，virtual redundant routing protocol)是为消除网络设备单点故障而设计的主备模式的协议，使得在发生故障时，可以在不影响内外数据通信，不修改内部网络的网络参数的情况下切换设备。\n\nVRRP协议通过配置虚拟路由ID(VRID)来将两台或多台设备虚拟成一个虚拟设备，对外提供一个或多个虚拟IP(VIP)和虚拟的MAC地址（VMC），通过该VIP和VMC对外提供服务，可以保证在设备切换时网络参数不变。所以当VIP在哪一台设备上，则该设备为master节点对外提供服务，其他的节点为backup节点不实际对外提供服务。\n\nVRRP协议通过心跳算法自动选举哪个节点为master节点，默认使用多播数据来传输VRRP数据。通过配置文件可以指定每个设备的优先级，所以在初始状态时，优先级最大的为master节点。VRRP运行时只有MASTER路由器定时发送VRRP通告信息，表示master工作正常，backup只接收VRRP数据，不发送数据，如果一定时间内没有接收到master的通告信息，各backup将宣告自己成为master，发送通告信息，重新进行master选举状态。\n\n# KeepAlived的安装\n\n该教程使用的Ubuntu版本是18.04.1版本，Ubuntu的安装教程参考{% post_link VirtualBox安装Ubuntu教程 %}。KeepAlived可以直接通过apt-get安装，也可以通过源码编译安装。\n\n## apt-get安装\n\nUbuntu下执行`sudo apt-get install keepalived`命令即可安装。\n\n通过`which keepalived`可以看到KeepAlived是安装在`/usr/sbin/keepalived`下。\n\n使用`sudo service keepalived start`即可启动KeepAlived。\n\n## 源码编译安装\n\n源码安装的脚本可以点击此处下载： {% asset_link keepalived_install.sh keepalived_install.sh %}，下面对安装过程做一下说明。\n\n首先安装编译工具和openssl，下载KeepAlived源码并解压，然后执行源码编译三件套（`./configure && make && make install`），我们安装的目录为`/usr/local/keepalived`：\n\n```bash\nsudo apt-get install build-essential libssl-dev # 安装编译工具和openssl依赖\nwget http://www.keepalived.org/software/keepalived-2.0.7.tar.gz # 下载源码\ntar -zxvf keepalived-2.0.7.tar.gz # 解压源码\ncd keepalived-2.0.7/\n./configure --prefix=/usr/local/keepalived # 配置keepalived的安装目录\nmake # 编译源码\nsudo make install # 安装到安装目录，需要使用root权限\n```\n\n**可能遇到的问题**\n\n1. 执行`./configure`时提示`g++ is not found`\n> 源码安装需要安装编译器将源码转换为二进制可执行文件，因此执行`sudo apt-get install build-essential`安装编译器即可\n\n1. 执行`./configure`时提示`OpenSSL is not properly installed on your system`\n> 你的系统没有安装openssl，执行`sudo apt-get install libssl-dev`即可\n\n# 守护进程和开机启动\n\n由于Ubunt 18.04.1默认使用Systemd作为init程序，因此设置守护进程也采用该方式，了解详细请参考{% post_link Linux初始化init系统 %}\n\n首先，创建相关文件的链接：\n\n```bash\nsudo mkdir -p /etc/keepalived\nsudo ln -s /usr/local/keepalived/sbin/keepalived /usr/sbin/\nsudo ln -s /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf\nsudo ln -s /usr/local/keepalived/etc/sysconfig/keepalived /etc/default/keepalived\n```\n\n我们还是采用systemd的方式添加到系统服务，执行如下命令：\n\n```bash\n(\ncat <<EOF\n[Unit]\nDescription=Keepalive Daemon (LVS and VRRP)\nAfter=syslog.target network-online.target\nWants=network-online.target\n# Only start if there is a configuration file\nConditionFileNotEmpty=/etc/keepalived/keepalived.conf\n\n[Service]\nType=forking\nKillMode=process\n# Read configuration variable file if it is present\nEnvironmentFile=-/etc/default/keepalived\nExecStart=/usr/sbin/keepalived $KEEPALIVED_OPTIONS\nExecReload=/bin/kill -HUP $MAINPID\n\n[Install]\nWantedBy=multi-user.target\nEOF\n) > keepalived.service\n\nsudo cp -a keepalived.service /lib/systemd/system/keepalived.service\nsudo ln -s /lib/systemd/system/keepalived.service /etc/systemd/system/multi-user.target.wants/keepalived.service\n```\n\n启动keepalived进程，并设置为开机启动，通过`sudo systemctl status keepalived`查看状态：\n\n```bash\nsudo systemctl start keepalived\nsudo systemctl status keepalived\nsudo systemctl enable keepalived\n```\n\n{% asset_img 2018-09-24-16-41-22.png [blog.ruanxinyu.cn] %}\n\n# KeepAlive的配置\n\n## keepalived.conf\n\n在keepalived的安装目录`/usr/local/keepalived/etc/keepalived/samples/`有很多样例配置，每一种配置对应的都是一种使用场景，后续会做详细说明，因此在此处不做过多的分析。\n\n此处使用最简单的配置入门，假设我们以`/tmp/`目录下是否存在`service_ok`这个文件来判断服务是否可用。可参考样例`/usr/local/keepalived/etc/keepalived/samples/keepalived.conf.vrrp.localcheck`\n\n```bash\nvrrp_script chk_service_ok {\n       script \"ls /tmp/service_ok\"    # 检查文件是否存在\n       interval 2                     # 每两秒钟检查一次\n}\n\nvrrp_instance VI_1 {\n    interface enp0s3                  # 指定网卡\n    state MASTER                      # 角色，主机为MASTER，备机为BACKUP\n    virtual_router_id 51              # 虚拟路由Id，相同的ID表示在相同的组\n    priority 100                      # 优先级，MASTER的优先级要比BACKUP的大\n\n    virtual_ipaddress {               # 虚拟IP地址，即VIP\n        192.168.42.23/25\n    }\n\n    track_script {                    # 设置vrrp检查脚本的名称\n       chk_service_ok\n    }\n}\n```\n\n# KeepAlived的验证\n\n我们使用两台虚拟机，IP地址分别为主机vm01（`192.168.42.21`）和备机vm02（`192.168.42.22`）， VIP为`192.168.42.23`。安装好KeepAlived后, 编辑配置文件`sudo vim /etc/keepalived/keepalived.conf`\n\n1. 主机vm01（`192.168.42.21`）的配置如下：\n\n```bash\nvrrp_script chk_service_ok {\n       script \"ls /tmp/service_ok\"\n       interval 2\n}\n\nvrrp_instance VI_1 {\n    interface enp0s3\n    state MASTER\n    virtual_router_id 51\n    priority 100\n\n    virtual_ipaddress {\n        192.168.42.23/25\n    }\n\n    track_script {\n       chk_service_ok\n    }\n}\n```\n\n1. 备机vm02（`192.168.42.22`）的配置如下，相对于vm01，只修改`state`和`priority`:\n\n```bash\nvrrp_script chk_service_ok {\n       script \"ls /tmp/service_ok\"\n       interval 2\n}\n\nvrrp_instance VI_1 {\n    interface enp0s3\n    state BACKUP\n    virtual_router_id 51\n    priority 80\n\n    virtual_ipaddress {\n        192.168.42.23/25\n    }\n\n    track_script {\n       chk_service_ok\n    }\n}\n```\n\n首先，我们在两台机器上都创建一个system_ok文件，表示机器是OK的，`touch /tmp/service_ok`。然后执行`sudo systemctl restart keepalived`重新启动两台机器的keepalived。\n\n分别在两台机器上执行`ip a`查看机器的网络信息，可以发现VIP（`192.168.42.23`）已经在主机vm01上，我们通过`ssh ruan@192.168.42.23`登陆到的也是主机vm01。\n\n{% asset_img 2018-09-24-16-53-52.png [blog.ruanxinyu.cn] %}\n\n我们删除主机vm01上的`/tmp/service_ok`文件，然后重新执行`ip a`，发现VIP（`192.168.42.23`）已经漂移到备机vm02上，此时我们通过`ssh ruan@192.168.42.23`登陆则是备机vm02。即当主机故障时，业务可以自动切换至备机。\n\n{% asset_img 2018-09-24-16-58-02.png [blog.ruanxinyu.cn] %}\n\n我们重新创建主机vm01上的`/tmp/service_ok`文件，，然后重新执行`ip a`，发现VIP（`192.168.42.23`）已经重新漂移到备机vm01上，此时我们通过`ssh ruan@192.168.42.23`登陆重新回到主机vm01。即当主机恢复时，可以自动将该主机加入到服务器群提供服务。","content":"<h1 id=\"KeepAlived介绍\"><a href=\"#KeepAlived介绍\" class=\"headerlink\" title=\"KeepAlived介绍\"></a>KeepAlived介绍</h1><p>Keepalived是一个基于VRRP协议来实现的服务高可用方案，可以利用其来避免IP单点故障，一般与其它负载均衡技术（如lvs、haproxy、nginx）一起工作来达到集群的高可用。</p>\n<p>健康检查和失败切换是keepalived的两大核心功能。</p>\n<p>keepalived的健康检查支持tcp三次握手、icmp请求、http请求、udp和echo请求等方式对负载均衡器后面的实际的服务器)进行保活，具体采用哪种检查方式可以根据自己的业务需要进行选择；</p>\n<p>失败切换主要是应用于配置了主备模式的负载均衡器， 由VRRP(虚拟路由冗余协议）协议实现，对外提供一个VIP（虚拟IP），VIP在其中master机器上，当该机器出现故障时，VIP会自动漂移到slave的机器上，从而保证对外的功能是正常的。如果mastr机器功能正常之后，会自动加入到服务器集群中，无需人工干预，只需要人工做修复故障的服务器。</p>\n<h1 id=\"VRRP协议介绍\"><a href=\"#VRRP协议介绍\" class=\"headerlink\" title=\"VRRP协议介绍\"></a>VRRP协议介绍</h1><p>VRRP（虚拟路由协议，virtual redundant routing protocol)是为消除网络设备单点故障而设计的主备模式的协议，使得在发生故障时，可以在不影响内外数据通信，不修改内部网络的网络参数的情况下切换设备。</p>\n<p>VRRP协议通过配置虚拟路由ID(VRID)来将两台或多台设备虚拟成一个虚拟设备，对外提供一个或多个虚拟IP(VIP)和虚拟的MAC地址（VMC），通过该VIP和VMC对外提供服务，可以保证在设备切换时网络参数不变。所以当VIP在哪一台设备上，则该设备为master节点对外提供服务，其他的节点为backup节点不实际对外提供服务。</p>\n<p>VRRP协议通过心跳算法自动选举哪个节点为master节点，默认使用多播数据来传输VRRP数据。通过配置文件可以指定每个设备的优先级，所以在初始状态时，优先级最大的为master节点。VRRP运行时只有MASTER路由器定时发送VRRP通告信息，表示master工作正常，backup只接收VRRP数据，不发送数据，如果一定时间内没有接收到master的通告信息，各backup将宣告自己成为master，发送通告信息，重新进行master选举状态。</p>\n<h1 id=\"KeepAlived的安装\"><a href=\"#KeepAlived的安装\" class=\"headerlink\" title=\"KeepAlived的安装\"></a>KeepAlived的安装</h1><p>该教程使用的Ubuntu版本是18.04.1版本，Ubuntu的安装教程参考<a href=\"/posts/VirtualBox安装Ubuntu教程/\" title=\"VirtualBox安装Ubuntu教程\">VirtualBox安装Ubuntu教程</a>。KeepAlived可以直接通过apt-get安装，也可以通过源码编译安装。</p>\n<h2 id=\"apt-get安装\"><a href=\"#apt-get安装\" class=\"headerlink\" title=\"apt-get安装\"></a>apt-get安装</h2><p>Ubuntu下执行<code>sudo apt-get install keepalived</code>命令即可安装。</p>\n<p>通过<code>which keepalived</code>可以看到KeepAlived是安装在<code>/usr/sbin/keepalived</code>下。</p>\n<p>使用<code>sudo service keepalived start</code>即可启动KeepAlived。</p>\n<h2 id=\"源码编译安装\"><a href=\"#源码编译安装\" class=\"headerlink\" title=\"源码编译安装\"></a>源码编译安装</h2><p>源码安装的脚本可以点击此处下载： <a href=\"/posts/Ubuntu下KeepAlived的安装与配置/keepalived_install.sh\" title=\"keepalived_install.sh\">keepalived_install.sh</a>，下面对安装过程做一下说明。</p>\n<p>首先安装编译工具和openssl，下载KeepAlived源码并解压，然后执行源码编译三件套（<code>./configure &amp;&amp; make &amp;&amp; make install</code>），我们安装的目录为<code>/usr/local/keepalived</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install build-essential libssl-dev <span class=\"comment\"># 安装编译工具和openssl依赖</span></span><br><span class=\"line\">wget http://www.keepalived.org/software/keepalived-2.0.7.tar.gz <span class=\"comment\"># 下载源码</span></span><br><span class=\"line\">tar -zxvf keepalived-2.0.7.tar.gz <span class=\"comment\"># 解压源码</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> keepalived-2.0.7/</span><br><span class=\"line\">./configure --prefix=/usr/<span class=\"built_in\">local</span>/keepalived <span class=\"comment\"># 配置keepalived的安装目录</span></span><br><span class=\"line\">make <span class=\"comment\"># 编译源码</span></span><br><span class=\"line\">sudo make install <span class=\"comment\"># 安装到安装目录，需要使用root权限</span></span><br></pre></td></tr></table></figure>\n<p><strong>可能遇到的问题</strong></p>\n<ol>\n<li><p>执行<code>./configure</code>时提示<code>g++ is not found</code></p>\n<blockquote>\n<p>源码安装需要安装编译器将源码转换为二进制可执行文件，因此执行<code>sudo apt-get install build-essential</code>安装编译器即可</p>\n</blockquote>\n</li>\n<li><p>执行<code>./configure</code>时提示<code>OpenSSL is not properly installed on your system</code></p>\n<blockquote>\n<p>你的系统没有安装openssl，执行<code>sudo apt-get install libssl-dev</code>即可</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"守护进程和开机启动\"><a href=\"#守护进程和开机启动\" class=\"headerlink\" title=\"守护进程和开机启动\"></a>守护进程和开机启动</h1><p>由于Ubunt 18.04.1默认使用Systemd作为init程序，因此设置守护进程也采用该方式，了解详细请参考<a href=\"/posts/Linux初始化init系统/\" title=\"Linux初始化init系统：Sysvinit、Upstart和Systemd\">Linux初始化init系统：Sysvinit、Upstart和Systemd</a></p>\n<p>首先，创建相关文件的链接：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /etc/keepalived</span><br><span class=\"line\">sudo ln -s /usr/<span class=\"built_in\">local</span>/keepalived/sbin/keepalived /usr/sbin/</span><br><span class=\"line\">sudo ln -s /usr/<span class=\"built_in\">local</span>/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf</span><br><span class=\"line\">sudo ln -s /usr/<span class=\"built_in\">local</span>/keepalived/etc/sysconfig/keepalived /etc/default/keepalived</span><br></pre></td></tr></table></figure>\n<p>我们还是采用systemd的方式添加到系统服务，执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(</span><br><span class=\"line\">cat &lt;&lt;EOF</span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Keepalive Daemon (LVS and VRRP)</span><br><span class=\"line\">After=syslog.target network-online.target</span><br><span class=\"line\">Wants=network-online.target</span><br><span class=\"line\"><span class=\"comment\"># Only start if there is a configuration file</span></span><br><span class=\"line\">ConditionFileNotEmpty=/etc/keepalived/keepalived.conf</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=forking</span><br><span class=\"line\">KillMode=process</span><br><span class=\"line\"><span class=\"comment\"># Read configuration variable file if it is present</span></span><br><span class=\"line\">EnvironmentFile=-/etc/default/keepalived</span><br><span class=\"line\">ExecStart=/usr/sbin/keepalived <span class=\"variable\">$KEEPALIVED_OPTIONS</span></span><br><span class=\"line\">ExecReload=/bin/<span class=\"built_in\">kill</span> -HUP <span class=\"variable\">$MAINPID</span></span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br><span class=\"line\">EOF</span><br><span class=\"line\">) &gt; keepalived.service</span><br><span class=\"line\"></span><br><span class=\"line\">sudo cp -a keepalived.service /lib/systemd/system/keepalived.service</span><br><span class=\"line\">sudo ln -s /lib/systemd/system/keepalived.service /etc/systemd/system/multi-user.target.wants/keepalived.service</span><br></pre></td></tr></table></figure>\n<p>启动keepalived进程，并设置为开机启动，通过<code>sudo systemctl status keepalived</code>查看状态：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start keepalived</span><br><span class=\"line\">sudo systemctl status keepalived</span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">enable</span> keepalived</span><br></pre></td></tr></table></figure>\n<img src=\"/posts/Ubuntu下KeepAlived的安装与配置/2018-09-24-16-41-22.png\" title=\"[blog.ruanxinyu.cn]\">\n<h1 id=\"KeepAlive的配置\"><a href=\"#KeepAlive的配置\" class=\"headerlink\" title=\"KeepAlive的配置\"></a>KeepAlive的配置</h1><h2 id=\"keepalived-conf\"><a href=\"#keepalived-conf\" class=\"headerlink\" title=\"keepalived.conf\"></a>keepalived.conf</h2><p>在keepalived的安装目录<code>/usr/local/keepalived/etc/keepalived/samples/</code>有很多样例配置，每一种配置对应的都是一种使用场景，后续会做详细说明，因此在此处不做过多的分析。</p>\n<p>此处使用最简单的配置入门，假设我们以<code>/tmp/</code>目录下是否存在<code>service_ok</code>这个文件来判断服务是否可用。可参考样例<code>/usr/local/keepalived/etc/keepalived/samples/keepalived.conf.vrrp.localcheck</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vrrp_script chk_service_ok &#123;</span><br><span class=\"line\">       script <span class=\"string\">\"ls /tmp/service_ok\"</span>    <span class=\"comment\"># 检查文件是否存在</span></span><br><span class=\"line\">       interval 2                     <span class=\"comment\"># 每两秒钟检查一次</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">vrrp_instance VI_1 &#123;</span><br><span class=\"line\">    interface enp0s3                  <span class=\"comment\"># 指定网卡</span></span><br><span class=\"line\">    state MASTER                      <span class=\"comment\"># 角色，主机为MASTER，备机为BACKUP</span></span><br><span class=\"line\">    virtual_router_id 51              <span class=\"comment\"># 虚拟路由Id，相同的ID表示在相同的组</span></span><br><span class=\"line\">    priority 100                      <span class=\"comment\"># 优先级，MASTER的优先级要比BACKUP的大</span></span><br><span class=\"line\"></span><br><span class=\"line\">    virtual_ipaddress &#123;               <span class=\"comment\"># 虚拟IP地址，即VIP</span></span><br><span class=\"line\">        192.168.42.23/25</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    track_script &#123;                    <span class=\"comment\"># 设置vrrp检查脚本的名称</span></span><br><span class=\"line\">       chk_service_ok</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"KeepAlived的验证\"><a href=\"#KeepAlived的验证\" class=\"headerlink\" title=\"KeepAlived的验证\"></a>KeepAlived的验证</h1><p>我们使用两台虚拟机，IP地址分别为主机vm01（<code>192.168.42.21</code>）和备机vm02（<code>192.168.42.22</code>）， VIP为<code>192.168.42.23</code>。安装好KeepAlived后, 编辑配置文件<code>sudo vim /etc/keepalived/keepalived.conf</code></p>\n<ol>\n<li>主机vm01（<code>192.168.42.21</code>）的配置如下：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vrrp_script chk_service_ok &#123;</span><br><span class=\"line\">       script <span class=\"string\">\"ls /tmp/service_ok\"</span></span><br><span class=\"line\">       interval 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">vrrp_instance VI_1 &#123;</span><br><span class=\"line\">    interface enp0s3</span><br><span class=\"line\">    state MASTER</span><br><span class=\"line\">    virtual_router_id 51</span><br><span class=\"line\">    priority 100</span><br><span class=\"line\"></span><br><span class=\"line\">    virtual_ipaddress &#123;</span><br><span class=\"line\">        192.168.42.23/25</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    track_script &#123;</span><br><span class=\"line\">       chk_service_ok</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>备机vm02（<code>192.168.42.22</code>）的配置如下，相对于vm01，只修改<code>state</code>和<code>priority</code>:</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vrrp_script chk_service_ok &#123;</span><br><span class=\"line\">       script <span class=\"string\">\"ls /tmp/service_ok\"</span></span><br><span class=\"line\">       interval 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">vrrp_instance VI_1 &#123;</span><br><span class=\"line\">    interface enp0s3</span><br><span class=\"line\">    state BACKUP</span><br><span class=\"line\">    virtual_router_id 51</span><br><span class=\"line\">    priority 80</span><br><span class=\"line\"></span><br><span class=\"line\">    virtual_ipaddress &#123;</span><br><span class=\"line\">        192.168.42.23/25</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    track_script &#123;</span><br><span class=\"line\">       chk_service_ok</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，我们在两台机器上都创建一个system_ok文件，表示机器是OK的，<code>touch /tmp/service_ok</code>。然后执行<code>sudo systemctl restart keepalived</code>重新启动两台机器的keepalived。</p>\n<p>分别在两台机器上执行<code>ip a</code>查看机器的网络信息，可以发现VIP（<code>192.168.42.23</code>）已经在主机vm01上，我们通过<code>ssh ruan@192.168.42.23</code>登陆到的也是主机vm01。</p>\n<img src=\"/posts/Ubuntu下KeepAlived的安装与配置/2018-09-24-16-53-52.png\" title=\"[blog.ruanxinyu.cn]\">\n<p>我们删除主机vm01上的<code>/tmp/service_ok</code>文件，然后重新执行<code>ip a</code>，发现VIP（<code>192.168.42.23</code>）已经漂移到备机vm02上，此时我们通过<code>ssh ruan@192.168.42.23</code>登陆则是备机vm02。即当主机故障时，业务可以自动切换至备机。</p>\n<img src=\"/posts/Ubuntu下KeepAlived的安装与配置/2018-09-24-16-58-02.png\" title=\"[blog.ruanxinyu.cn]\">\n<p>我们重新创建主机vm01上的<code>/tmp/service_ok</code>文件，，然后重新执行<code>ip a</code>，发现VIP（<code>192.168.42.23</code>）已经重新漂移到备机vm01上，此时我们通过<code>ssh ruan@192.168.42.23</code>登陆重新回到主机vm01。即当主机恢复时，可以自动将该主机加入到服务器群提供服务。</p>\n","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/categories/环境搭建/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/tags/环境搭建/"}]},{"title":"VirtualBox安装Ubuntu教程","slug":"VirtualBox安装Ubuntu教程","date":"un00fin00","updated":"un22fin22","comments":true,"path":"posts/VirtualBox安装Ubuntu教程/","link":"","permalink":"http://ruanxinyu.github.io/posts/VirtualBox安装Ubuntu教程/","excerpt":"","keywords":"","text":"基础准备工作本教程使用的VirtualBox版本为5.2.18，Ubuntu版本为server 18.04.1。 首先，下载Ubuntu Server镜像，本文以ubuntu-18.04.1为例，可以从华为开源镜像站提供加速下载，地址为： http://mirrors.huaweicloud.com/repository/ubuntu-releases/18.04.1/ubuntu-18.04.1-live-server-amd64.iso 下载并安装VirtualBox，下载地址为: https://download.virtualbox.org/virtualbox/5.2.18/VirtualBox-5.2.18-124319-Win.exe 创建虚拟机 打开VirtualBox，点击新建, 输入名称，比如叫做UbuntuTemplate，之所以叫这个名称是因为如果后续需要多个Ubuntu虚拟机的话，可以直接复制该虚拟机，这样每次都可以有一个全新的虚拟机。操作系统版本选择Ubuntu(64bit), 点击下一步，内存选择512M或者1024M都可以，因为我们下载的镜像是没有桌面的，因此对内存要求没有那么大。 选择现在创建虚拟磁盘，当然，如果也可以使用已经存在的磁盘，下一步，磁盘类型我更愿意用VMDK(虚拟机磁盘)，因此该磁盘VMWare也是可以使用的，磁盘大小选择动态分配大小。 此处有两个地方需要注意一下： 选择磁盘的保存位置默认为虚拟机名称，这个时候是保存在用户目录下的，也就是C盘，因此最好是自己选择路径保存到其他目录，以免占用过多的C盘空间。 此处设置的其实是磁盘的最大大小，默认的10G肯定是太小了，可以直接改成100G, 这个是最大值，不是立即分配这么大的磁盘空间。 设置虚拟机设置粘贴板 导入操作系统镜像从设置的系统标签页中可以看出系统的启动顺序是“软驱”-&gt;”光驱”-&gt;”硬盘”，因此只要在光驱中导入刚刚下载的操作系统镜像，启动的虚拟机的时候就会开始安装操作系统。 设置虚拟机网络虚拟机的网络连接方式有很多中，因为涉及到很多网络知识，总结起来就是一张表，如下所示： 因为在做实验的情况下，默认都是希望虚拟机能够访问外网，虚拟机与虚拟机之间，虚拟机与宿主机之间也是可以相互访问的，因此选择桥接模式，网卡选择你当前正在使用的网卡，这样你的虚拟机就相当于是另外与宿主机相同的电脑。 安装Ubuntu 通过方向键移动，回车确认，如果发现鼠标在虚拟机捕获出不来了，可以按键盘右边的CTRL键 启动虚拟机，语言选择英文，然后选择Install Ubuntu。 如果你的宿主机连接的是路由器，那么一般都是通过DHCP自动分配的IP地址，这样的话虚拟机也能通过DHCP自动获取IP地址，从下图中可以看出对应的IP。 如果你的宿主机能够正常上网就不需要配置proxy，直接回车确认下一步就可以。 配置Ubuntu的源，也就是安装软件的默认下载地址，为了提高下载速度，我一般使用华为开源镜像站的源：https://mirrors.huaweicloud.com/ubuntu/ 我们可以手动对磁盘进行分区，但是这个需要对Linux很熟悉，因此此处我们直接选择Use An Entre Disk，让操作系统自动分区。 接下来会让你确认磁盘和分区信息，我们继续就可以。 然后输入你的主机名和密码等信息，ssh identify是用于免密码登陆linux的，一般不需要设置。 接下来会让你安装一些默认的应用程序，也可以什么都不装，保持一个最纯净的系统。 等待安装完毕，就可以开开心心重启了， 重启的过程中VirtualBox会提示你是否将光驱中的镜像移除掉，直接回车就可以移除就剋有了，这样就可以直接从磁盘启动你刚刚安装的系统，否则还是会从光驱中启动。 启动后输入用户名密码，输入ip a命令可以看到虚拟机的IP地址: 由于Ubuntu自带的控制台使用不是很方便，因此可以直接通过xshell连接该虚拟机 VirtualBox的使用说明鼠标捕获如果发现鼠标在虚拟机捕获出不来了，可以按键盘右边的CTRL键 保存快照如下所示，一般第一次安装的时候都做一次快照，因此这样即使后续做了破坏性的操作也可以快速还原。 快速保存并恢复关闭虚拟机时可以选择快速休眠，下次启动的时候就可以快速从将虚拟机从当前状态恢复。 复制虚拟机在做实验的时候需要使用多个虚拟机，不用重新安装，直接复制虚拟机即可，在对应的虚拟机上右键就可以，需要在关机的状态下才能复制。但是在复制虚拟机之后最后刷新一下网卡的MAC地址，否则可能会出现相同MAC地址的情况。","raw":"---\ntitle: VirtualBox安装Ubuntu教程\ntags: 环境搭建\ncategories: 环境搭建\ndate: 2018-09-16 19:59:38\n---\n\n# 基础准备工作\n\n本教程使用的VirtualBox版本为`5.2.18`，Ubuntu版本为`server 18.04.1`。\n\n首先，下载Ubuntu Server镜像，本文以ubuntu-18.04.1为例，可以从华为开源镜像站提供加速下载，地址为： http://mirrors.huaweicloud.com/repository/ubuntu-releases/18.04.1/ubuntu-18.04.1-live-server-amd64.iso\n\n下载并安装VirtualBox，下载地址为: https://download.virtualbox.org/virtualbox/5.2.18/VirtualBox-5.2.18-124319-Win.exe\n\n# 创建虚拟机\n\n1. 打开VirtualBox，点击`新建`, 输入名称，比如叫做`UbuntuTemplate`，之所以叫这个名称是因为如果后续需要多个Ubuntu虚拟机的话，可以直接复制该虚拟机，这样每次都可以有一个全新的虚拟机。操作系统版本选择`Ubuntu(64bit)`, 点击下一步，内存选择512M或者1024M都可以，因为我们下载的镜像是没有桌面的，因此对内存要求没有那么大。\n{% asset_img 2018-09-16-20-11-35.png [blog.ruanxinyu.cn] %}\n\n2. 选择`现在创建虚拟磁盘`，当然，如果也可以使用已经存在的磁盘，下一步，磁盘类型我更愿意用`VMDK(虚拟机磁盘)`，因此该磁盘VMWare也是可以使用的，磁盘大小选择`动态分配大小`。\n{% asset_img 2018-09-16-20-14-32.png [blog.ruanxinyu.cn] %}\n\n3. 此处有两个地方需要注意一下：\n\n> 1. 选择磁盘的保存位置默认为虚拟机名称，这个时候是保存在用户目录下的，也就是C盘，因此**最好是自己选择路径保存到其他目录**，以免占用过多的C盘空间。\n> 2. 此处设置的其实是磁盘的最大大小，默认的10G肯定是太小了，可以直接改成`100G`, 这个是最大值，不是立即分配这么大的磁盘空间。\n\n{% asset_img 2018-09-16-20-18-22.png [blog.ruanxinyu.cn] %}\n\n# 设置虚拟机\n\n## 设置粘贴板\n\n{% asset_img 2018-09-16-20-26-02.png [blog.ruanxinyu.cn] %}\n\n## 导入操作系统镜像\n\n从设置的系统标签页中可以看出系统的启动顺序是“软驱”->\"光驱\"->\"硬盘\"，因此只要在光驱中导入刚刚下载的操作系统镜像，启动的虚拟机的时候就会开始安装操作系统。\n{% asset_img 2018-09-16-20-30-36.png [blog.ruanxinyu.cn] %}\n\n## 设置虚拟机网络\n\n虚拟机的网络连接方式有很多中，因为涉及到很多网络知识，总结起来就是一张表，如下所示：\n{% asset_img 2018-09-16-21-22-53.png [blog.ruanxinyu.cn] %}\n\n因为在做实验的情况下，默认都是希望虚拟机能够访问外网，虚拟机与虚拟机之间，虚拟机与宿主机之间也是可以相互访问的，因此选择桥接模式，网卡选择你当前正在使用的网卡，这样你的虚拟机就相当于是另外与宿主机相同的电脑。\n{% asset_img 2018-09-16-20-35-30.png [blog.ruanxinyu.cn] %}\n\n# 安装Ubuntu\n\n> 通过方向键移动，回车确认，如果发现鼠标在虚拟机捕获出不来了，可以按键盘右边的`CTRL`键\n\n启动虚拟机，语言选择英文，然后选择`Install Ubuntu`。\n{% asset_img 2018-09-16-20-55-08.png [blog.ruanxinyu.cn] %}\n\n如果你的宿主机连接的是路由器，那么一般都是通过DHCP自动分配的IP地址，这样的话虚拟机也能通过DHCP自动获取IP地址，从下图中可以看出对应的IP。\n{% asset_img 2018-09-16-20-55-47.png [blog.ruanxinyu.cn] %}\n\n如果你的宿主机能够正常上网就不需要配置proxy，直接回车确认下一步就可以。\n{% asset_img 2018-09-16-20-58-24.png [blog.ruanxinyu.cn] %}\n\n配置Ubuntu的源，也就是安装软件的默认下载地址，为了提高下载速度，我一般使用华为开源镜像站的源：https://mirrors.huaweicloud.com/ubuntu/\n{% asset_img 2018-09-16-21-02-30.png [blog.ruanxinyu.cn] %}\n\n我们可以手动对磁盘进行分区，但是这个需要对Linux很熟悉，因此此处我们直接选择`Use An Entre Disk`，让操作系统自动分区。\n{% asset_img 2018-09-16-21-03-45.png [blog.ruanxinyu.cn] %}\n\n接下来会让你确认磁盘和分区信息，我们继续就可以。\n{% asset_img 2018-09-16-21-06-02.png [blog.ruanxinyu.cn] %}\n\n然后输入你的主机名和密码等信息，`ssh identify`是用于免密码登陆linux的，一般不需要设置。\n{% asset_img 2018-09-16-21-08-19.png [blog.ruanxinyu.cn] %}\n\n接下来会让你安装一些默认的应用程序，也可以什么都不装，保持一个最纯净的系统。\n{% asset_img 2018-09-16-21-09-27.png [blog.ruanxinyu.cn] %}\n\n等待安装完毕，就可以开开心心重启了，\n{% asset_img 2018-09-16-21-15-58.png [blog.ruanxinyu.cn] %}\n\n重启的过程中VirtualBox会提示你是否将光驱中的镜像移除掉，直接回车就可以移除就剋有了，这样就可以直接从磁盘启动你刚刚安装的系统，否则还是会从光驱中启动。\n{% asset_img 2018-09-16-21-17-37.png [blog.ruanxinyu.cn] %}\n\n启动后输入用户名密码，输入`ip a`命令可以看到虚拟机的IP地址:\n> 由于Ubuntu自带的控制台使用不是很方便，因此可以直接通过xshell连接该虚拟机\n\n{% asset_img 2018-09-16-21-26-23.png [blog.ruanxinyu.cn] %}\n\n# VirtualBox的使用说明\n\n## 鼠标捕获\n\n如果发现鼠标在虚拟机捕获出不来了，可以按键盘右边的`CTRL`键\n\n## 保存快照\n\n如下所示，一般第一次安装的时候都做一次快照，因此这样即使后续做了破坏性的操作也可以快速还原。\n{% asset_img 2018-09-16-21-29-57.png [blog.ruanxinyu.cn] %}\n\n## 快速保存并恢复\n\n关闭虚拟机时可以选择`快速休眠`，下次启动的时候就可以快速从将虚拟机从当前状态恢复。\n{% asset_img 2018-09-16-21-34-53.png [blog.ruanxinyu.cn] %}\n\n## 复制虚拟机\n\n在做实验的时候需要使用多个虚拟机，不用重新安装，直接复制虚拟机即可，在对应的虚拟机上右键就可以，需要在关机的状态下才能复制。但是在复制虚拟机之后最后刷新一下网卡的MAC地址，否则可能会出现相同MAC地址的情况。\n{% asset_img 2018-09-26-15-33-38.png [blog.ruanxinyu.cn] %}\n","content":"<h1 id=\"基础准备工作\"><a href=\"#基础准备工作\" class=\"headerlink\" title=\"基础准备工作\"></a>基础准备工作</h1><p>本教程使用的VirtualBox版本为<code>5.2.18</code>，Ubuntu版本为<code>server 18.04.1</code>。</p>\n<p>首先，下载Ubuntu Server镜像，本文以ubuntu-18.04.1为例，可以从华为开源镜像站提供加速下载，地址为： <a href=\"http://mirrors.huaweicloud.com/repository/ubuntu-releases/18.04.1/ubuntu-18.04.1-live-server-amd64.iso\" target=\"_blank\" rel=\"noopener\">http://mirrors.huaweicloud.com/repository/ubuntu-releases/18.04.1/ubuntu-18.04.1-live-server-amd64.iso</a></p>\n<p>下载并安装VirtualBox，下载地址为: <a href=\"https://download.virtualbox.org/virtualbox/5.2.18/VirtualBox-5.2.18-124319-Win.exe\" target=\"_blank\" rel=\"noopener\">https://download.virtualbox.org/virtualbox/5.2.18/VirtualBox-5.2.18-124319-Win.exe</a></p>\n<h1 id=\"创建虚拟机\"><a href=\"#创建虚拟机\" class=\"headerlink\" title=\"创建虚拟机\"></a>创建虚拟机</h1><ol>\n<li><p>打开VirtualBox，点击<code>新建</code>, 输入名称，比如叫做<code>UbuntuTemplate</code>，之所以叫这个名称是因为如果后续需要多个Ubuntu虚拟机的话，可以直接复制该虚拟机，这样每次都可以有一个全新的虚拟机。操作系统版本选择<code>Ubuntu(64bit)</code>, 点击下一步，内存选择512M或者1024M都可以，因为我们下载的镜像是没有桌面的，因此对内存要求没有那么大。</p>\n<img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-20-11-35.png\" title=\"[blog.ruanxinyu.cn]\">\n</li>\n<li><p>选择<code>现在创建虚拟磁盘</code>，当然，如果也可以使用已经存在的磁盘，下一步，磁盘类型我更愿意用<code>VMDK(虚拟机磁盘)</code>，因此该磁盘VMWare也是可以使用的，磁盘大小选择<code>动态分配大小</code>。</p>\n<img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-20-14-32.png\" title=\"[blog.ruanxinyu.cn]\">\n</li>\n<li><p>此处有两个地方需要注意一下：</p>\n</li>\n</ol>\n<blockquote>\n<ol>\n<li>选择磁盘的保存位置默认为虚拟机名称，这个时候是保存在用户目录下的，也就是C盘，因此<strong>最好是自己选择路径保存到其他目录</strong>，以免占用过多的C盘空间。</li>\n<li>此处设置的其实是磁盘的最大大小，默认的10G肯定是太小了，可以直接改成<code>100G</code>, 这个是最大值，不是立即分配这么大的磁盘空间。</li>\n</ol>\n</blockquote>\n<img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-20-18-22.png\" title=\"[blog.ruanxinyu.cn]\">\n<h1 id=\"设置虚拟机\"><a href=\"#设置虚拟机\" class=\"headerlink\" title=\"设置虚拟机\"></a>设置虚拟机</h1><h2 id=\"设置粘贴板\"><a href=\"#设置粘贴板\" class=\"headerlink\" title=\"设置粘贴板\"></a>设置粘贴板</h2><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-20-26-02.png\" title=\"[blog.ruanxinyu.cn]\">\n<h2 id=\"导入操作系统镜像\"><a href=\"#导入操作系统镜像\" class=\"headerlink\" title=\"导入操作系统镜像\"></a>导入操作系统镜像</h2><p>从设置的系统标签页中可以看出系统的启动顺序是“软驱”-&gt;”光驱”-&gt;”硬盘”，因此只要在光驱中导入刚刚下载的操作系统镜像，启动的虚拟机的时候就会开始安装操作系统。<br><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-20-30-36.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"设置虚拟机网络\"><a href=\"#设置虚拟机网络\" class=\"headerlink\" title=\"设置虚拟机网络\"></a>设置虚拟机网络</h2><p>虚拟机的网络连接方式有很多中，因为涉及到很多网络知识，总结起来就是一张表，如下所示：<br><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-21-22-53.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>因为在做实验的情况下，默认都是希望虚拟机能够访问外网，虚拟机与虚拟机之间，虚拟机与宿主机之间也是可以相互访问的，因此选择桥接模式，网卡选择你当前正在使用的网卡，这样你的虚拟机就相当于是另外与宿主机相同的电脑。<br><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-20-35-30.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h1 id=\"安装Ubuntu\"><a href=\"#安装Ubuntu\" class=\"headerlink\" title=\"安装Ubuntu\"></a>安装Ubuntu</h1><blockquote>\n<p>通过方向键移动，回车确认，如果发现鼠标在虚拟机捕获出不来了，可以按键盘右边的<code>CTRL</code>键</p>\n</blockquote>\n<p>启动虚拟机，语言选择英文，然后选择<code>Install Ubuntu</code>。<br><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-20-55-08.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>如果你的宿主机连接的是路由器，那么一般都是通过DHCP自动分配的IP地址，这样的话虚拟机也能通过DHCP自动获取IP地址，从下图中可以看出对应的IP。<br><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-20-55-47.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>如果你的宿主机能够正常上网就不需要配置proxy，直接回车确认下一步就可以。<br><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-20-58-24.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>配置Ubuntu的源，也就是安装软件的默认下载地址，为了提高下载速度，我一般使用华为开源镜像站的源：<a href=\"https://mirrors.huaweicloud.com/ubuntu/\" target=\"_blank\" rel=\"noopener\">https://mirrors.huaweicloud.com/ubuntu/</a><br><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-21-02-30.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>我们可以手动对磁盘进行分区，但是这个需要对Linux很熟悉，因此此处我们直接选择<code>Use An Entre Disk</code>，让操作系统自动分区。<br><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-21-03-45.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>接下来会让你确认磁盘和分区信息，我们继续就可以。<br><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-21-06-02.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>然后输入你的主机名和密码等信息，<code>ssh identify</code>是用于免密码登陆linux的，一般不需要设置。<br><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-21-08-19.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>接下来会让你安装一些默认的应用程序，也可以什么都不装，保持一个最纯净的系统。<br><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-21-09-27.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>等待安装完毕，就可以开开心心重启了，<br><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-21-15-58.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>重启的过程中VirtualBox会提示你是否将光驱中的镜像移除掉，直接回车就可以移除就剋有了，这样就可以直接从磁盘启动你刚刚安装的系统，否则还是会从光驱中启动。<br><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-21-17-37.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<p>启动后输入用户名密码，输入<code>ip a</code>命令可以看到虚拟机的IP地址:</p>\n<blockquote>\n<p>由于Ubuntu自带的控制台使用不是很方便，因此可以直接通过xshell连接该虚拟机</p>\n</blockquote>\n<img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-21-26-23.png\" title=\"[blog.ruanxinyu.cn]\">\n<h1 id=\"VirtualBox的使用说明\"><a href=\"#VirtualBox的使用说明\" class=\"headerlink\" title=\"VirtualBox的使用说明\"></a>VirtualBox的使用说明</h1><h2 id=\"鼠标捕获\"><a href=\"#鼠标捕获\" class=\"headerlink\" title=\"鼠标捕获\"></a>鼠标捕获</h2><p>如果发现鼠标在虚拟机捕获出不来了，可以按键盘右边的<code>CTRL</code>键</p>\n<h2 id=\"保存快照\"><a href=\"#保存快照\" class=\"headerlink\" title=\"保存快照\"></a>保存快照</h2><p>如下所示，一般第一次安装的时候都做一次快照，因此这样即使后续做了破坏性的操作也可以快速还原。<br><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-21-29-57.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"快速保存并恢复\"><a href=\"#快速保存并恢复\" class=\"headerlink\" title=\"快速保存并恢复\"></a>快速保存并恢复</h2><p>关闭虚拟机时可以选择<code>快速休眠</code>，下次启动的时候就可以快速从将虚拟机从当前状态恢复。<br><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-16-21-34-53.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n<h2 id=\"复制虚拟机\"><a href=\"#复制虚拟机\" class=\"headerlink\" title=\"复制虚拟机\"></a>复制虚拟机</h2><p>在做实验的时候需要使用多个虚拟机，不用重新安装，直接复制虚拟机即可，在对应的虚拟机上右键就可以，需要在关机的状态下才能复制。但是在复制虚拟机之后最后刷新一下网卡的MAC地址，否则可能会出现相同MAC地址的情况。<br><img src=\"/posts/VirtualBox安装Ubuntu教程/2018-09-26-15-33-38.png\" title=\"[blog.ruanxinyu.cn]\"></p>\n","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/categories/环境搭建/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/tags/环境搭建/"}]},{"title":"每天学习一个Linux命令（3）：echo命令","slug":"每天学习一个Linux命令/每天学习一个Linux命令（3）：echo命令","date":"un33fin33","updated":"un00fin00","comments":true,"path":"posts/每天学习一个Linux命令/每天学习一个Linux命令（3）：echo命令/","link":"","permalink":"http://ruanxinyu.github.io/posts/每天学习一个Linux命令/每天学习一个Linux命令（3）：echo命令/","excerpt":"","keywords":"","text":"echo命令用于输出字符串，可以通过参数和转义等来控制输出格式。 语法1echo [-neE] [arg ...] 参数 -n 打印不添加换行符 -e 使能转义字符 转义字符 \\b 退格键，即删除一个字符 \\c 抑制后续的输出 \\n 换行 \\t tab键 \\\\ 斜杠 使用小技巧 echo是shell的内部命令，因此查看帮助需要使用help echo echo后的字符串如果使用单引号括起来，则转义和变量都失效(重要) 通过-e参数和\\c转义可以控制换行的输出 常用范例范例1： 显示普通字符串命令： echo &quot;this is a text&quot; # 也可以不加引号输出：1this is a text 范例2： 显示转义字符命令： echo &quot;\\&quot;this is a text\\&quot;&quot;输出：1&quot;this is a text&quot; 范例3： 显示变量命令：12text=\"ffff\"echo \"this is a $&#123;text&#125;\" 输出：1this is a ffff 范例4： 输出换行命令：12echo -e \"this \\n\"echo \"is a text\" 输出：123this is a text 范例5： 不输出换行命令：12echo -e \"this \\c\"echo \"is a text\" 输出：1this is a text （注：相比于上面的命令，少了两个换行） 范例6： 禁止显示转义和变量（使用单引号）命令： echo &#39;$name\\&quot;&#39; # 这个很重要输出：1$name\\&quot; 范例7： 显示命令执行的结果命令：12echo `date`echo $(date) 输出：12Tue May 1 21:16:57 CST 2018Tue May 1 21:16:57 CST 2018","raw":"---\ntitle: 每天学习一个Linux命令（3）：echo命令\ntags: Linux\ncategories: Linux\ndate: 2018-05-02 19:20:58\n---\n\n`echo`命令用于输出字符串，可以通过参数和转义等来控制输出格式。\n\n# 语法\n```shell\n echo [-neE] [arg ...]\n```\n\n# 参数\n+ `-n` 打印不添加换行符\n+ `-e` 使能转义字符\n\n# 转义字符\n+ `\\b` 退格键，即删除一个字符\n+ `\\c` 抑制后续的输出\n+ `\\n` 换行\n+ `\\t` tab键\n+ `\\\\` 斜杠\n\n# 使用小技巧\n1. `echo`是shell的内部命令，因此查看帮助需要使用`help echo`\n2. `echo`后的字符串如果使用单引号括起来，则转义和变量都失效`(重要)`\n3. 通过`-e`参数和`\\c`转义可以控制换行的输出\n\n# 常用范例\n**范例1： 显示普通字符串**\n命令： `echo \"this is a text\"` # 也可以不加引号\n输出：\n```\nthis is a text\n```\n\n**范例2： 显示转义字符**\n命令： `echo \"\\\"this is a text\\\"\"`\n输出：\n```\n\"this is a text\"\n```\n\n**范例3： 显示变量**\n命令： \n```bash\ntext=\"ffff\"\necho \"this is a ${text}\"\n```\n输出：\n```\nthis is a ffff\n```\n\n**范例4： 输出换行**\n命令： \n```bash\necho -e \"this \\n\"\necho \"is a text\"\n```\n输出：\n```\nthis \n\nis a text\n```\n**范例5： 不输出换行**\n命令： \n```bash\necho -e \"this \\c\"\necho \"is a text\"\n```\n输出：\n```\nthis is a text （注：相比于上面的命令，少了两个换行）\n```\n\n**范例6： 禁止显示转义和变量（使用单引号）**\n命令： `echo '$name\\\"'` # 这个很重要\n输出：\n```\n$name\\\"\n```\n\n**范例7： 显示命令执行的结果**\n命令： \n```bash\necho `date`\necho $(date)\n```\n输出：\n```\nTue May 1 21:16:57 CST 2018\nTue May 1 21:16:57 CST 2018\n```\n","content":"<p><code>echo</code>命令用于输出字符串，可以通过参数和转义等来控制输出格式。</p>\n<h1 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo [-neE] [arg ...]</span><br></pre></td></tr></table></figure>\n<h1 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h1><ul>\n<li><code>-n</code> 打印不添加换行符</li>\n<li><code>-e</code> 使能转义字符</li>\n</ul>\n<h1 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h1><ul>\n<li><code>\\b</code> 退格键，即删除一个字符</li>\n<li><code>\\c</code> 抑制后续的输出</li>\n<li><code>\\n</code> 换行</li>\n<li><code>\\t</code> tab键</li>\n<li><code>\\\\</code> 斜杠</li>\n</ul>\n<h1 id=\"使用小技巧\"><a href=\"#使用小技巧\" class=\"headerlink\" title=\"使用小技巧\"></a>使用小技巧</h1><ol>\n<li><code>echo</code>是shell的内部命令，因此查看帮助需要使用<code>help echo</code></li>\n<li><code>echo</code>后的字符串如果使用单引号括起来，则转义和变量都失效<code>(重要)</code></li>\n<li>通过<code>-e</code>参数和<code>\\c</code>转义可以控制换行的输出</li>\n</ol>\n<h1 id=\"常用范例\"><a href=\"#常用范例\" class=\"headerlink\" title=\"常用范例\"></a>常用范例</h1><p><strong>范例1： 显示普通字符串</strong><br>命令： <code>echo &quot;this is a text&quot;</code> # 也可以不加引号<br>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this is a text</span><br></pre></td></tr></table></figure></p>\n<p><strong>范例2： 显示转义字符</strong><br>命令： <code>echo &quot;\\&quot;this is a text\\&quot;&quot;</code><br>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;this is a text&quot;</span><br></pre></td></tr></table></figure></p>\n<p><strong>范例3： 显示变量</strong><br>命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text=<span class=\"string\">\"ffff\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"this is a <span class=\"variable\">$&#123;text&#125;</span>\"</span></span><br></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this is a ffff</span><br></pre></td></tr></table></figure></p>\n<p><strong>范例4： 输出换行</strong><br>命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"this \\n\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"is a text\"</span></span><br></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this </span><br><span class=\"line\"></span><br><span class=\"line\">is a text</span><br></pre></td></tr></table></figure></p>\n<p><strong>范例5： 不输出换行</strong><br>命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"this \\c\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"is a text\"</span></span><br></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this is a text （注：相比于上面的命令，少了两个换行）</span><br></pre></td></tr></table></figure></p>\n<p><strong>范例6： 禁止显示转义和变量（使用单引号）</strong><br>命令： <code>echo &#39;$name\\&quot;&#39;</code> # 这个很重要<br>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$name\\&quot;</span><br></pre></td></tr></table></figure></p>\n<p><strong>范例7： 显示命令执行的结果</strong><br>命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> `date`</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $(date)</span><br></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Tue May 1 21:16:57 CST 2018</span><br><span class=\"line\">Tue May 1 21:16:57 CST 2018</span><br></pre></td></tr></table></figure></p>\n","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ruanxinyu.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://ruanxinyu.github.io/tags/Linux/"}]},{"title":"每天学习一个Linux命令（2）：cd命令","slug":"每天学习一个Linux命令/每天学习一个Linux命令（2）：cd命令","date":"un22fin22","updated":"un00fin00","comments":true,"path":"posts/每天学习一个Linux命令/每天学习一个Linux命令（2）：cd命令/","link":"","permalink":"http://ruanxinyu.github.io/posts/每天学习一个Linux命令/每天学习一个Linux命令（2）：cd命令/","excerpt":"","keywords":"","text":"cd命令用于切换至目标目录，以/开头的则为绝对路径，否则为相对路径。 语法1cd [dir] 使用小技巧 切换至用户所示在的目录可以使用cd ~ 或者 cd(不带参数) &quot;.&quot; 则是表示目前所在的目录，&quot;..&quot; 则表示目前目录位置的上一层目录 通过pwd命令可以打印当前所在的目录 cd -表示切换至上一次所在的目录 常用范例范例1： 切换至根目录下的var目录下命令： cd /var(绝对路径) 范例2： 切换至当前目录下的var目录下命令： cd var(相对目录) 范例3： 切换至上两级的目录命令： cd ../../ 范例4： 切换至包含空格的目录命令： cd &#39;aa aa&#39;或者cd aa\\ aa 范例5： 切换至当前用户的home目录命令： cd ~或者cd 范例6： 打印当前所在的目录命令： pwd 范例7： 切换到上一次所在的目录命令： cd -","raw":"---\ntitle: 每天学习一个Linux命令（2）：cd命令\ntags: Linux\ncategories: Linux\ndate: 2018-05-01 18:00:58\n---\n\n`cd`命令用于切换至目标目录，以/开头的则为绝对路径，否则为相对路径。\n\n# 语法\n```shell\ncd [dir]\n```\n\n# 使用小技巧\n1. 切换至用户所示在的目录可以使用`cd ~` 或者 `cd`(不带参数)\n2. `\".\"` 则是表示目前所在的目录，`\"..\"` 则表示目前目录位置的上一层目录\n3. 通过`pwd`命令可以打印当前所在的目录\n4. `cd -`表示切换至上一次所在的目录\n\n# 常用范例\n**范例1： 切换至根目录下的var目录下**\n命令： `cd /var`(绝对路径)\n\n***\n**范例2： 切换至当前目录下的var目录下**\n命令： `cd var`(相对目录)\n\n***\n**范例3： 切换至上两级的目录**\n命令： `cd ../../`\n\n***\n**范例4： 切换至包含空格的目录**\n命令： `cd 'aa aa'`或者`cd aa\\ aa`\n\n***\n**范例5： 切换至当前用户的home目录**\n命令： `cd ~`或者`cd`\n\n***\n**范例6： 打印当前所在的目录**\n命令： `pwd`\n\n***\n**范例7： 切换到上一次所在的目录**\n命令： `cd -`\n\n\n","content":"<p><code>cd</code>命令用于切换至目标目录，以/开头的则为绝对路径，否则为相对路径。</p>\n<h1 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd [dir]</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用小技巧\"><a href=\"#使用小技巧\" class=\"headerlink\" title=\"使用小技巧\"></a>使用小技巧</h1><ol>\n<li>切换至用户所示在的目录可以使用<code>cd ~</code> 或者 <code>cd</code>(不带参数)</li>\n<li><code>&quot;.&quot;</code> 则是表示目前所在的目录，<code>&quot;..&quot;</code> 则表示目前目录位置的上一层目录</li>\n<li>通过<code>pwd</code>命令可以打印当前所在的目录</li>\n<li><code>cd -</code>表示切换至上一次所在的目录</li>\n</ol>\n<h1 id=\"常用范例\"><a href=\"#常用范例\" class=\"headerlink\" title=\"常用范例\"></a>常用范例</h1><p><strong>范例1： 切换至根目录下的var目录下</strong><br>命令： <code>cd /var</code>(绝对路径)</p>\n<hr>\n<p><strong>范例2： 切换至当前目录下的var目录下</strong><br>命令： <code>cd var</code>(相对目录)</p>\n<hr>\n<p><strong>范例3： 切换至上两级的目录</strong><br>命令： <code>cd ../../</code></p>\n<hr>\n<p><strong>范例4： 切换至包含空格的目录</strong><br>命令： <code>cd &#39;aa aa&#39;</code>或者<code>cd aa\\ aa</code></p>\n<hr>\n<p><strong>范例5： 切换至当前用户的home目录</strong><br>命令： <code>cd ~</code>或者<code>cd</code></p>\n<hr>\n<p><strong>范例6： 打印当前所在的目录</strong><br>命令： <code>pwd</code></p>\n<hr>\n<p><strong>范例7： 切换到上一次所在的目录</strong><br>命令： <code>cd -</code></p>\n","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ruanxinyu.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://ruanxinyu.github.io/tags/Linux/"}]},{"title":"每天学习一个Linux命令（1）：ls命令","slug":"每天学习一个Linux命令/每天学习一个Linux命令（1）：ls命令","date":"un22fin22","updated":"un11fin11","comments":true,"path":"posts/每天学习一个Linux命令/每天学习一个Linux命令（1）：ls命令/","link":"","permalink":"http://ruanxinyu.github.io/posts/每天学习一个Linux命令/每天学习一个Linux命令（1）：ls命令/","excerpt":"","keywords":"","text":"ls命令是linux下最常用的命令。ls命令就是list的缩写，用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。 语法1ls [OPTION]... [FILE]... 参数 -a 显示所有文件及目录，包括以.开头的隐藏文件 -A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录) -l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出 -h human-readable，默认-l参数显示出来的文件大小是字节大小，-h参数可以按照KB/MB/GB来显示 -r reverse，将文件以相反次序显示(原定依英文字母次序) -t 将文件依建立时间之先后次序列出 -F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“ -R recursive，若目录下有文件，则以下之文件亦皆依序列出 使用小技巧 一般Linux操作系统都会存在一个ll的命令，相当于ls -l --color=auto ls命令使支持*通配符的 常用范例范例1： 列出/var目录下的文件命令： ls /var结果： 范例2： 列出目前工作目录下所有名称是s开头的文件，越新的排越后面命令： ls -ltr s*结果： 范例3： 将/bin目录以下所有目录及文件详细资料列出命令： ls -lR /bin","raw":"---\ntitle: 每天学习一个Linux命令（1）：ls命令\ntags: Linux\ncategories: Linux\ndate: 2018-05-01 16:18:02\n---\n\n`ls`命令是linux下最常用的命令。`ls`命令就是`list`的缩写，用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。\n\n# 语法\n```shell\nls [OPTION]... [FILE]...\n```\n\n# 参数\n+ `-a` 显示所有文件及目录，包括以.开头的隐藏文件\n+ `-A` 同 -a ，但不列出 \".\" (目前目录) 及 \"..\" (父目录)\n+ `-l` 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出\n+ `-h` human-readable，默认-l参数显示出来的文件大小是字节大小，-h参数可以按照KB/MB/GB来显示\n+ `-r` reverse，将文件以相反次序显示(原定依英文字母次序)\n+ `-t` 将文件依建立时间之先后次序列出\n+ `-F` 在列出的文件名称后加一符号；例如可执行档则加 \"*\", 目录则加 \"/\"\n+ `-R` recursive，若目录下有文件，则以下之文件亦皆依序列出\n\n# 使用小技巧\n1. 一般Linux操作系统都会存在一个`ll`的命令，相当于`ls -l --color=auto`\n2. ls命令使支持`*`通配符的\n\n# 常用范例\n**范例1： 列出`/var`目录下的文件**\n命令： `ls /var`\n结果：\n{% asset_img 1.png [1] %}\n\n\n***\n**范例2： 列出目前工作目录下所有名称是` s `开头的文件，越新的排越后面**\n命令： `ls -ltr s*`\n结果：\n{% asset_img 2.png [2] %}\n\n\n***\n**范例3： 将`/bin`目录以下所有目录及文件详细资料列出**\n命令： `ls -lR /bin`\n\n\n","content":"<p><code>ls</code>命令是linux下最常用的命令。<code>ls</code>命令就是<code>list</code>的缩写，用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。</p>\n<h1 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>\n<h1 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h1><ul>\n<li><code>-a</code> 显示所有文件及目录，包括以.开头的隐藏文件</li>\n<li><code>-A</code> 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li>\n<li><code>-l</code> 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li>\n<li><code>-h</code> human-readable，默认-l参数显示出来的文件大小是字节大小，-h参数可以按照KB/MB/GB来显示</li>\n<li><code>-r</code> reverse，将文件以相反次序显示(原定依英文字母次序)</li>\n<li><code>-t</code> 将文件依建立时间之先后次序列出</li>\n<li><code>-F</code> 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“</li>\n<li><code>-R</code> recursive，若目录下有文件，则以下之文件亦皆依序列出</li>\n</ul>\n<h1 id=\"使用小技巧\"><a href=\"#使用小技巧\" class=\"headerlink\" title=\"使用小技巧\"></a>使用小技巧</h1><ol>\n<li>一般Linux操作系统都会存在一个<code>ll</code>的命令，相当于<code>ls -l --color=auto</code></li>\n<li>ls命令使支持<code>*</code>通配符的</li>\n</ol>\n<h1 id=\"常用范例\"><a href=\"#常用范例\" class=\"headerlink\" title=\"常用范例\"></a>常用范例</h1><p><strong>范例1： 列出<code>/var</code>目录下的文件</strong><br>命令： <code>ls /var</code><br>结果：<br><img src=\"/posts/每天学习一个Linux命令/每天学习一个Linux命令（1）：ls命令/1.png\" title=\"[1]\"></p>\n<hr>\n<p><strong>范例2： 列出目前工作目录下所有名称是<code>s</code>开头的文件，越新的排越后面</strong><br>命令： <code>ls -ltr s*</code><br>结果：<br><img src=\"/posts/每天学习一个Linux命令/每天学习一个Linux命令（1）：ls命令/2.png\" title=\"[2]\"></p>\n<hr>\n<p><strong>范例3： 将<code>/bin</code>目录以下所有目录及文件详细资料列出</strong><br>命令： <code>ls -lR /bin</code></p>\n","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ruanxinyu.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://ruanxinyu.github.io/tags/Linux/"}]},{"title":"如何使用GitHubPages搭建个人博客","slug":"如何使用GitHubPages搭建个人博客","date":"un11fin11","updated":"un11fin11","comments":true,"path":"posts/如何使用GitHubPages搭建个人博客/","link":"","permalink":"http://ruanxinyu.github.io/posts/如何使用GitHubPages搭建个人博客/","excerpt":"","keywords":"","text":"我对个人博客的要求我对个人博客有如下几点要求，因此最终选定通过Hexo+GitHub Pages来搭建。 存在独立域名，别人能通过互联网访问 通过Git进行管理，支持MarkDown语法 不需要自己购买主机维护环境 支持评论分享等功能 配置GitHub Pages 前提： 您需要有一个GitHub的账号，请将下文中的ruanxinyu替换为您的用户名。 点击此处，创建一个仓库， 一般GitHub Pages对应的仓库名称规则为： 用户名.github.io， 如下图所示： 现在仓库有了，但是在推送内容之前还需要设置GitHub的SSH秘钥，通过如下命令生成并查看SSH秘钥，如果需要输入，一路回车就即可： 12ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; cat /c/Users/you/.ssh/id_rsa.pub 进入到GitHub的Setting页面，添加SSH秘钥，如下图所示： 下面，我们往仓库中推送一个index.html页面来充当我们的博客，可以参考如下命令：（Windows下可以使用git bash终端运行如下命令） 123456git clone git@github.com:RuanXinyu/ruanxinyu.github.io.gitcd ruanxinyu.github.ioecho \"Hello World\" &gt; index.htmlgit add --allgit commit -m \"Initial commit\"git push -u origin master 此时你的博客已经产生，网址为：https://ruanxinyu.github.io/, 点击即可访问: 安装并体验Hexo GitHub Pages相当于一个静态网站，您需要将您的博客全部转换为html页面才可以，当然，这个繁琐的过程不需要我们自己去完成，当前有两个框架可以做这个事情：Jekyll和Hexo，下面我就介绍一下如何通过Hexo快速的发表自己的文章。 Hexo是一个NodeJS实现的博客框架，官方文档地址为： https://hexo.io/zh-cn/docs/, 文档存在中文哦，给力吧！下面说一下使用过程： 执行npm install -g hexo-cli命令安装Hexo（在安装Hexo之前，请您自行安装NodeJS和NPM） 执行hexo init xxx创建一个博客 执行hexo generate渲染MarkDown博文，渲染出来的结果在public目录下 执行npm install hexo-server --save安装server工具，然后执行hexo server，访问http://localhost:4000/网址可在本地访问你的博客，该方式主要用于调试。 执行hexo new xxx创建一篇博文，博文的文件存放在source\\_posts目录下，编辑文档内容，hexo server会自动检测文章的变化并运行generate命令，因此刷新本地网址即可看到你更新的内容。 在将博文推送到GitHub Pages之前，执行npm install hexo-deployer-git --save安装部署工具，然后将根目录下的_config.yml文件中的如下内容更改为您的GitHub Pages的仓库地址，注意是git@开头的地址，否则在使用hexo deploy会报错 1234deploy: type: git repo: git@github.com:RuanXinyu/ruanxinyu.github.com.git branch: master 执行hexo deploy， Hexo将渲染后的页面放到.deploy_git目录，本地提交后，自动将您的博文推送到GitHub Pages所对应的仓库 此时，访问您的GitHubPages就可以看到你更新的文章内容。 切换到Indigo主题Hexo默认使用的是landscape主题，如果不符合自己的审美，可以在https://hexo.io/themes/查找自己喜欢的主题。我比较喜欢indigo主题，该主题有平铺和卡片两种显示方式，卡片模式的代码是在card分支下，下面以此主题为例。 克隆该主题的代码仓库，如下： 1git clone -b card https://github.com/yscoder/hexo-theme-indigo.git themes/indigo 安装Indigo主题依赖的插件 1234npm install hexo-renderer-less --savenpm install hexo-generator-feed --savenpm install hexo-generator-json-content --savenpm install hexo-helper-qrcode --save 修改顶层配置文件_config.yml中的theme: landscape为theme: indigo，刷新页面即可看到新的主题。 配置Hexo和Indigo主题Hexo的配置文件为_config.yml，Indigo主题的配置文件在themes/indigo/_config.yml。 Hexo的配置说明文档地址为： https://hexo.io/zh-cn/docs/configuration.htmlIndigo主题的配置说明文档地址为： https://github.com/yscoder/hexo-theme-indigo/wiki/%E9%85%8D%E7%BD%AE 官方文档已经描述很清楚，当然，最简单的方式是基于别人的进行修改，因此在此我贡献出我的配置，然后对几个点做一下说明。 Hexo配置文件样例 language: zh-CN: 语言的种类可以参考themes/indigo/languages目录下的文件 post_asset_folder: true: 在创建博文的时候自动生成对应的文件夹，以存放该博文对应的图片 配置文件末尾的feed和jsonContent两部分分别是hexo-generator-feed和hexo-generator-json-content两个插件的配置，该部分说明在Indigo的说明文章中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: RuanXinYu's Blogsubtitle: 路漫漫其修远兮，吾将上下而求索description: 阮新宇的成长记录keywords: Ruandyauthor: 阮新宇email: 1096421257@qq.comurl: http://ruanxinyu.github.io/language: zh-CNtimezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: true # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 20 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 20pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: indigo# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:RuanXinyu/ruanxinyu.github.com.git branch: masterfeed: type: atom path: atom.xml limit: 0jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true Indigo配置文件样例 该主题对应的图片在themes/indigo/source/img，请自行进行替换 样例内容配置了百度统计功能，下文有详细描述 样例内容配置了gitment的评论功能，下文有详细描述 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162# hexo-theme-indigo# https://github.com/yscoder/hexo-theme-indigo# 添加新菜单项遵循以下规则# menu:# link: fontawesome图标，省略前缀，本主题前缀为 icon-，必须# text: About 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写# url: /about 链接，绝对或相对路径，必须。# target: _blank 是否跳出，省略则在当前页面打开menu: home: text: 主页 url: / archives: text: 归档 url: /archives tags: text: 标签 url: /tags th-list: text: 分类 url: /categories github: url: https://github.com/RuanXinyu target: _blank# 你的头像urlavatar: /img/avatar.png# avatar linkavatar_link: /# 头像背景图brand: /img/brand.jpg# faviconfavicon: /favicon.ico# emailemail: 1096421257@qq.com# 设置 Android L Chrome 浏览器状态栏颜色color: '#3F51B5'# 页面标题tags_title: 标签archives_title: 归档categories_title: 分类# 文章截断excerpt_render: falseexcerpt_length: 200excerpt_link: 阅读全文...mathjax: falsearchive_yearly: true# 是否显示文章最后更新时间show_last_updated: true# 是否开启分享share: true# 是否开启打赏，关闭 reward: falsereward: title: 谢谢您的打赏 wechat: /img/wechat.png #微信，关闭设为 false alipay: /img/alipay.jpg #支付宝，关闭设为 false# 是否开启搜索search: true# 是否大屏幕下文章页隐藏导航hideMenu: false# 是否开启toc# toc: falsetoc: list_number: true # 是否显示数字排序# 文章页留言内容，hexo中所有变量及辅助函数等均可调用，具体请查阅 hexo.iopostMessage: 原始链接：&lt;a href=\"&lt;%- url_for(page.path).replace(/index\\.html$/, '') %&gt;\" target=\"_blank\" rel=\"external\"&gt;&lt;%- page.permalink.replace(/index\\.html$/, '') %&gt;&lt;/a&gt;# 站长统计，如要开启，输入CNZZ站点id，如 cnzz: 1255152447cnzz: false# 百度统计，如要开启，改为你的 keybaidu_tongji: b4c4998e548a16b827d4ffe9dbe2b47b# 腾讯分析，如要开启，输入站点idtajs: false# googlegoogle_analytics: falsegoogle_site_verification: false# sogou站长验证 http://zhanzhang.sogou.com/sogou_site_verification: false# lessless: compress: true paths: - source/css/style.less# 以下评论插件开启一个即可# 是否开启 disqusdisqus_shortname: false# 是否开启友言评论, 填写友言用户iduyan_uid: false# 是否使用 gitment，https://github.com/imsun/gitment#gitment: falsegitment: owner: RuanXinyu repo: ruanxinyu.github.com client_id: 2a6e23cf2e39e54ef316 client_secret: f237d3eb9fc94607a0454f894b143efe72eb8aca# Valine Comment system. https://valine.js.orgvaline: enable: false # 如果你想使用valine，请将值设置为 true appId: # your leancloud appId appKey: # your leancloud appKey notify: false # Mail notify verify: false # Verify code avatar: mm # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide placeholder: Just go go # Comment Box placeholder guest_info: nick,mail,link # Comment header info pageSize: 10 # comment list page size# 是否开启Hyper Comments，填写id则启用，false则禁用。http://hypercomments.com# Hyper Comments support. Write your id here, or false to disablehyper_id: false# 规范网址# 让搜索引擎重定向你的不同域名、不同子域、同域不同目录的站点到你期望的路径# https://support.google.com/webmasters/answer/139066# 假设配置为 canonical: http://imys.net，那么从搜索引擎中 www.imys.net 进入会重定向到 imys.netcanonical: false# 版权起始年份since_year: 2015# 用户页面中作者相关的描述性文字，如不需要设为 falseabout: 用户页面中作者相关的描述性文字，如不需要设为 false# “不蒜子”访问量统计，详见 http://ibruce.info/2015/04/04/busuanzi/visit_counter: site_uv: 站点总访客数： site_pv: 站点总访问量：# 动态定义titletitle_change: normal: 欢迎回来！ leave: 您还会回来吗？# 设置为 true 发布后将使用 unpkg cdn 最新的主题样式# 如果想让你的自定义样式生效，把此项设为 falsecdn: true# 设置为 true 将使用 lightbox render 图片lightbox: true# icp备案号 ICP_license: 京ICP备1234556号-1ICP_license: false 配置百度统计 百度统计是可以免费试用的，进入到百度统计注册账号，然后进入到管理页面添加你的网址，如下图所示： 添加完成之后，你就可以看到你的Key，如下图所示： 将你的key值添加到indigo主题的配置文件中即可，如下所示： 12# 百度统计，如要开启，改为你的 keybaidu_tongji: b4c4998e548a16b827d4ffe9dbe2b47b 访问百度统计查看你的网站访问情况等数据。 配置评论功能 友言评论功能已经关闭，因此采用的是gitment插件，该插件是依托于GitHub的Issue的功能的。采用npm install --save gitment命令安装gitment。 点击此处注册OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，比如： https://ruanxinyu.github.io ）。 你会得到一个client ID和一个client secret，将其配置到indigo的配置文件中： 1234567# 是否使用 gitment，https://github.com/imsun/gitment#gitment: falsegitment: owner: RuanXinyu repo: ruanxinyu.github.com client_id: 2a6e23cf2e29e54ef316 client_secret: f237d3eb9fc94607a0354f894b143efe52eb8aca 页面发布后，你需要访问页面并使用你的GitHub账号登录（请确保你的账号是第二步所填repo的owner），点击初始化按钮，之后其他用户即可在该页面发表评论。 如果初始化时出现Error：validation failed，则说明你的网址超过50个字符，这是由GitHub的Issue限制的，此时可以修改themes\\indigo\\layout\\_partial\\plugins\\gitment.ejs文件的如下内容，以时间为ID： 123456789var gitment = new Gitment(&#123; id: '&lt;%- page.date %&gt;', owner: '&lt;%- theme.gitment.owner %&gt;', repo: '&lt;%- theme.gitment.repo %&gt;', oauth: &#123; client_id: '&lt;%- theme.gitment.client_id %&gt;', client_secret: '&lt;%- theme.gitment.client_secret %&gt;', &#125;,&#125;) 现在在你的博文下就可以进行评论了： 在你所指定的GitHub仓库中的Issue中也会有你的评论信息： 如果出现其他问题，可以参考：https://imsun.net/posts/gitment-introduction/和https://www.jianshu.com/p/57afa4844aaa 使用个人独立域名经过上述的配置，我们的博客已经能够在公网访问，但是如果您还想需要自己的域名，而不是以github.io结尾的，比如我的域名为：blog.ruanxinyu.cn，那么您可以按照下面的说明进行配置。 配置域名解析DNS首先您需要购买自己的域名，比如通过阿里云进行购买https://wanwang.aliyun.com/?spm=5176.8142029.388261.275.a7236d3earZNnp，该过程比较繁琐，需要认证。 域名认证通过之后，需要在添在云解析DNS中加一项CNAME将你的独立域名指向你的GitHub Pages网址，如下图所示， 其中ruanxinyu.cn是我购买的域名；blog是我为我的博客分配的二级域名，二级域名是自己随意指定的；ruanxinyu.github.io是我的GitHub Pages地址。 配置GitHub仓库进入到你的GitHub Pages所在的代码仓库的配置中，将您的域名配置进去： 到此，您就可以通过您的独立域名访问您的博客内容，比如我的：https://blog.ruanxinyu.cn 还存在一个小问题，每次你通过hexo deploy -g将你的博客推送到你的GitHubPages的时候，域名配置就丢失了，为了解决此问题，我们可以在我的Hexo工程添加一个source/CNAME文件，在该文件中写入你的独立域名，比如blog.ruanxinyu.cn，这样每次推送，都会自动给您设置域名。 通过Git的子模块功能管理主题为什么要用Git的子模块功能呢？ 我们的博客代码是存在我们自己仓库中的，而主题是从别人的仓库中拉取的，并且我们会修改主题中的配置文件。如果我们将主题的内容全部存到我们的仓库中，那么如果主题的作者更新了内容，我们想同步下来就会很费劲。而Git的子模块功能就是为了解决这个问题的，允许你将一个Git仓库当作另外一个Git仓库的子目录，允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。 在华为DevCloud上建立私有代码仓因为敏感信息问题，我不想将hexo工程源码放和主题的源码放在gitHub上，因此我在华为软件开发云上建立了两个私有仓库: 一个用于存放我的hexo工程源码，地址为：1git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/Blog.git 一个用于存放我修改后的indigo主题，该仓库是从indigo的官方仓库导入进来的, 如下图所示, 地址为：1git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/hexo-theme-indigo.git 如何添加Git的子模块功能在第一次使用的时候，需要先添加子模块功能：1git submodule add -b card git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/hexo-theme-indigo.git themes/indigo 此时，会在你的代码目录下生成.gitmodules文件，该文件记录你的子模块信息：1234[submodule &quot;themes/indigo&quot;]truepath = themes/indigotrueurl = git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/hexo-theme-indigo.gittruebranch = card 然后执行git submodule init和git submodule update命令将远端的代码同步下来。 如何修改indigo主题的内容我们根据自己的需要修改主题文件夹中的文件，然后推送至我们的私有仓库即可，可以参考如下命令：1234cd themes/indigogit add .git commit -m '修改配置信息'git push origin card 如何同步indigo主题官方仓库的更新首先，我们将我们的仓库与官方的仓库进行一下关联，如下所示：1git remote add office -t card https://github.com/yscoder/hexo-theme-indigo.git 之后通过git pull office即可将官方的仓库合并到本地。 如何修改Hexo工程代码的内容Hexo工程就跟普通仓库一样维护即可，与子模块是相互独立的，当前两个仓库分开维护即可。Hexo工程代码并不会管理indigo主题的文件，而只是维护一个子模块的commit id。 克隆已经添加子模块功能的hexo工程使用子模块之后，克隆Hexo工程代码可以加上--recursive参数，将子模组的内容一起克隆下来，如果没有加该参数，则需要手动执行一下git submodule update：1git clone --recursive git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/Blog.git 你可能会遇到的坑 执行hexo deploy时报error deployer not found:github错误 您没有安装安装hexo-deployer-git造成的，通过 npm install hexo-deployer-git --save进行安装 执行hexo deploy时报Permission denied (publickey)错误 您的Github没有配置你的SSH key，配置方法参照上文的“配置GitHub Pages”章节 执行hexo deploy时报fatal: could not read Username for &#39;https://github.com&#39;: Invalid argument错误 在GitHub上设置SSH Key，同时将配置文件deploy配置下的git地址改为git@开头的ssh地址，如下所示： 1234deploy: type: git repo: git@github.com:RuanXinyu/ruanxinyu.github.com.git branch: master 百度统计没有数据 百度统计在初次添加后会有一定的延迟，可以手动检查是否添加成功，如下所示: gitment初始化评论时出现Error：validation failed 这是由于你的网址超过50个字符导致的，解决方式请参照上文“配置评论功能”中的第5条","raw":"---\ntitle: 如何使用GitHubPages搭建个人博客\ntags: 环境搭建\ncategories: 环境搭建\ndate: 2018-04-30 20:07:11\n---\n\n# 我对个人博客的要求\n我对个人博客有如下几点要求，因此最终选定通过`Hexo`+`GitHub Pages`来搭建。\n1. 存在独立域名，别人能通过互联网访问\n2. 通过Git进行管理，支持MarkDown语法\n3. 不需要自己购买主机维护环境\n4. 支持评论分享等功能\n\n# 配置GitHub Pages\n> 前提： 您需要有一个GitHub的账号，请将下文中的`ruanxinyu`替换为您的用户名。\n\n1. 点击[此处](https://github.com/new)，创建一个仓库， 一般GitHub Pages对应的仓库名称规则为： `用户名.github.io`， 如下图所示：\n{% asset_img 创建GitHub仓库.png [创建GitHub仓库] %}\n\n2. 现在仓库有了，但是在推送内容之前还需要设置GitHub的SSH秘钥，通过如下命令生成并查看SSH秘钥，如果需要输入，一路回车就即可：\n```\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" \ncat /c/Users/you/.ssh/id_rsa.pub\n```\n\n3. 进入到GitHub的Setting页面，添加SSH秘钥，如下图所示：\n{% asset_img 添加GitHub的SSHKey.png [添加GitHub的SSHKey] %}\n\n4. 下面，我们往仓库中推送一个`index.html`页面来充当我们的博客，可以参考如下命令：（Windows下可以使用git bash终端运行如下命令）\n```shell\ngit clone git@github.com:RuanXinyu/ruanxinyu.github.io.git\ncd ruanxinyu.github.io\necho \"Hello World\" > index.html\ngit add --all\ngit commit -m \"Initial commit\"\ngit push -u origin master\n```\n\n5. 此时你的博客已经产生，网址为：[https://ruanxinyu.github.io/](https://ruanxinyu.github.io/), 点击即可访问:\n\n\n\n# 安装并体验Hexo\n> GitHub Pages相当于一个静态网站，您需要将您的博客全部转换为html页面才可以，当然，这个繁琐的过程不需要我们自己去完成，当前有两个框架可以做这个事情：`Jekyll`和`Hexo`，下面我就介绍一下如何通过`Hexo`快速的发表自己的文章。\n\nHexo是一个NodeJS实现的博客框架，官方文档地址为： [https://hexo.io/zh-cn/docs/](https://hexo.io/zh-cn/docs/), 文档存在中文哦，给力吧！下面说一下使用过程：\n\n1. 执行`npm install -g hexo-cli`命令安装Hexo（在安装Hexo之前，请您自行安装NodeJS和NPM）\n\n2. 执行`hexo init xxx`创建一个博客\n\n3. 执行`hexo generate`渲染MarkDown博文，渲染出来的结果在`public`目录下\n\n4. 执行`npm install hexo-server --save`安装server工具，然后执行`hexo server`，访问[http://localhost:4000/](http://localhost:4000/)网址可在本地访问你的博客，该方式主要用于调试。\n\n5. 执行`hexo new xxx`创建一篇博文，博文的文件存放在`source\\_posts`目录下，编辑文档内容，hexo server会自动检测文章的变化并运行generate命令，因此刷新本地网址即可看到你更新的内容。\n\n6. 在将博文推送到GitHub Pages之前，执行`npm install hexo-deployer-git --save`安装部署工具，然后将根目录下的`_config.yml`文件中的如下内容更改为您的GitHub Pages的仓库地址，注意是`git@`开头的地址，否则在使用`hexo deploy`会报错\n```javascript\ndeploy:\n  type: git\n  repo: git@github.com:RuanXinyu/ruanxinyu.github.com.git\n  branch: master\n```\n\n7. 执行`hexo deploy`， Hexo将渲染后的页面放到`.deploy_git`目录，本地提交后，自动将您的博文推送到GitHub Pages所对应的仓库\n\n8. 此时，访问您的GitHubPages就可以看到你更新的文章内容。\n\n\n# 切换到Indigo主题\nHexo默认使用的是`landscape`主题，如果不符合自己的审美，可以在[https://hexo.io/themes/](https://hexo.io/themes/)查找自己喜欢的主题。我比较喜欢`indigo`主题，该主题有平铺和卡片两种显示方式，卡片模式的代码是在`card`分支下，下面以此主题为例。\n\n1. 克隆该主题的代码仓库，如下：\n```\ngit clone -b card https://github.com/yscoder/hexo-theme-indigo.git themes/indigo\n```\n\n2. 安装Indigo主题依赖的插件\n```\nnpm install hexo-renderer-less --save\nnpm install hexo-generator-feed --save\nnpm install hexo-generator-json-content --save\nnpm install hexo-helper-qrcode --save\n```\n\n3. 修改顶层配置文件`_config.yml`中的`theme: landscape`为`theme: indigo`，刷新页面即可看到新的主题。\n\n# 配置Hexo和Indigo主题\nHexo的配置文件为`_config.yml`，Indigo主题的配置文件在`themes/indigo/_config.yml`。\n\nHexo的配置说明文档地址为： [https://hexo.io/zh-cn/docs/configuration.html](https://hexo.io/zh-cn/docs/configuration.html)\nIndigo主题的配置说明文档地址为： [https://github.com/yscoder/hexo-theme-indigo/wiki/%E9%85%8D%E7%BD%AE](https://github.com/yscoder/hexo-theme-indigo/wiki/%E9%85%8D%E7%BD%AE)\n\n官方文档已经描述很清楚，当然，最简单的方式是基于别人的进行修改，因此在此我贡献出我的配置，然后对几个点做一下说明。\n\n## Hexo配置文件样例\n> 1. `language: zh-CN`: 语言的种类可以参考`themes/indigo/languages`目录下的文件\n> 2. `post_asset_folder: true`: 在创建博文的时候自动生成对应的文件夹，以存放该博文对应的图片\n> 3. 配置文件末尾的`feed`和`jsonContent`两部分分别是`hexo-generator-feed`和`hexo-generator-json-content`两个插件的配置，该部分说明在Indigo的说明文章中。\n\n```yml\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\n\ntitle: RuanXinYu's Blog\nsubtitle: 路漫漫其修远兮，吾将上下而求索\ndescription: 阮新宇的成长记录\nkeywords: Ruandy\nauthor: 阮新宇\nemail: 1096421257@qq.com\nurl: http://ruanxinyu.github.io/\nlanguage: zh-CN\ntimezone: Asia/Shanghai\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: true\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace: true\n  \n# Home page setting\n# path: Root path for your blogs index page. (default = '')\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\n  per_page: 20\n  order_by: -date\n  \n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 20\npagination_dir: page\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: indigo\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: git@github.com:RuanXinyu/ruanxinyu.github.com.git\n  branch: master\n\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 0\n\njsonContent:\n  meta: false\n  pages: false\n  posts:\n    title: true\n    date: true\n    path: true\n    text: true\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: true\n```\n\n## Indigo配置文件样例\n> 1. 该主题对应的图片在`themes/indigo/source/img`，请自行进行替换\n> 2. 样例内容配置了百度统计功能，下文有详细描述\n> 3. 样例内容配置了gitment的评论功能，下文有详细描述\n\n```yml\n# hexo-theme-indigo\n# https://github.com/yscoder/hexo-theme-indigo\n\n# 添加新菜单项遵循以下规则\n# menu:\n#  link:               fontawesome图标，省略前缀，本主题前缀为 icon-，必须\n#    text: About       菜单显示的文字，如果省略即默认与图标一致，首字母会转大写\n#    url: /about       链接，绝对或相对路径，必须。\n#    target: _blank    是否跳出，省略则在当前页面打开\nmenu:\n  home:\n    text: 主页\n    url: /\n  archives:\n    text: 归档\n    url: /archives\n  tags:\n    text: 标签\n    url: /tags\n  th-list:\n    text: 分类\n    url: /categories\n  github:\n    url: https://github.com/RuanXinyu\n    target: _blank\n\n# 你的头像url\navatar: /img/avatar.png\n# avatar link\navatar_link: /\n# 头像背景图\nbrand: /img/brand.jpg\n# favicon\nfavicon: /favicon.ico\n\n# email\nemail: 1096421257@qq.com\n\n# 设置 Android L Chrome 浏览器状态栏颜色\ncolor: '#3F51B5'\n\n# 页面标题\ntags_title: 标签\narchives_title: 归档\ncategories_title: 分类\n\n# 文章截断\nexcerpt_render: false\nexcerpt_length: 200\nexcerpt_link: 阅读全文...\nmathjax: false\narchive_yearly: true\n\n# 是否显示文章最后更新时间\nshow_last_updated: true\n\n# 是否开启分享\nshare: true\n\n# 是否开启打赏，关闭 reward: false\nreward:\n  title: 谢谢您的打赏\n  wechat: /img/wechat.png     #微信，关闭设为 false\n  alipay: /img/alipay.jpg     #支付宝，关闭设为 false\n\n# 是否开启搜索\nsearch: true\n\n# 是否大屏幕下文章页隐藏导航\nhideMenu: false\n\n# 是否开启toc\n# toc: false\ntoc:\n  list_number: true  # 是否显示数字排序\n\n# 文章页留言内容，hexo中所有变量及辅助函数等均可调用，具体请查阅 hexo.io\npostMessage: 原始链接：<a href=\"<%- url_for(page.path).replace(/index\\.html$/, '') %>\" target=\"_blank\" rel=\"external\"><%- page.permalink.replace(/index\\.html$/, '') %></a>\n\n# 站长统计，如要开启，输入CNZZ站点id，如 cnzz: 1255152447\ncnzz: false\n\n# 百度统计，如要开启，改为你的 key\nbaidu_tongji: b4c4998e548a16b827d4ffe9dbe2b47b\n\n# 腾讯分析，如要开启，输入站点id\ntajs: false\n\n# google\ngoogle_analytics: false\ngoogle_site_verification: false\n\n# sogou站长验证 http://zhanzhang.sogou.com/\nsogou_site_verification: false\n\n# less\nless:\n  compress: true\n  paths:\n    - source/css/style.less\n\n# 以下评论插件开启一个即可\n# 是否开启 disqus\ndisqus_shortname: false\n# 是否开启友言评论, 填写友言用户id\nuyan_uid: false\n# 是否使用 gitment，https://github.com/imsun/gitment\n#gitment: false\ngitment:\n  owner: RuanXinyu\n  repo: ruanxinyu.github.com\n  client_id: 2a6e23cf2e39e54ef316\n  client_secret: f237d3eb9fc94607a0454f894b143efe72eb8aca\n\n# Valine Comment system. https://valine.js.org\nvaline:\n  enable: false # 如果你想使用valine，请将值设置为 true\n  appId:  # your leancloud appId\n  appKey:  # your leancloud appKey\n  notify: false # Mail notify\n  verify: false # Verify code\n  avatar: mm # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide\n  placeholder: Just go go # Comment Box placeholder\n  guest_info: nick,mail,link # Comment header info\n  pageSize: 10 # comment list page size\n\n# 是否开启Hyper Comments，填写id则启用，false则禁用。http://hypercomments.com\n# Hyper Comments support. Write your id here, or false to disable\nhyper_id: false\n\n\n# 规范网址\n# 让搜索引擎重定向你的不同域名、不同子域、同域不同目录的站点到你期望的路径\n# https://support.google.com/webmasters/answer/139066\n# 假设配置为 canonical: http://imys.net，那么从搜索引擎中 www.imys.net 进入会重定向到 imys.net\ncanonical: false\n\n# 版权起始年份\nsince_year: 2015\n\n# 用户页面中作者相关的描述性文字，如不需要设为 false\nabout: 用户页面中作者相关的描述性文字，如不需要设为 false\n\n# “不蒜子”访问量统计，详见 http://ibruce.info/2015/04/04/busuanzi/\nvisit_counter:\n  site_uv: 站点总访客数：\n  site_pv: 站点总访问量：\n\n# 动态定义title\ntitle_change:\n  normal: 欢迎回来！\n  leave: 您还会回来吗？\n\n# 设置为 true 发布后将使用 unpkg cdn 最新的主题样式\n# 如果想让你的自定义样式生效，把此项设为 false\ncdn: true\n\n# 设置为 true 将使用 lightbox render 图片\nlightbox: true\n\n# icp备案号  ICP_license: 京ICP备1234556号-1\nICP_license: false\n```\n\n# 配置百度统计\n1. 百度统计是可以免费试用的，进入到[百度统计](https://tongji.baidu.com/web/homepage/index)注册账号，然后进入到管理页面添加你的网址，如下图所示：\n{% asset_img 百度统计添加网站.png [百度统计添加网站] %}\n\n2. 添加完成之后，你就可以看到你的Key，如下图所示：\n{% asset_img 百度统计key.png [百度统计key] %}\n\n3. 将你的key值添加到indigo主题的配置文件中即可，如下所示：\n```yml\n# 百度统计，如要开启，改为你的 key\nbaidu_tongji: b4c4998e548a16b827d4ffe9dbe2b47b\n```\n\n4. 访问百度统计查看你的网站访问情况等数据。\n{% asset_img 百度统计结果.png [百度统计结果] %}\n\n# 配置评论功能\n1. 友言评论功能已经关闭，因此采用的是gitment插件，该插件是依托于GitHub的Issue的功能的。采用`npm install --save gitment`命令安装gitment。\n\n2. 点击[此处](https://github.com/settings/applications/new)注册`OAuth Application`。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，比如： https://ruanxinyu.github.io ）。\n{% asset_img GitHubOAuth.png [blog.ruanxinyu.cn] %}\n\n3. 你会得到一个`client ID`和一个`client secret`，将其配置到indigo的配置文件中：\n```yml\n# 是否使用 gitment，https://github.com/imsun/gitment\n#gitment: false\ngitment:\n  owner: RuanXinyu\n  repo: ruanxinyu.github.com\n  client_id: 2a6e23cf2e29e54ef316\n  client_secret: f237d3eb9fc94607a0354f894b143efe52eb8aca\n```\n\n4. 页面发布后，你需要访问页面并使用你的GitHub账号登录（`请确保你的账号是第二步所填repo的owner`），点击初始化按钮，之后其他用户即可在该页面发表评论。\n\n5. 如果初始化时出现`Error：validation failed`，则说明你的网址超过50个字符，这是由GitHub的Issue限制的，此时可以修改`themes\\indigo\\layout\\_partial\\plugins\\gitment.ejs`文件的如下内容，以时间为ID：\n```javascript\nvar gitment = new Gitment({\n    id: '<%- page.date %>',\n    owner: '<%- theme.gitment.owner %>',\n    repo: '<%- theme.gitment.repo %>',\n    oauth: {\n        client_id: '<%- theme.gitment.client_id %>',\n        client_secret: '<%- theme.gitment.client_secret %>',\n    },\n})\n```\n\n6. 现在在你的博文下就可以进行评论了：\n{% asset_img 博文评论.png [博文评论] %}\n\n7. 在你所指定的GitHub仓库中的Issue中也会有你的评论信息：\n{% asset_img GitHubIssue.png [GitHubIssue] %}\n\n\n> 如果出现其他问题，可以参考：[https://imsun.net/posts/gitment-introduction/](https://imsun.net/posts/gitment-introduction/)和[https://www.jianshu.com/p/57afa4844aaa](https://www.jianshu.com/p/57afa4844aaa)\n\n# 使用个人独立域名\n经过上述的配置，我们的博客已经能够在公网访问，但是如果您还想需要自己的域名，而不是以`github.io`结尾的，比如我的域名为：`blog.ruanxinyu.cn`，那么您可以按照下面的说明进行配置。\n\n## 配置域名解析DNS\n首先您需要购买自己的域名，比如通过阿里云进行购买[https://wanwang.aliyun.com/?spm=5176.8142029.388261.275.a7236d3earZNnp](https://wanwang.aliyun.com/?spm=5176.8142029.388261.275.a7236d3earZNnp)，该过程比较繁琐，需要认证。\n\n域名认证通过之后，需要在添在云解析DNS中加一项`CNAME`将你的独立域名指向你的GitHub Pages网址，如下图所示，\n> 其中`ruanxinyu.cn`是我购买的域名；`blog`是我为我的博客分配的二级域名，二级域名是自己随意指定的；`ruanxinyu.github.io`是我的GitHub Pages地址。\n\n{% asset_img 阿里云域名解析设置.png [阿里云域名解析设置] %}\n\n## 配置GitHub仓库\n进入到你的GitHub Pages所在的代码仓库的配置中，将您的域名配置进去：\n{% asset_img GitHub配置域名设置入口.png [GitHub配置域名设置入口] %}\n{% asset_img GitHub配置域名.png [GitHub配置域名] %}\n\n到此，您就可以通过您的独立域名访问您的博客内容，比如我的：[https://blog.ruanxinyu.cn](https://blog.ruanxinyu.cn)\n\n> 还存在一个小问题，每次你通过`hexo deploy -g`将你的博客推送到你的GitHubPages的时候，域名配置就丢失了，为了解决此问题，我们可以在我的Hexo工程添加一个`source/CNAME`文件，在该文件中写入你的独立域名，比如`blog.ruanxinyu.cn`，这样每次推送，都会自动给您设置域名。\n\n\n# 通过Git的子模块功能管理主题\n为什么要用Git的子模块功能呢？\n> 我们的博客代码是存在我们自己仓库中的，而主题是从别人的仓库中拉取的，并且我们会修改主题中的配置文件。如果我们将主题的内容全部存到我们的仓库中，那么如果主题的作者更新了内容，我们想同步下来就会很费劲。而Git的子模块功能就是为了解决这个问题的，允许你将一个Git仓库当作另外一个Git仓库的子目录，允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。\n\n## 在华为DevCloud上建立私有代码仓\n因为敏感信息问题，我不想将hexo工程源码放和主题的源码放在gitHub上，因此我在华为软件开发云上建立了两个私有仓库:\n\n一个用于存放我的hexo工程源码，地址为： \n```\ngit@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/Blog.git\n```\n\n一个用于存放我修改后的indigo主题，该仓库是从indigo的官方仓库导入进来的, 如下图所示, 地址为： \n```\ngit@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/hexo-theme-indigo.git\n```\n{% asset_img 华为云创建仓库.png [华为云创建仓库] %}\n\n\n## 如何添加Git的子模块功能\n在第一次使用的时候，需要先添加子模块功能：\n```\ngit submodule add -b card git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/hexo-theme-indigo.git themes/indigo\n```\n\n此时，会在你的代码目录下生成`.gitmodules`文件，该文件记录你的子模块信息：\n```\n[submodule \"themes/indigo\"]\n\tpath = themes/indigo\n\turl = git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/hexo-theme-indigo.git\n\tbranch = card\n```\n\n然后执行`git submodule init`和`git submodule update`命令将远端的代码同步下来。\n\n\n## 如何修改indigo主题的内容\n我们根据自己的需要修改主题文件夹中的文件，然后推送至我们的私有仓库即可，可以参考如下命令：\n```shell\ncd themes/indigo\ngit add .\ngit commit -m '修改配置信息'\ngit push origin card\n```\n\n\n## 如何同步indigo主题官方仓库的更新\n首先，我们将我们的仓库与官方的仓库进行一下关联，如下所示：\n```\ngit remote add office -t card https://github.com/yscoder/hexo-theme-indigo.git\n```\n\n之后通过`git pull office`即可将官方的仓库合并到本地。\n\n\n## 如何修改Hexo工程代码的内容\nHexo工程就跟普通仓库一样维护即可，与子模块是相互独立的，当前两个仓库分开维护即可。Hexo工程代码并不会管理indigo主题的文件，而只是维护一个子模块的commit id。\n\n\n## 克隆已经添加子模块功能的hexo工程\n使用子模块之后，克隆Hexo工程代码可以加上`--recursive`参数，将子模组的内容一起克隆下来，如果没有加该参数，则需要手动执行一下`git submodule update`：\n```\ngit clone --recursive git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/Blog.git\n```\n\n# 你可能会遇到的坑\n1. 执行`hexo deploy`时报`error deployer not found:github`错误\n> 您没有安装安装`hexo-deployer-git`造成的，通过 `npm install hexo-deployer-git --save`进行安装\n\n2. 执行`hexo deploy`时报`Permission denied (publickey)`错误\n> 您的Github没有配置你的SSH key，配置方法参照上文的“配置GitHub Pages”章节\n\n3.  执行`hexo deploy`时报`fatal: could not read Username for 'https://github.com': Invalid argument`错误\n> 在GitHub上设置SSH Key，同时将配置文件`deploy`配置下的git地址改为`git@`开头的ssh地址，如下所示：\n```javascript\ndeploy:\n  type: git\n  repo: git@github.com:RuanXinyu/ruanxinyu.github.com.git\n  branch: master\n```\n\n4. 百度统计没有数据\n> 百度统计在初次添加后会有一定的延迟，可以手动检查是否添加成功，如下所示:\n{% asset_img 百度统计检查状态.png [百度统计检查状态] %}\n\n5. gitment初始化评论时出现`Error：validation failed`\n> 这是由于你的网址超过50个字符导致的，解决方式请参照上文“配置评论功能”中的第5条\n\n\n\n","content":"<h1 id=\"我对个人博客的要求\"><a href=\"#我对个人博客的要求\" class=\"headerlink\" title=\"我对个人博客的要求\"></a>我对个人博客的要求</h1><p>我对个人博客有如下几点要求，因此最终选定通过<code>Hexo</code>+<code>GitHub Pages</code>来搭建。</p>\n<ol>\n<li>存在独立域名，别人能通过互联网访问</li>\n<li>通过Git进行管理，支持MarkDown语法</li>\n<li>不需要自己购买主机维护环境</li>\n<li>支持评论分享等功能</li>\n</ol>\n<h1 id=\"配置GitHub-Pages\"><a href=\"#配置GitHub-Pages\" class=\"headerlink\" title=\"配置GitHub Pages\"></a>配置GitHub Pages</h1><blockquote>\n<p>前提： 您需要有一个GitHub的账号，请将下文中的<code>ruanxinyu</code>替换为您的用户名。</p>\n</blockquote>\n<ol>\n<li><p>点击<a href=\"https://github.com/new\" target=\"_blank\" rel=\"noopener\">此处</a>，创建一个仓库， 一般GitHub Pages对应的仓库名称规则为： <code>用户名.github.io</code>， 如下图所示：</p>\n<img src=\"/posts/如何使用GitHubPages搭建个人博客/创建GitHub仓库.png\" title=\"[创建GitHub仓库]\">\n</li>\n<li><p>现在仓库有了，但是在推送内容之前还需要设置GitHub的SSH秘钥，通过如下命令生成并查看SSH秘钥，如果需要输入，一路回车就即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; </span><br><span class=\"line\">cat /c/Users/you/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进入到GitHub的Setting页面，添加SSH秘钥，如下图所示：</p>\n<img src=\"/posts/如何使用GitHubPages搭建个人博客/添加GitHub的SSHKey.png\" title=\"[添加GitHub的SSHKey]\">\n</li>\n<li><p>下面，我们往仓库中推送一个<code>index.html</code>页面来充当我们的博客，可以参考如下命令：（Windows下可以使用git bash终端运行如下命令）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:RuanXinyu/ruanxinyu.github.io.git</span><br><span class=\"line\">cd ruanxinyu.github.io</span><br><span class=\"line\">echo \"Hello World\" &gt; index.html</span><br><span class=\"line\">git add --all</span><br><span class=\"line\">git commit -m \"Initial commit\"</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>此时你的博客已经产生，网址为：<a href=\"https://ruanxinyu.github.io/\">https://ruanxinyu.github.io/</a>, 点击即可访问:</p>\n</li>\n</ol>\n<h1 id=\"安装并体验Hexo\"><a href=\"#安装并体验Hexo\" class=\"headerlink\" title=\"安装并体验Hexo\"></a>安装并体验Hexo</h1><blockquote>\n<p>GitHub Pages相当于一个静态网站，您需要将您的博客全部转换为html页面才可以，当然，这个繁琐的过程不需要我们自己去完成，当前有两个框架可以做这个事情：<code>Jekyll</code>和<code>Hexo</code>，下面我就介绍一下如何通过<code>Hexo</code>快速的发表自己的文章。</p>\n</blockquote>\n<p>Hexo是一个NodeJS实现的博客框架，官方文档地址为： <a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs/</a>, 文档存在中文哦，给力吧！下面说一下使用过程：</p>\n<ol>\n<li><p>执行<code>npm install -g hexo-cli</code>命令安装Hexo（在安装Hexo之前，请您自行安装NodeJS和NPM）</p>\n</li>\n<li><p>执行<code>hexo init xxx</code>创建一个博客</p>\n</li>\n<li><p>执行<code>hexo generate</code>渲染MarkDown博文，渲染出来的结果在<code>public</code>目录下</p>\n</li>\n<li><p>执行<code>npm install hexo-server --save</code>安装server工具，然后执行<code>hexo server</code>，访问<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a>网址可在本地访问你的博客，该方式主要用于调试。</p>\n</li>\n<li><p>执行<code>hexo new xxx</code>创建一篇博文，博文的文件存放在<code>source\\_posts</code>目录下，编辑文档内容，hexo server会自动检测文章的变化并运行generate命令，因此刷新本地网址即可看到你更新的内容。</p>\n</li>\n<li><p>在将博文推送到GitHub Pages之前，执行<code>npm install hexo-deployer-git --save</code>安装部署工具，然后将根目录下的<code>_config.yml</code>文件中的如下内容更改为您的GitHub Pages的仓库地址，注意是<code>git@</code>开头的地址，否则在使用<code>hexo deploy</code>会报错</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:RuanXinyu/ruanxinyu.github.com.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行<code>hexo deploy</code>， Hexo将渲染后的页面放到<code>.deploy_git</code>目录，本地提交后，自动将您的博文推送到GitHub Pages所对应的仓库</p>\n</li>\n<li><p>此时，访问您的GitHubPages就可以看到你更新的文章内容。</p>\n</li>\n</ol>\n<h1 id=\"切换到Indigo主题\"><a href=\"#切换到Indigo主题\" class=\"headerlink\" title=\"切换到Indigo主题\"></a>切换到Indigo主题</h1><p>Hexo默认使用的是<code>landscape</code>主题，如果不符合自己的审美，可以在<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/themes/</a>查找自己喜欢的主题。我比较喜欢<code>indigo</code>主题，该主题有平铺和卡片两种显示方式，卡片模式的代码是在<code>card</code>分支下，下面以此主题为例。</p>\n<ol>\n<li><p>克隆该主题的代码仓库，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone -b card https://github.com/yscoder/hexo-theme-indigo.git themes/indigo</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装Indigo主题依赖的插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-less --save</span><br><span class=\"line\">npm install hexo-generator-feed --save</span><br><span class=\"line\">npm install hexo-generator-json-content --save</span><br><span class=\"line\">npm install hexo-helper-qrcode --save</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改顶层配置文件<code>_config.yml</code>中的<code>theme: landscape</code>为<code>theme: indigo</code>，刷新页面即可看到新的主题。</p>\n</li>\n</ol>\n<h1 id=\"配置Hexo和Indigo主题\"><a href=\"#配置Hexo和Indigo主题\" class=\"headerlink\" title=\"配置Hexo和Indigo主题\"></a>配置Hexo和Indigo主题</h1><p>Hexo的配置文件为<code>_config.yml</code>，Indigo主题的配置文件在<code>themes/indigo/_config.yml</code>。</p>\n<p>Hexo的配置说明文档地址为： <a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs/configuration.html</a><br>Indigo主题的配置说明文档地址为： <a href=\"https://github.com/yscoder/hexo-theme-indigo/wiki/%E9%85%8D%E7%BD%AE\" target=\"_blank\" rel=\"noopener\">https://github.com/yscoder/hexo-theme-indigo/wiki/%E9%85%8D%E7%BD%AE</a></p>\n<p>官方文档已经描述很清楚，当然，最简单的方式是基于别人的进行修改，因此在此我贡献出我的配置，然后对几个点做一下说明。</p>\n<h2 id=\"Hexo配置文件样例\"><a href=\"#Hexo配置文件样例\" class=\"headerlink\" title=\"Hexo配置文件样例\"></a>Hexo配置文件样例</h2><blockquote>\n<ol>\n<li><code>language: zh-CN</code>: 语言的种类可以参考<code>themes/indigo/languages</code>目录下的文件</li>\n<li><code>post_asset_folder: true</code>: 在创建博文的时候自动生成对应的文件夹，以存放该博文对应的图片</li>\n<li>配置文件末尾的<code>feed</code>和<code>jsonContent</code>两部分分别是<code>hexo-generator-feed</code>和<code>hexo-generator-json-content</code>两个插件的配置，该部分说明在Indigo的说明文章中。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Hexo Configuration</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class=\"line\"><span class=\"comment\">## Source: https://github.com/hexojs/hexo/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Site</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">RuanXinYu's</span> <span class=\"string\">Blog</span></span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> <span class=\"string\">路漫漫其修远兮，吾将上下而求索</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">阮新宇的成长记录</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"string\">Ruandy</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">阮新宇</span></span><br><span class=\"line\"><span class=\"attr\">email:</span> <span class=\"number\">1096421257</span><span class=\"string\">@qq.com</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"attr\">http://ruanxinyu.github.io/</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span></span><br><span class=\"line\"><span class=\"attr\">timezone:</span> <span class=\"string\">Asia/Shanghai</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># URL</span></span><br><span class=\"line\"><span class=\"comment\">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/</span></span><br><span class=\"line\"><span class=\"attr\">permalink:</span> <span class=\"string\">:year/:month/:day/:title/</span></span><br><span class=\"line\"><span class=\"attr\">permalink_defaults:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Directory</span></span><br><span class=\"line\"><span class=\"attr\">source_dir:</span> <span class=\"string\">source</span></span><br><span class=\"line\"><span class=\"attr\">public_dir:</span> <span class=\"string\">public</span></span><br><span class=\"line\"><span class=\"attr\">tag_dir:</span> <span class=\"string\">tags</span></span><br><span class=\"line\"><span class=\"attr\">archive_dir:</span> <span class=\"string\">archives</span></span><br><span class=\"line\"><span class=\"attr\">category_dir:</span> <span class=\"string\">categories</span></span><br><span class=\"line\"><span class=\"attr\">code_dir:</span> <span class=\"string\">downloads/code</span></span><br><span class=\"line\"><span class=\"attr\">i18n_dir:</span> <span class=\"string\">:lang</span></span><br><span class=\"line\"><span class=\"attr\">skip_render:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Writing</span></span><br><span class=\"line\"><span class=\"attr\">new_post_name:</span> <span class=\"string\">:title.md</span> <span class=\"comment\"># File name of new posts</span></span><br><span class=\"line\"><span class=\"attr\">default_layout:</span> <span class=\"string\">post</span></span><br><span class=\"line\"><span class=\"attr\">titlecase:</span> <span class=\"literal\">false</span> <span class=\"comment\"># Transform title into titlecase</span></span><br><span class=\"line\"><span class=\"attr\">external_link:</span> <span class=\"literal\">true</span> <span class=\"comment\"># Open external links in new tab</span></span><br><span class=\"line\"><span class=\"attr\">filename_case:</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"attr\">render_drafts:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">post_asset_folder:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">relative_link:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">future:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">highlight:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  line_number:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  auto_detect:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  tab_replace:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># Home page setting</span></span><br><span class=\"line\"><span class=\"comment\"># path: Root path for your blogs index page. (default = '')</span></span><br><span class=\"line\"><span class=\"comment\"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class=\"line\"><span class=\"comment\"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class=\"line\"><span class=\"attr\">index_generator:</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">''</span></span><br><span class=\"line\"><span class=\"attr\">  per_page:</span> <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"attr\">  order_by:</span> <span class=\"bullet\">-date</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># Category &amp; Tag</span></span><br><span class=\"line\"><span class=\"attr\">default_category:</span> <span class=\"string\">uncategorized</span></span><br><span class=\"line\"><span class=\"attr\">category_map:</span></span><br><span class=\"line\"><span class=\"attr\">tag_map:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Date / Time format</span></span><br><span class=\"line\"><span class=\"comment\">## Hexo uses Moment.js to parse and display date</span></span><br><span class=\"line\"><span class=\"comment\">## You can customize the date format as defined in</span></span><br><span class=\"line\"><span class=\"comment\">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class=\"line\"><span class=\"attr\">date_format:</span> <span class=\"string\">YYYY-MM-DD</span></span><br><span class=\"line\"><span class=\"attr\">time_format:</span> <span class=\"attr\">HH:mm:ss</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Pagination</span></span><br><span class=\"line\"><span class=\"comment\">## Set per_page to 0 to disable pagination</span></span><br><span class=\"line\"><span class=\"attr\">per_page:</span> <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"attr\">pagination_dir:</span> <span class=\"string\">page</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Extensions</span></span><br><span class=\"line\"><span class=\"comment\">## Plugins: https://hexo.io/plugins/</span></span><br><span class=\"line\"><span class=\"comment\">## Themes: https://hexo.io/themes/</span></span><br><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">indigo</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"string\">git@github.com:RuanXinyu/ruanxinyu.github.com.git</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">master</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">feed:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">atom</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">atom.xml</span></span><br><span class=\"line\"><span class=\"attr\">  limit:</span> <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jsonContent:</span></span><br><span class=\"line\"><span class=\"attr\">  meta:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  pages:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  posts:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    categories:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    tags:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Indigo配置文件样例\"><a href=\"#Indigo配置文件样例\" class=\"headerlink\" title=\"Indigo配置文件样例\"></a>Indigo配置文件样例</h2><blockquote>\n<ol>\n<li>该主题对应的图片在<code>themes/indigo/source/img</code>，请自行进行替换</li>\n<li>样例内容配置了百度统计功能，下文有详细描述</li>\n<li>样例内容配置了gitment的评论功能，下文有详细描述</li>\n</ol>\n</blockquote>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># hexo-theme-indigo</span></span><br><span class=\"line\"><span class=\"comment\"># https://github.com/yscoder/hexo-theme-indigo</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加新菜单项遵循以下规则</span></span><br><span class=\"line\"><span class=\"comment\"># menu:</span></span><br><span class=\"line\"><span class=\"comment\">#  link:               fontawesome图标，省略前缀，本主题前缀为 icon-，必须</span></span><br><span class=\"line\"><span class=\"comment\">#    text: About       菜单显示的文字，如果省略即默认与图标一致，首字母会转大写</span></span><br><span class=\"line\"><span class=\"comment\">#    url: /about       链接，绝对或相对路径，必须。</span></span><br><span class=\"line\"><span class=\"comment\">#    target: _blank    是否跳出，省略则在当前页面打开</span></span><br><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\"><span class=\"attr\">  home:</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"string\">主页</span></span><br><span class=\"line\"><span class=\"attr\">    url:</span> <span class=\"string\">/</span></span><br><span class=\"line\"><span class=\"attr\">  archives:</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"string\">归档</span></span><br><span class=\"line\"><span class=\"attr\">    url:</span> <span class=\"string\">/archives</span></span><br><span class=\"line\"><span class=\"attr\">  tags:</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"string\">标签</span></span><br><span class=\"line\"><span class=\"attr\">    url:</span> <span class=\"string\">/tags</span></span><br><span class=\"line\"><span class=\"attr\">  th-list:</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"string\">分类</span></span><br><span class=\"line\"><span class=\"attr\">    url:</span> <span class=\"string\">/categories</span></span><br><span class=\"line\"><span class=\"attr\">  github:</span></span><br><span class=\"line\"><span class=\"attr\">    url:</span> <span class=\"attr\">https://github.com/RuanXinyu</span></span><br><span class=\"line\"><span class=\"attr\">    target:</span> <span class=\"string\">_blank</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 你的头像url</span></span><br><span class=\"line\"><span class=\"attr\">avatar:</span> <span class=\"string\">/img/avatar.png</span></span><br><span class=\"line\"><span class=\"comment\"># avatar link</span></span><br><span class=\"line\"><span class=\"attr\">avatar_link:</span> <span class=\"string\">/</span></span><br><span class=\"line\"><span class=\"comment\"># 头像背景图</span></span><br><span class=\"line\"><span class=\"attr\">brand:</span> <span class=\"string\">/img/brand.jpg</span></span><br><span class=\"line\"><span class=\"comment\"># favicon</span></span><br><span class=\"line\"><span class=\"attr\">favicon:</span> <span class=\"string\">/favicon.ico</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># email</span></span><br><span class=\"line\"><span class=\"attr\">email:</span> <span class=\"number\">1096421257</span><span class=\"string\">@qq.com</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 Android L Chrome 浏览器状态栏颜色</span></span><br><span class=\"line\"><span class=\"attr\">color:</span> <span class=\"string\">'#3F51B5'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 页面标题</span></span><br><span class=\"line\"><span class=\"attr\">tags_title:</span> <span class=\"string\">标签</span></span><br><span class=\"line\"><span class=\"attr\">archives_title:</span> <span class=\"string\">归档</span></span><br><span class=\"line\"><span class=\"attr\">categories_title:</span> <span class=\"string\">分类</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 文章截断</span></span><br><span class=\"line\"><span class=\"attr\">excerpt_render:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">excerpt_length:</span> <span class=\"number\">200</span></span><br><span class=\"line\"><span class=\"attr\">excerpt_link:</span> <span class=\"string\">阅读全文...</span></span><br><span class=\"line\"><span class=\"attr\">mathjax:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">archive_yearly:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 是否显示文章最后更新时间</span></span><br><span class=\"line\"><span class=\"attr\">show_last_updated:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 是否开启分享</span></span><br><span class=\"line\"><span class=\"attr\">share:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 是否开启打赏，关闭 reward: false</span></span><br><span class=\"line\"><span class=\"attr\">reward:</span></span><br><span class=\"line\"><span class=\"attr\">  title:</span> <span class=\"string\">谢谢您的打赏</span></span><br><span class=\"line\"><span class=\"attr\">  wechat:</span> <span class=\"string\">/img/wechat.png</span>     <span class=\"comment\">#微信，关闭设为 false</span></span><br><span class=\"line\"><span class=\"attr\">  alipay:</span> <span class=\"string\">/img/alipay.jpg</span>     <span class=\"comment\">#支付宝，关闭设为 false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 是否开启搜索</span></span><br><span class=\"line\"><span class=\"attr\">search:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 是否大屏幕下文章页隐藏导航</span></span><br><span class=\"line\"><span class=\"attr\">hideMenu:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 是否开启toc</span></span><br><span class=\"line\"><span class=\"comment\"># toc: false</span></span><br><span class=\"line\"><span class=\"attr\">toc:</span></span><br><span class=\"line\"><span class=\"attr\">  list_number:</span> <span class=\"literal\">true</span>  <span class=\"comment\"># 是否显示数字排序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 文章页留言内容，hexo中所有变量及辅助函数等均可调用，具体请查阅 hexo.io</span></span><br><span class=\"line\"><span class=\"attr\">postMessage:</span> <span class=\"string\">原始链接：&lt;a</span> <span class=\"string\">href=\"&lt;%-</span> <span class=\"string\">url_for(page.path).replace(/index\\.html$/,</span> <span class=\"string\">''</span><span class=\"string\">)</span> <span class=\"string\">%&gt;\"</span> <span class=\"string\">target=\"_blank\"</span> <span class=\"string\">rel=\"external\"&gt;&lt;%-</span> <span class=\"string\">page.permalink.replace(/index\\.html$/,</span> <span class=\"string\">''</span><span class=\"string\">)</span> <span class=\"string\">%&gt;&lt;/a&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 站长统计，如要开启，输入CNZZ站点id，如 cnzz: 1255152447</span></span><br><span class=\"line\"><span class=\"attr\">cnzz:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 百度统计，如要开启，改为你的 key</span></span><br><span class=\"line\"><span class=\"attr\">baidu_tongji:</span> <span class=\"string\">b4c4998e548a16b827d4ffe9dbe2b47b</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 腾讯分析，如要开启，输入站点id</span></span><br><span class=\"line\"><span class=\"attr\">tajs:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># google</span></span><br><span class=\"line\"><span class=\"attr\">google_analytics:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">google_site_verification:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># sogou站长验证 http://zhanzhang.sogou.com/</span></span><br><span class=\"line\"><span class=\"attr\">sogou_site_verification:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># less</span></span><br><span class=\"line\"><span class=\"attr\">less:</span></span><br><span class=\"line\"><span class=\"attr\">  compress:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  paths:</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">source/css/style.less</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以下评论插件开启一个即可</span></span><br><span class=\"line\"><span class=\"comment\"># 是否开启 disqus</span></span><br><span class=\"line\"><span class=\"attr\">disqus_shortname:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 是否开启友言评论, 填写友言用户id</span></span><br><span class=\"line\"><span class=\"attr\">uyan_uid:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 是否使用 gitment，https://github.com/imsun/gitment</span></span><br><span class=\"line\"><span class=\"comment\">#gitment: false</span></span><br><span class=\"line\"><span class=\"attr\">gitment:</span></span><br><span class=\"line\"><span class=\"attr\">  owner:</span> <span class=\"string\">RuanXinyu</span></span><br><span class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"string\">ruanxinyu.github.com</span></span><br><span class=\"line\"><span class=\"attr\">  client_id:</span> <span class=\"number\">2</span><span class=\"string\">a6e23cf2e39e54ef316</span></span><br><span class=\"line\"><span class=\"attr\">  client_secret:</span> <span class=\"string\">f237d3eb9fc94607a0454f894b143efe72eb8aca</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Valine Comment system. https://valine.js.org</span></span><br><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 如果你想使用valine，请将值设置为 true</span></span><br><span class=\"line\"><span class=\"attr\">  appId:</span>  <span class=\"comment\"># your leancloud appId</span></span><br><span class=\"line\"><span class=\"attr\">  appKey:</span>  <span class=\"comment\"># your leancloud appKey</span></span><br><span class=\"line\"><span class=\"attr\">  notify:</span> <span class=\"literal\">false</span> <span class=\"comment\"># Mail notify</span></span><br><span class=\"line\"><span class=\"attr\">  verify:</span> <span class=\"literal\">false</span> <span class=\"comment\"># Verify code</span></span><br><span class=\"line\"><span class=\"attr\">  avatar:</span> <span class=\"string\">mm</span> <span class=\"comment\"># Gravatar style : mm/identicon/monsterid/wavatar/retro/hide</span></span><br><span class=\"line\"><span class=\"attr\">  placeholder:</span> <span class=\"string\">Just</span> <span class=\"string\">go</span> <span class=\"string\">go</span> <span class=\"comment\"># Comment Box placeholder</span></span><br><span class=\"line\"><span class=\"attr\">  guest_info:</span> <span class=\"string\">nick,mail,link</span> <span class=\"comment\"># Comment header info</span></span><br><span class=\"line\"><span class=\"attr\">  pageSize:</span> <span class=\"number\">10</span> <span class=\"comment\"># comment list page size</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 是否开启Hyper Comments，填写id则启用，false则禁用。http://hypercomments.com</span></span><br><span class=\"line\"><span class=\"comment\"># Hyper Comments support. Write your id here, or false to disable</span></span><br><span class=\"line\"><span class=\"attr\">hyper_id:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 规范网址</span></span><br><span class=\"line\"><span class=\"comment\"># 让搜索引擎重定向你的不同域名、不同子域、同域不同目录的站点到你期望的路径</span></span><br><span class=\"line\"><span class=\"comment\"># https://support.google.com/webmasters/answer/139066</span></span><br><span class=\"line\"><span class=\"comment\"># 假设配置为 canonical: http://imys.net，那么从搜索引擎中 www.imys.net 进入会重定向到 imys.net</span></span><br><span class=\"line\"><span class=\"attr\">canonical:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 版权起始年份</span></span><br><span class=\"line\"><span class=\"attr\">since_year:</span> <span class=\"number\">2015</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 用户页面中作者相关的描述性文字，如不需要设为 false</span></span><br><span class=\"line\"><span class=\"attr\">about:</span> <span class=\"string\">用户页面中作者相关的描述性文字，如不需要设为</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># “不蒜子”访问量统计，详见 http://ibruce.info/2015/04/04/busuanzi/</span></span><br><span class=\"line\"><span class=\"attr\">visit_counter:</span></span><br><span class=\"line\"><span class=\"attr\">  site_uv:</span> <span class=\"string\">站点总访客数：</span></span><br><span class=\"line\"><span class=\"attr\">  site_pv:</span> <span class=\"string\">站点总访问量：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 动态定义title</span></span><br><span class=\"line\"><span class=\"attr\">title_change:</span></span><br><span class=\"line\"><span class=\"attr\">  normal:</span> <span class=\"string\">欢迎回来！</span></span><br><span class=\"line\"><span class=\"attr\">  leave:</span> <span class=\"string\">您还会回来吗？</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置为 true 发布后将使用 unpkg cdn 最新的主题样式</span></span><br><span class=\"line\"><span class=\"comment\"># 如果想让你的自定义样式生效，把此项设为 false</span></span><br><span class=\"line\"><span class=\"attr\">cdn:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置为 true 将使用 lightbox render 图片</span></span><br><span class=\"line\"><span class=\"attr\">lightbox:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># icp备案号  ICP_license: 京ICP备1234556号-1</span></span><br><span class=\"line\"><span class=\"attr\">ICP_license:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"配置百度统计\"><a href=\"#配置百度统计\" class=\"headerlink\" title=\"配置百度统计\"></a>配置百度统计</h1><ol>\n<li><p>百度统计是可以免费试用的，进入到<a href=\"https://tongji.baidu.com/web/homepage/index\" target=\"_blank\" rel=\"noopener\">百度统计</a>注册账号，然后进入到管理页面添加你的网址，如下图所示：</p>\n<img src=\"/posts/如何使用GitHubPages搭建个人博客/百度统计添加网站.png\" title=\"[百度统计添加网站]\">\n</li>\n<li><p>添加完成之后，你就可以看到你的Key，如下图所示：</p>\n<img src=\"/posts/如何使用GitHubPages搭建个人博客/百度统计key.png\" title=\"[百度统计key]\">\n</li>\n<li><p>将你的key值添加到indigo主题的配置文件中即可，如下所示：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 百度统计，如要开启，改为你的 key</span></span><br><span class=\"line\"><span class=\"attr\">baidu_tongji:</span> <span class=\"string\">b4c4998e548a16b827d4ffe9dbe2b47b</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>访问百度统计查看你的网站访问情况等数据。</p>\n<img src=\"/posts/如何使用GitHubPages搭建个人博客/百度统计结果.png\" title=\"[百度统计结果]\">\n</li>\n</ol>\n<h1 id=\"配置评论功能\"><a href=\"#配置评论功能\" class=\"headerlink\" title=\"配置评论功能\"></a>配置评论功能</h1><ol>\n<li><p>友言评论功能已经关闭，因此采用的是gitment插件，该插件是依托于GitHub的Issue的功能的。采用<code>npm install --save gitment</code>命令安装gitment。</p>\n</li>\n<li><p>点击<a href=\"https://github.com/settings/applications/new\" target=\"_blank\" rel=\"noopener\">此处</a>注册<code>OAuth Application</code>。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，比如： <a href=\"https://ruanxinyu.github.io\">https://ruanxinyu.github.io</a> ）。</p>\n<img src=\"/posts/如何使用GitHubPages搭建个人博客/GitHubOAuth.png\" title=\"[blog.ruanxinyu.cn]\">\n</li>\n<li><p>你会得到一个<code>client ID</code>和一个<code>client secret</code>，将其配置到indigo的配置文件中：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 是否使用 gitment，https://github.com/imsun/gitment</span></span><br><span class=\"line\"><span class=\"comment\">#gitment: false</span></span><br><span class=\"line\"><span class=\"attr\">gitment:</span></span><br><span class=\"line\"><span class=\"attr\">  owner:</span> <span class=\"string\">RuanXinyu</span></span><br><span class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"string\">ruanxinyu.github.com</span></span><br><span class=\"line\"><span class=\"attr\">  client_id:</span> <span class=\"number\">2</span><span class=\"string\">a6e23cf2e29e54ef316</span></span><br><span class=\"line\"><span class=\"attr\">  client_secret:</span> <span class=\"string\">f237d3eb9fc94607a0354f894b143efe52eb8aca</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>页面发布后，你需要访问页面并使用你的GitHub账号登录（<code>请确保你的账号是第二步所填repo的owner</code>），点击初始化按钮，之后其他用户即可在该页面发表评论。</p>\n</li>\n<li><p>如果初始化时出现<code>Error：validation failed</code>，则说明你的网址超过50个字符，这是由GitHub的Issue限制的，此时可以修改<code>themes\\indigo\\layout\\_partial\\plugins\\gitment.ejs</code>文件的如下内容，以时间为ID：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gitment = <span class=\"keyword\">new</span> Gitment(&#123;</span><br><span class=\"line\">    id: <span class=\"string\">'&lt;%- page.date %&gt;'</span>,</span><br><span class=\"line\">    owner: <span class=\"string\">'&lt;%- theme.gitment.owner %&gt;'</span>,</span><br><span class=\"line\">    repo: <span class=\"string\">'&lt;%- theme.gitment.repo %&gt;'</span>,</span><br><span class=\"line\">    oauth: &#123;</span><br><span class=\"line\">        client_id: <span class=\"string\">'&lt;%- theme.gitment.client_id %&gt;'</span>,</span><br><span class=\"line\">        client_secret: <span class=\"string\">'&lt;%- theme.gitment.client_secret %&gt;'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>现在在你的博文下就可以进行评论了：</p>\n<img src=\"/posts/如何使用GitHubPages搭建个人博客/博文评论.png\" title=\"[博文评论]\">\n</li>\n<li><p>在你所指定的GitHub仓库中的Issue中也会有你的评论信息：</p>\n<img src=\"/posts/如何使用GitHubPages搭建个人博客/GitHubIssue.png\" title=\"[GitHubIssue]\">\n</li>\n</ol>\n<blockquote>\n<p>如果出现其他问题，可以参考：<a href=\"https://imsun.net/posts/gitment-introduction/\" target=\"_blank\" rel=\"noopener\">https://imsun.net/posts/gitment-introduction/</a>和<a href=\"https://www.jianshu.com/p/57afa4844aaa\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/57afa4844aaa</a></p>\n</blockquote>\n<h1 id=\"使用个人独立域名\"><a href=\"#使用个人独立域名\" class=\"headerlink\" title=\"使用个人独立域名\"></a>使用个人独立域名</h1><p>经过上述的配置，我们的博客已经能够在公网访问，但是如果您还想需要自己的域名，而不是以<code>github.io</code>结尾的，比如我的域名为：<code>blog.ruanxinyu.cn</code>，那么您可以按照下面的说明进行配置。</p>\n<h2 id=\"配置域名解析DNS\"><a href=\"#配置域名解析DNS\" class=\"headerlink\" title=\"配置域名解析DNS\"></a>配置域名解析DNS</h2><p>首先您需要购买自己的域名，比如通过阿里云进行购买<a href=\"https://wanwang.aliyun.com/?spm=5176.8142029.388261.275.a7236d3earZNnp\" target=\"_blank\" rel=\"noopener\">https://wanwang.aliyun.com/?spm=5176.8142029.388261.275.a7236d3earZNnp</a>，该过程比较繁琐，需要认证。</p>\n<p>域名认证通过之后，需要在添在云解析DNS中加一项<code>CNAME</code>将你的独立域名指向你的GitHub Pages网址，如下图所示，</p>\n<blockquote>\n<p>其中<code>ruanxinyu.cn</code>是我购买的域名；<code>blog</code>是我为我的博客分配的二级域名，二级域名是自己随意指定的；<code>ruanxinyu.github.io</code>是我的GitHub Pages地址。</p>\n</blockquote>\n<img src=\"/posts/如何使用GitHubPages搭建个人博客/阿里云域名解析设置.png\" title=\"[阿里云域名解析设置]\">\n<h2 id=\"配置GitHub仓库\"><a href=\"#配置GitHub仓库\" class=\"headerlink\" title=\"配置GitHub仓库\"></a>配置GitHub仓库</h2><p>进入到你的GitHub Pages所在的代码仓库的配置中，将您的域名配置进去：<br><img src=\"/posts/如何使用GitHubPages搭建个人博客/GitHub配置域名设置入口.png\" title=\"[GitHub配置域名设置入口]\"><br><img src=\"/posts/如何使用GitHubPages搭建个人博客/GitHub配置域名.png\" title=\"[GitHub配置域名]\"></p>\n<p>到此，您就可以通过您的独立域名访问您的博客内容，比如我的：<a href=\"https://blog.ruanxinyu.cn\" target=\"_blank\" rel=\"noopener\">https://blog.ruanxinyu.cn</a></p>\n<blockquote>\n<p>还存在一个小问题，每次你通过<code>hexo deploy -g</code>将你的博客推送到你的GitHubPages的时候，域名配置就丢失了，为了解决此问题，我们可以在我的Hexo工程添加一个<code>source/CNAME</code>文件，在该文件中写入你的独立域名，比如<code>blog.ruanxinyu.cn</code>，这样每次推送，都会自动给您设置域名。</p>\n</blockquote>\n<h1 id=\"通过Git的子模块功能管理主题\"><a href=\"#通过Git的子模块功能管理主题\" class=\"headerlink\" title=\"通过Git的子模块功能管理主题\"></a>通过Git的子模块功能管理主题</h1><p>为什么要用Git的子模块功能呢？</p>\n<blockquote>\n<p>我们的博客代码是存在我们自己仓库中的，而主题是从别人的仓库中拉取的，并且我们会修改主题中的配置文件。如果我们将主题的内容全部存到我们的仓库中，那么如果主题的作者更新了内容，我们想同步下来就会很费劲。而Git的子模块功能就是为了解决这个问题的，允许你将一个Git仓库当作另外一个Git仓库的子目录，允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。</p>\n</blockquote>\n<h2 id=\"在华为DevCloud上建立私有代码仓\"><a href=\"#在华为DevCloud上建立私有代码仓\" class=\"headerlink\" title=\"在华为DevCloud上建立私有代码仓\"></a>在华为DevCloud上建立私有代码仓</h2><p>因为敏感信息问题，我不想将hexo工程源码放和主题的源码放在gitHub上，因此我在华为软件开发云上建立了两个私有仓库:</p>\n<p>一个用于存放我的hexo工程源码，地址为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/Blog.git</span><br></pre></td></tr></table></figure></p>\n<p>一个用于存放我修改后的indigo主题，该仓库是从indigo的官方仓库导入进来的, 如下图所示, 地址为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/hexo-theme-indigo.git</span><br></pre></td></tr></table></figure></p>\n<img src=\"/posts/如何使用GitHubPages搭建个人博客/华为云创建仓库.png\" title=\"[华为云创建仓库]\">\n<h2 id=\"如何添加Git的子模块功能\"><a href=\"#如何添加Git的子模块功能\" class=\"headerlink\" title=\"如何添加Git的子模块功能\"></a>如何添加Git的子模块功能</h2><p>在第一次使用的时候，需要先添加子模块功能：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule add -b card git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/hexo-theme-indigo.git themes/indigo</span><br></pre></td></tr></table></figure></p>\n<p>此时，会在你的代码目录下生成<code>.gitmodules</code>文件，该文件记录你的子模块信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[submodule &quot;themes/indigo&quot;]</span><br><span class=\"line\">truepath = themes/indigo</span><br><span class=\"line\">trueurl = git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/hexo-theme-indigo.git</span><br><span class=\"line\">truebranch = card</span><br></pre></td></tr></table></figure></p>\n<p>然后执行<code>git submodule init</code>和<code>git submodule update</code>命令将远端的代码同步下来。</p>\n<h2 id=\"如何修改indigo主题的内容\"><a href=\"#如何修改indigo主题的内容\" class=\"headerlink\" title=\"如何修改indigo主题的内容\"></a>如何修改indigo主题的内容</h2><p>我们根据自己的需要修改主题文件夹中的文件，然后推送至我们的私有仓库即可，可以参考如下命令：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd themes/indigo</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m '修改配置信息'</span><br><span class=\"line\">git push origin card</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"如何同步indigo主题官方仓库的更新\"><a href=\"#如何同步indigo主题官方仓库的更新\" class=\"headerlink\" title=\"如何同步indigo主题官方仓库的更新\"></a>如何同步indigo主题官方仓库的更新</h2><p>首先，我们将我们的仓库与官方的仓库进行一下关联，如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add office -t card https://github.com/yscoder/hexo-theme-indigo.git</span><br></pre></td></tr></table></figure></p>\n<p>之后通过<code>git pull office</code>即可将官方的仓库合并到本地。</p>\n<h2 id=\"如何修改Hexo工程代码的内容\"><a href=\"#如何修改Hexo工程代码的内容\" class=\"headerlink\" title=\"如何修改Hexo工程代码的内容\"></a>如何修改Hexo工程代码的内容</h2><p>Hexo工程就跟普通仓库一样维护即可，与子模块是相互独立的，当前两个仓库分开维护即可。Hexo工程代码并不会管理indigo主题的文件，而只是维护一个子模块的commit id。</p>\n<h2 id=\"克隆已经添加子模块功能的hexo工程\"><a href=\"#克隆已经添加子模块功能的hexo工程\" class=\"headerlink\" title=\"克隆已经添加子模块功能的hexo工程\"></a>克隆已经添加子模块功能的hexo工程</h2><p>使用子模块之后，克隆Hexo工程代码可以加上<code>--recursive</code>参数，将子模组的内容一起克隆下来，如果没有加该参数，则需要手动执行一下<code>git submodule update</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone --recursive git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/Blog.git</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"你可能会遇到的坑\"><a href=\"#你可能会遇到的坑\" class=\"headerlink\" title=\"你可能会遇到的坑\"></a>你可能会遇到的坑</h1><ol>\n<li><p>执行<code>hexo deploy</code>时报<code>error deployer not found:github</code>错误</p>\n<blockquote>\n<p>您没有安装安装<code>hexo-deployer-git</code>造成的，通过 <code>npm install hexo-deployer-git --save</code>进行安装</p>\n</blockquote>\n</li>\n<li><p>执行<code>hexo deploy</code>时报<code>Permission denied (publickey)</code>错误</p>\n<blockquote>\n<p>您的Github没有配置你的SSH key，配置方法参照上文的“配置GitHub Pages”章节</p>\n</blockquote>\n</li>\n<li><p>执行<code>hexo deploy</code>时报<code>fatal: could not read Username for &#39;https://github.com&#39;: Invalid argument</code>错误</p>\n<blockquote>\n<p>在GitHub上设置SSH Key，同时将配置文件<code>deploy</code>配置下的git地址改为<code>git@</code>开头的ssh地址，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:RuanXinyu/ruanxinyu.github.com.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>百度统计没有数据</p>\n<blockquote>\n<p>百度统计在初次添加后会有一定的延迟，可以手动检查是否添加成功，如下所示:</p>\n<img src=\"/posts/如何使用GitHubPages搭建个人博客/百度统计检查状态.png\" title=\"[百度统计检查状态]\">\n</blockquote>\n</li>\n<li><p>gitment初始化评论时出现<code>Error：validation failed</code></p>\n<blockquote>\n<p>这是由于你的网址超过50个字符导致的，解决方式请参照上文“配置评论功能”中的第5条</p>\n</blockquote>\n</li>\n</ol>\n","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/categories/环境搭建/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/tags/环境搭建/"}]},{"title":"JDK安装教程","slug":"JDK安装教程","date":"un00fin00","updated":"un22fin22","comments":true,"path":"posts/JDK安装教程/","link":"","permalink":"http://ruanxinyu.github.io/posts/JDK安装教程/","excerpt":"","keywords":"","text":"学习Java，首先得安装JDK(Java Development Kit)，那么下面就说一下如何在Windows和Linux下安装并验证JDK。 JDK的下载JDK的官方下载地址为： http://www.oracle.com/technetwork/java/javase/downloads/index.html， 请根据需要下载对应操作系统的安装包。 官方下载速度比较慢，因此可以从华为开源镜像站下载，地址为：https://mirrors.huaweicloud.com/repository/toolkit/java/jdk/ Windows下安装JDK 以jdk-8u151为例，双击上一步下载下来的exe文件，默认安装即可。（备注：路径可以选择其他盘符，但是不建议路径中包含中文及特殊字符） 进入到系统环境变量的管理界面：右键计算机图标=&gt;属性=&gt;高级系统设置=&gt;环境变量 新建变量JAVA_HOME，值为：C:\\Program Files\\Java\\jdk1.8.0_151 编辑变量PATH，追加：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 新建变量CLASSPATH，值为：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar Linux下安装JDK 以jdk-8u151为例，下载JDK后，将压缩包解压至特定的目录，一般解压至/usr/local目录，下载和解压命令可以参考如下命令： 123wget https://mirrors.huaweicloud.com/repository/toolkit/java/jdk/8u151-b12/jdk-8u151-linux-x64.tar.gzsudo tar -zxvf jdk-8u151-linux-x64.tar.gz -C /usr/local/sudo chown -R $(whoami):$(whoami) /usr/local/jdk1.8.0_151 经JDK的路径加入到环境变量中，在命令行中输入sudo vim /etc/profile，编辑文件，在文件末尾增加如下的内容，然后执行source /etc/profile使环境变量生效。 1234export JAVA_HOME=/usr/local/jdk1.8.0_151export JRE_HOME=/usr/local/jdk1.8.0_151/jreexport CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin JDK的验证windows打开CMD命令窗口，Linux打开终端端口，输入java -version命令，如果出现如下提示则Java安装成功。","raw":"---\ntitle: JDK安装教程\ndate: 2018-04-15 14:53:32\ntags: \n- 环境搭建\n- Java\ncategories: \n- 环境搭建\n---\n\n学习Java，首先得安装JDK(Java Development Kit)，那么下面就说一下如何在Windows和Linux下安装并验证JDK。\n\n# JDK的下载\nJDK的官方下载地址为： http://www.oracle.com/technetwork/java/javase/downloads/index.html， 请根据需要下载对应操作系统的安装包。\n> 官方下载速度比较慢，因此可以从华为开源镜像站下载，地址为：https://mirrors.huaweicloud.com/repository/toolkit/java/jdk/\n\n# Windows下安装JDK\n1. 以`jdk-8u151`为例，双击上一步下载下来的exe文件，默认安装即可。（备注：路径可以选择其他盘符，但是不建议路径中包含中文及特殊字符）\n2. 进入到系统环境变量的管理界面：`右键计算机图标=>属性=>高级系统设置=>环境变量`\n{% asset_img windows_install_01.png [设置Windows环境变量] %}\n3. `新建`变量`JAVA_HOME`，值为：`C:\\Program Files\\Java\\jdk1.8.0_151`\n4. `编辑`变量`PATH`，追加：`%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;`\n5. `新建`变量`CLASSPATH`，值为：`.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar`\n{% asset_img windows_install_02.png [设置Windows环境变量] %}\n\n# Linux下安装JDK\n1. 以`jdk-8u151`为例，下载JDK后，将压缩包解压至特定的目录，一般解压至/usr/local目录，下载和解压命令可以参考如下命令：\n```shell\nwget https://mirrors.huaweicloud.com/repository/toolkit/java/jdk/8u151-b12/jdk-8u151-linux-x64.tar.gz\nsudo tar -zxvf jdk-8u151-linux-x64.tar.gz -C /usr/local/\nsudo chown -R $(whoami):$(whoami) /usr/local/jdk1.8.0_151\n```\n\n2. 经JDK的路径加入到环境变量中，在命令行中输入`sudo vim /etc/profile`，编辑文件，在文件末尾增加如下的内容，然后执行`source /etc/profile`使环境变量生效。\n```shell\nexport JAVA_HOME=/usr/local/jdk1.8.0_151\nexport JRE_HOME=/usr/local/jdk1.8.0_151/jre\nexport CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib\nexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin\n```\n\n# JDK的验证\nwindows打开`CMD`命令窗口，Linux打开终端端口，输入`java -version`命令，如果出现如下提示则Java安装成功。\n{% asset_img java_version.png [Java的验证] %}\n\n\n","content":"<p>学习Java，首先得安装JDK(Java Development Kit)，那么下面就说一下如何在Windows和Linux下安装并验证JDK。</p>\n<h1 id=\"JDK的下载\"><a href=\"#JDK的下载\" class=\"headerlink\" title=\"JDK的下载\"></a>JDK的下载</h1><p>JDK的官方下载地址为： <a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index.html，\" target=\"_blank\" rel=\"noopener\">http://www.oracle.com/technetwork/java/javase/downloads/index.html，</a> 请根据需要下载对应操作系统的安装包。</p>\n<blockquote>\n<p>官方下载速度比较慢，因此可以从华为开源镜像站下载，地址为：<a href=\"https://mirrors.huaweicloud.com/repository/toolkit/java/jdk/\" target=\"_blank\" rel=\"noopener\">https://mirrors.huaweicloud.com/repository/toolkit/java/jdk/</a></p>\n</blockquote>\n<h1 id=\"Windows下安装JDK\"><a href=\"#Windows下安装JDK\" class=\"headerlink\" title=\"Windows下安装JDK\"></a>Windows下安装JDK</h1><ol>\n<li>以<code>jdk-8u151</code>为例，双击上一步下载下来的exe文件，默认安装即可。（备注：路径可以选择其他盘符，但是不建议路径中包含中文及特殊字符）</li>\n<li>进入到系统环境变量的管理界面：<code>右键计算机图标=&gt;属性=&gt;高级系统设置=&gt;环境变量</code><img src=\"/posts/JDK安装教程/windows_install_01.png\" title=\"[设置Windows环境变量]\"></li>\n<li><code>新建</code>变量<code>JAVA_HOME</code>，值为：<code>C:\\Program Files\\Java\\jdk1.8.0_151</code></li>\n<li><code>编辑</code>变量<code>PATH</code>，追加：<code>%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;</code></li>\n<li><code>新建</code>变量<code>CLASSPATH</code>，值为：<code>.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar</code><img src=\"/posts/JDK安装教程/windows_install_02.png\" title=\"[设置Windows环境变量]\">\n</li>\n</ol>\n<h1 id=\"Linux下安装JDK\"><a href=\"#Linux下安装JDK\" class=\"headerlink\" title=\"Linux下安装JDK\"></a>Linux下安装JDK</h1><ol>\n<li><p>以<code>jdk-8u151</code>为例，下载JDK后，将压缩包解压至特定的目录，一般解压至/usr/local目录，下载和解压命令可以参考如下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://mirrors.huaweicloud.com/repository/toolkit/java/jdk/8u151-b12/jdk-8u151-linux-x64.tar.gz</span><br><span class=\"line\">sudo tar -zxvf jdk-8u151-linux-x64.tar.gz -C /usr/local/</span><br><span class=\"line\">sudo chown -R $(whoami):$(whoami) /usr/local/jdk1.8.0_151</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>经JDK的路径加入到环境变量中，在命令行中输入<code>sudo vim /etc/profile</code>，编辑文件，在文件末尾增加如下的内容，然后执行<code>source /etc/profile</code>使环境变量生效。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=/usr/local/jdk1.8.0_151</span><br><span class=\"line\">export JRE_HOME=/usr/local/jdk1.8.0_151/jre</span><br><span class=\"line\">export CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class=\"line\">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"JDK的验证\"><a href=\"#JDK的验证\" class=\"headerlink\" title=\"JDK的验证\"></a>JDK的验证</h1><p>windows打开<code>CMD</code>命令窗口，Linux打开终端端口，输入<code>java -version</code>命令，如果出现如下提示则Java安装成功。<br><img src=\"/posts/JDK安装教程/java_version.png\" title=\"[Java的验证]\"></p>\n","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/categories/环境搭建/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/tags/环境搭建/"},{"name":"Java","slug":"Java","permalink":"http://ruanxinyu.github.io/tags/Java/"}]}]}