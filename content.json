[{"title":"Ubuntu下HAProxy的安装与配置","date":"2018-09-24T23:07:50.000Z","path":"2018/09/25/Ubuntu下HAProxy的安装与配置/","text":"HAProxy的简介HAProxy是一款提供高可用性、负载均衡以及基于TCP（第四层）和HTTP（第七层）应用的代理软件，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。 HAProxy实现了一种事件驱动、单一进程模型，此模型支持非常大的并发连接数，特别适用于那些负载特大的web站点，完全可以支持数以万计的并发连接，根据官方文档，haproxy可以跑满10Gbps。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中，同时可以保护你的web服务器不被暴露到网络上。 HAProxy支持全透明代理，可以用客户端IP地址或者任何其他地址来连接后端服务器，同时提供连接拒绝功能，可以有效的限制攻击蠕虫。 HAProxy的安装该教程使用的Ubuntu版本是18.04.1版本，Ubuntu的安装教程参考VirtualBox安装Ubuntu教程。HAProxy可以直接通过apt-get安装，也可以通过源码编译安装。 apt-get安装Ubuntu下执行sudo apt-get install haproxy命令即可安装。 通过which haproxy可以看到KeepAlived是安装在/usr/sbin/haproxy下，HAProxy的配置文件路径为：/etc/haproxy/haproxy.cfg 使用sudo haproxy -f /etc/haproxy/haproxy.cfg即可启动HAProxy。 源码编译安装一般源码安装目录为/usr/local/haproxy，在源码目录中的README文件有安装说明，下面罗列出几点内容： 在执行make命令之前是不需要执行./configure命令的，因此执行的参数都在make命令中指定 我们操作系统为Ubuntu 18.04.1，不涉及嵌入式编译，因此使用TARGET=linux26 ARCH=x86_64参数 PCRE(Perl Compatible Regular Expressions)的速度是其他的2-10倍，因此添加USE_PCRE=1选项，但是前提需要安装libpcre3 libpcre3-dev 为支持HTTPS协议，我们需要添加USE_OPENSSL=1选项，但是前提需要安装libssl-dev 为支持HTTP的压缩功能，我们需要添加USE_ZLIB=1，但是前提需要安装zlib1g-dev 为了保证安装目录为/usr/local/haproxy，我们需要在make install命令中指定PREFIX参数 12345678sudo apt-get install build-essential libssl-dev # 安装编译工具和openssl依赖sudo apt-get install zlib1g-devsudo apt-get install libpcre3 libpcre3-devwget https://www.haproxy.org/download/1.8/src/haproxy-1.8.8.tar.gz # 下载源码tar -zxvf haproxy-1.8.8.tar.gz # 解压源码cd haproxy-1.8.8/make TARGET=linux26 ARCH=x86_64 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 # 编译源码，从README中可以看出如何编译sudo make install PREFIX=/usr/local/haproxy # 安装到安装目录，需要使用root权限 启动HAProxy: sudo /usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg 可能遇到的问题 提示make is not found 源码安装需要安装编译器将源码转换为二进制可执行文件，因此执行sudo apt-get install build-essential安装编译器即可 启动时提示parsing [/etc/haproxy/haproxy.cfg:12] : unknown keyword &#39;ca-base&#39; in &#39;global&#39; section 编译haproxy时没有使能openssl的支持，安装libssl-dev并在编译时指定USE_OPENSSL=1选项即可 HAProxy的配置 由于HAProxy一般需要是高可用的，因此常常与KeepAlived联合使用，由KeepAlived自动启动HAProxy，因此一般不将HAProxy添加到守护进程和开机启动中。 下面我们以一个最简单的用例说明如何配置HAProxy，架构图如下，192.168.1.102上安装有HAProxy, 8081端口转向192.168.1.106服务器，8082端口转向192.168.1.107服务器。因为HAProxy是提供有统计功能的，因此打开该功能，并监听在8083端口。 配置HAProxy编辑sudo vim /etc/haproxy/haproxy.cfg文件，写入如下的内容： 1234567891011121314151617181920212223242526272829global daemon # 配置为后台启动defaults mode http timeout connect 30s # 连接超时 timeout client 30s # 客户端超时 timeout server 30s # 服务器超时###########################################################frontend app01 bind *:8081 # 绑定端口 default_backend app01_backend # 默认的backend的名称backend app01_backend server web1 192.168.1.106:80 # 设置后端服务器###########################################################frontend app02 bind *:8082 # 绑定端口 default_backend app02_backend # 默认的backend的名称backend app02_backend server web1 192.168.1.107:80 # 设置后端服务器###########################################################listen stats bind *:8083 # 设置监控组的名称 stats refresh 30s # 统计页面自动刷新时间 stats uri /stats # 统计页面url 然后执行sudo /usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg启动HAProxy，通过sudo netstat -lntp | grep haproxy，可以看出HAProxy已经监听配置文件中的三个端口： 可能遇到的问题 启动时提示unknown keyword，如下所示： 从错误信息中可以看出keyword前都多了好多空格，说明我们的配置文件没有正确的使用tab键 启动HAProxy后配置文件没有生效 因为之前启动的HAProxy进程没有关闭，可以先通过ps -ef | grep haproxy找到进程的ID，然后执行kill命令，如下所示 搭建Apache服务器我们使用Apache服务器来模拟HAProxy后端的服务器，首先分别在192.168.1.106和192.168.1.107两台机器上执行sudo apt-get install apache2，完成后就会Apache会自动启动并监听80端口，此时在浏览器中访问对应机器，既可以看到Apache2的首页，默认使用的首页为/var/www/html/index.html。 为了对两台机器做一下区分，我们做如下操作： 在192.168.1.106执行sudo sh -c &#39;echo &quot;This is apache server 01&quot; &gt; /var/www/html/index.html&#39; 在192.168.1.107执行sudo sh -c &#39;echo &quot;This is apache server 02&quot; &gt; /var/www/html/index.html&#39; 此时分别访问http://192.168.1.106/和http://192.168.1.107/可以看到下面的界面： HAProxy的验证此时访问HAProxy（192.168.1.102）的8081和8082可以看到分别访问到后端的192.168.1.106和192.168.1.107的80端口，如下所示，说明HAProxy的功能已经生效。 访问HAProxy的8083端口：http://192.168.1.102:8083/stats，可以看到HAProxy自带的的统计数据页面，如下所示：","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/tags/环境搭建/"}]},{"title":"Linux初始化init系统：Sysvinit、Upstart和Systemd","date":"2018-09-22T07:04:38.000Z","path":"2018/09/22/Linux初始化init系统/","text":"init系统介绍Linux操作系统的启动首先从BIOS开始，接下来进入bootloader，由bootloader载入内核，进行内核初始化。内核初始化的最后一步就是启动pid为1的init进程。init以守护进程方式存在，是系统的第一个进程,，是所有其他进程的祖先。 Init系统能够定义、管理和控制 init进程的行为。它负责组织和运行许多独立的或相关的始化工作(因此被称为init系统)，从而让计算机系统进入某种用户预订的运行模式。 Linux初始化init系统包括：Sysvinit、Upstart和Systemd，它们在Ubuntu系统下的演化如下： Ubuntu 6.10及以前版本使用Sysvinit。 Ubuntu 14.10及以前版本使用Upstart，通过与Sysvinit并存。 Ubuntu 15.04开始默认使用Systemd，不能与Sysvinit或Upstart并存 Sysvinit介绍 Sysvinit就是System V风格的init系统，顾名思义，它源于System V系列UNIX。 运行级别Sysvinit用术语runlevel来定义”预订的运行模式”，默认的运行模式定义在/etc/inittab文件的initdefault项。如果没有默认的运行模式，那么用户将进入系统控制台，手动决定进入何种运行模式。 Sysvinit中运行模式描述了系统各种预订的运行模式。通常会有8种运行模式，即运行模式0-6和S。其中0表示关机，1表示单用户模式，3为命令行模式，5为GUI模式，6表示重启，1和S等往往用于系统故障之后的排错和恢复。可以看出每一种运行模式所作的初始化工作是不一样的。 Sysvinit执行顺序 /etc/rc.d/rc.sysinit /etc/rc.d/rc 和/etc/rc.d/rcX.d/ (X 代表运行级别 0-6) /etc/rc.d/rc.local X Display Manager（可选） 首先，运行rc.sysinit以便执行一些重要的系统初始化任务。 然后，Sysvinit开始运行/etc/rc.d/rc脚本。根据不同的runlevel，rc脚本将执行/etc/rc.d/rcX.d(X就是runlevel)目录下的所有启动脚本。当所有的初始化脚本执行完毕。该目录下有多个脚本，为了保证系统正常关闭，脚本是要按照顺序执行的在该目录下所有以K开头的脚本都将在关闭系统时调用，字母K之后的数字定义了它们的执行顺序。 然后，Sysvinit运行/etc/rc.d/rc.local脚本。rc.local是Linux 留给用户进行个性化设置的地方。 Sysvinit优缺点Sysvinit的优点： 是概念简单，开发人员只需要编写启动和停止脚本，概念非常清楚 确定的执行顺序，脚本严格按照启动数字的大小顺序执行，一个执行完毕再执行下一个，这非常有益于错误排查 Sysvinit的缺点： 串行地执行脚本导致Sysvinit运行效率较慢 对动态设备加载等Linux新特性支持不友好 Upstart介绍开发UpStart的缘由当Linux内核进入2.6时代时，系统支持热插拔功能，一旦新外设连接到系统，内核便可以自动实时地发现它们，并初始化这些设备，进而使用它们。这为便携式设备用户提供了很大的灵活性。 Sysvinit启动时必须一次性把所有可能用到的服务都启动起来，即使该设备没有连接，因此会造成浪费，比如为了管理打印任务，系统需要启动CUPS等服务。 UpStart基于事件机制，比如U盘插入USB接口后，udev得到内核通知，发现该设备，这就是一个新的事件。UpStart在感知到该事件之后触发相应的等待任务，比如处理/etc/fstab 中存在的挂载点。采用这种事件驱动的模式，upstart 完美地解决了即插即用设备带来的新问题。 UpStart相对于Sysvinit具有如下的优势： 更快地启动系统 当新硬件被发现时动态启动服务 硬件被拔除时动态停止服务 UpStart的原理Upstart的基本概念和设计清晰明确。UpStart主要的概念是job和event。Job就是一个工作单元，用来完成一件工作，比如启动一个后台服务，或者运行一个配置命令。每个Job都等待一个或多个事件，一旦事件发生，upstart就触发该 job 完成相应的工作。 Job包括包括TaskJob，SeriveJob和AbstractJob。其中SeriveJob代表后台服务进程，一旦开始运行就成为一个后台进程，由init进程管理。 事件是个非常抽象的概念，下面我罗列出一些常见的事件，希望可以帮助您进一步了解事件的含义： 系统上电启动，init 进程会发送”start”事件 根文件系统可写时，相应 job 会发送文件系统就绪的事件 一个块设备被发现并初始化完成，发送相应的事件 某个文件系统被挂载，发送相应的事件 类似 atd 和 cron，可以在某个时间点，或者周期的时间点发送事件 另外一个 job 开始或结束时，发送相应的事件 一个磁盘文件被修改时，可以发出相应的事件 一个网络设备被发现时，可以发出相应的事件 缺省路由被添加或删除时，可以发出相应的事件 系统初始化的过程是在工作和事件的相互协作下完成的，可以大致描述如下: 系统初始化时，init 进程开始运行，init 进程自身会发出不同的事件，这些最初的事件会触发一些工作运行。每个工作运行过程中会释放不同的事件，这些事件又将触发新的工作运行。如此反复，直到整个系统正常运行起来。 UpStart是兼容SysvInit的runlevel的，通过触发执行/etc/init/rc.conf来执行/etc/rc$.d/目录下的所有脚本。 Systemd介绍Systemd提供了和Sysvinit以及LSBinitscripts兼容的特性。系统中已经存在的服务和进程无需修改。这降低了系统向systemd 迁移的成本，使得Systemd替换现有初始化系统成为可能。 Systemd的启动速度更快，提供了比UpStart更激进的并行启动能力，采用了socket/D-Bus Activation等技术启动服务，提供按需启动的能力，只有在某个服务被真正请求的时候才启动它，当该服务结束，systemd 可以关闭它，等待下次需要时再次启动它。 Systemd还提供如下等特性: 和init比起来引导过程简化了很多 Systemd支持并发引导过程从而可以更快启动 通过控制组来追踪进程，而不是PID 优化了处理引导过程和服务之间依赖的方式 支持系统快照和恢复 监控已启动的服务；也支持重启已崩溃服务 包含了systemd-login模块用于控制用户登录 支持加载和卸载组件 低内存使用痕迹以及任务调度能力 记录事件的Journald模块和记录系统日志的syslogd模块 Systemd的单元概念系统初始化需要执行的任务非常多。每一个任务都被Systemd 抽象为一个配置单元，即unit。当前单元类型如下： service：代表一个后台服务进程，比如 mysqld。这是最常用的一类。 socket：此类配置单元封装系统和互联网中的一个 套接字 。当下，systemd 支持流式、数据报和连续包的 AF_INET、AF_INET6、AF_UNIX socket 。每一个套接字配置单元都有一个相应的服务配置单元 。相应的服务在第一个”连接”进入套接字时就会启动(例如：nscd.socket 在有新连接后便启动 nscd.service)。 device：此类配置单元封装一个存在于 Linux 设备树中的设备。每一个使用 udev 规则标记的设备都将会在 systemd 中作为一个设备配置单元出现。 mount：此类配置单元封装文件系统结构层次中的一个挂载点。Systemd 将对这个挂载点进行监控和管理。比如可以在启动时自动将其挂载；可以在某些条件下自动卸载。Systemd 会将/etc/fstab 中的条目都转换为挂载点，并在开机时处理。 automount：此类配置单元封装系统结构层次中的一个自挂载点。每一个自挂载配置单元对应一个挂载配置单元 ，当该自动挂载点被访问时，systemd 执行挂载点中定义的挂载行为。 swap: 和挂载配置单元类似，交换配置单元用来管理交换分区。用户可以用交换配置单元来定义系统中的交换分区，可以让这些交换分区在启动时被激活。 target：此类配置单元为其他配置单元进行逻辑分组。它们本身实际上并不做什么，只是引用其他配置单元而已。这样便可以对配置单元做一个统一的控制。这样就可以实现大家都已经非常熟悉的运行级别概念。比如想让系统进入图形化模式，需要运行许多服务和配置命令，这些操作都由一个个的配置单元表示，将所有这些配置单元组合为一个目标(target)，就表示需要将这些配置单元全部执行一遍以便进入目标所代表的系统运行状态。 (例如：multi-user.target 相当于在传统使用 SysV 的系统中运行级别 5) timer：定时器配置单元用来定时触发用户定义的操作，这类配置单元取代了 atd、crond 等传统的定时服务。 snapshot：与 target 配置单元相似，快照是一组配置单元。它保存了系统当前的运行状态。 Systemd的Target和运行级别systemd使用目标（target）替代了运行级别的概念，提供了更大的灵活性，如您可以继承一个已有的目标，并添加其它服务，来创建自己的目标。通过target文件夹的命令也可以看出对应的runlevel： Sysvinit运行级别 Systemd目标 备注 0 poweroff.target 关闭系统 1,s rescue.target 单用户模式 2,4 multi-user.target 多用户，非图形化 3 multi-user.target 多用户，非图形化 5 graphical.target 多用户，图形化 6 reboot.target 重启 使用C/C++开发新的系统服务使用C/C++开发新的系统服务可能需要关注如下的内容： 后台服务进程代码不需要执行两次派生来实现后台精灵进程，只需要实现服务本身的主循环即可。 不要调用 setsid()，交给 systemd 处理 不再需要维护 pid 文件。 Systemd 提供了日志功能，服务进程只需要输出到 stderr 即可，无需使用 syslog。 处理信号 SIGTERM，这个信号的唯一正确作用就是停止当前服务，不要做其他的事情。 SIGHUP 信号的作用是重启服务。 需要套接字的服务，不要自己创建套接字，让 systemd 传入套接字。 使用 sd_notify()函数通知 systemd 服务自己的状态改变。一般地，当服务初始化结束，进入服务就绪状态时，可以调用它。 Unit文件的编写服务配置单元文件以.service为文件名后缀，默认时存放在/lib/systemd/system/目录下，然后链接到/etc/systemd/system/对应的目录下。下面以sshd的为例/etc/system/system/sshd.service： 123456789101112[Unit]Description=OpenSSH server daemon[Service]EnvironmentFile=/etc/sysconfig/sshd #设置环境变量ExecStartPre=/usr/sbin/sshd-keygenExecStart=/usrsbin/sshd –D $OPTIONSExecReload=/bin/kill –HUP $MAINPIDKillMode=processRestart=on-failureRestartSec=42s[Install]WantedBy=multi-user.target #系统以该形式运行时，服务方可启动 文件分为三个小节，其中[Unit]段和[Install]段是所有Unit文件通用的，用于配置服务的描述、依赖和随系统启动方式，而[Service]断则是服务类型的Unit文件（后缀为.service)特有的，用于定义服务的具体管理和操作方法。 在/etc/systemd/system 目录下还可以看到诸如*.wants 的目录，放在该目录下的配置单元文件等同于在[Unit]小节中的 wants关键字，即本单元启动时，还需要启动这些单元。比如您可以简单地把您自己写的 foo.service 文件放入 multi-user.target.wants 目录下，这样每次都会被默认启动了。 [Unit]参数 Description： 一段描述这个Unit文件的文字，通常只是简短的一句话。 Documentation：指定服务的文档，可以是一个或多个文档的URL路径。 Requires：依赖的其他Unit列表，列在其中的Unit模块会在这个服务启动的同时被启动。 Wants：与Requires相似，但只是在被配置的这个Unit启动时，触发启动列出的每个Unit模块，而不去考虑这些模块启动时候是否成功。 After：与Requires相似，但是在后面列出的所有模块启动完成以后，才会启动当前的服务。与Requires不同的是，After不会因为依赖程序在运行过程中停止运行，导致当前服务也停止。 Before：与After相反，在启动指定的任意一个模块之前，都会首先确保当前服务已经运行。 BindsTo：与Requires非常相似，但是一种更强的关联。启动这个服务时会同时启动列出的所有模块，当有模块启动失败时终止当前服务。反之，只要列出的模块全部启动以后，就会自动启动当前服务。并且，这些模块中有任意一个出现意外结束或重启，这个服务会跟着终止或重启。 PartOf：这是一个BindsTo作用的子集，仅在列出的任何模块失败或重启时，终止或重启当前服务，而不会随列出模块的启动而启动。 OnFailure：当这个模块启动失败时，就自动启动列出的每个模块。 Conflicts：与这个模块有冲突的模块，如果列出的模块中有已经在运行的，则会将已启动的冲突模块停止，并启动当前模块；反过来，冲突模块启动时会把当前模块停止。 上面的这些配置，除了Description外，其他都可以被添加多次。比如After参数，可以使用多个After参数，也可以在一行内使用空格分割，写多个依赖模块。 [install]参数 WantedBy：和前面Wants作用相似，但此处表示当前模块被依赖。 RequiredBy：和前面的Requires作用相似，但此处表示当前模块被依赖。 Also：当这个服务被enable/disable时，将自动enable/disable后面列出的每个模块。 [service]参数服务生命周期控制相关的参数 Type：服务的类型，常用的有simple（默认类型）和forking，默认的simple类型可以适用于绝大多数场景，因此一般可以忽略者这个参数的配置。对于服务进程启动后通过fork系统调用创建子进程，然后关闭应用程序本身进程的情况，则应该将Type的值设置为forking；否则Systemd将不会跟踪子进程的行为，而认为服务已经退出。 RemainAfterExit：指为true或false（也可以写yes或no），默认为false。当配置为true时，Systemd只会负责启动服务进程，之后即便服务进程退出了，Systemd也仍然会认为这个服务还在运行中。这个配置主要是提供给一些并非常驻内存，而是启动注册后立即退出，然后等待消息按需启动的特殊类型服务使用的。 ExecStart：这个参数是几乎每个“.service”文件都会有的，指定服务启动的主要命令，在每个配置文件中只能使用一次. ExecStartPre：指定在启动执行ExecStart命令前的准备工作，在同一个配置文件中可以有多个，所有命令会按照文件中书写的顺序依次被执行。 ExecStartPost：指定在启动执行ExecStart命令后的收尾工作，在同一个配置文件中也可有多个。 TimeoutSec：快速设置TimeoutStartSec和TimeoutStopSec参数成指定值。（另外，关于默认时间设定都在systemd配置文件中的DefaultTimeoutStartSec、DefaultTimeoutStopSec和DefaultRestartSec字段进行配置，如果这些字段缺省，DefaultTimeoutStartSec和DefaultTimeoutStopSec的默认指为90s，DefaultRestartSec默认为100ms） TimeoutStartSec：启动服务时的等待秒数，如果超出这个时间服务仍然没有执行完所有的启动命令，则Systemd会认为服务自动失败。这一配置对于使用Docker容器托管的应用十分重要。由于Docker第一次运行时可能会需要从网络上下载服务的镜像文件，因此造成比较严重的延时，容易被Systemd误判断为启动失败而杀死。通常，对于这种服务，需要将TimeoutStartSec设置为0，关闭超时检测。 ExecStop：停止服务所需要执行的主要命令，在每个配置文件中只能够有一个。 ExecStopPost：指定在ExecStop命令执行后的收尾工作，在同一配置文件中可以有多个。 TimeoutStopSec：停止服务时的等待秒数，如果超过这个时间服务仍然没有停止，Systemd会使用SIGKILL信号强行干掉服务进程。 Restart：这个值用于指定在什么情况下需要重启服务进程。常用的值有：no、no-success、on-failure、on-abnormal、on-abort和always。默认值为no，即不会自动重启服务。这些不同的值分别表示在哪些情况下，服务会重新启动。 RestartSec：如果服务需要被重启，这个参数的值为服务被重启前的等待秒数。默认为100ms。 ExecReload：重新加载服务所需执行的主要命令。 服务上下文配置相关的参数 Environment：为服务添加环境变量，格式直接为Environment=“foo=bar”（看了一下Systemd的手册，这个参数所接受的格式有些奇葩，建议是直接“foo=bar”，取的时候使用${foo}进行获取） EnvironmentFile：指定加载一个包含服务所需的环境变量列表的文件，文件中的每一行都是一个环境变量的定义。顺便提一下，建议使用的时候将=换成=-，如EnvironmentFile=-/etc/my.env，和=的区别是，使用=-时，假如/etc/my.env文件不在也不会报错。 Nice：服务的进程优先级，指越小优先级越高，默认为0，。其中-20为最高优先级，19为最低优先级。 WorkingDirectory：指定当前服务的工作目录。 RootDirectory：指定当前服务进程的根目录（/目录）。如果配置了这个参数，服务将无法访问指定目录外的任何文件。 User：指定运行服务的用户，会影响服务对本地文件系统的访问权限。 Group：指定运行服务的用户组，会影响服务对本地文件系统的访问权限。 MountFlags：这个值其实是服务的Mount Namespace的配置，会影响服务进程上下文中挂载点的信息，即服务是否会继承主机上已有的挂载点，以及如果服务运行时执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为shared、slave和private，具体作用如下表所示： LimitCPU/LimitSTACK/LimitNOFILE/LimitNPROC等：限定服务可用的系统资源量，CPU、程序堆栈、文件句柄数量、子进程数量等 Systemd命令行工具的使用systemd 的主要命令行工具是systemctl，可以替换service、chkconfig以及telinit命令的使用。 Systemd命令和sysvinit命令的对照表 Sysvinit命令 Systemd命令 备注 service foo start systemctl start foo.service 用来启动一个服务 (并不会重启现有的) service foo stop systemctl stop foo.service 用来停止一个服务 (并不会重启现有的) service foo restart systemctl restart foo.service 用来停止并启动一个服务 service foo reload systemctl reload foo.service 当支持时，重新装载配置文件而不中断等待操作 service foo condrestart systemctl condrestart foo.service 如果服务正在运行那么重启它 service foo status systemctl status foo.service 汇报服务是否正在运行 ls /etc/rc.d/init.d/ systemctl list-unit-files –type=service 用来列出可以启动或停止的服务列表 chkconfig foo on systemctl enable foo.service 在下次启动时或满足其他触发条件时设置服务为启用 chkconfig foo off systemctl disable foo.service 在下次启动时或满足其他触发条件时设置服务为禁用 chkconfig foo systemctl is-enabled foo.service 用来检查一个服务在当前环境下被配置为启用还是禁用 chkconfig –list systemctl list-unit-files –type=service 输出在各个运行级别下服务的启用和禁用情况 chkconfig foo –list ls /etc/systemd/system/*.wants/foo.service 用来列出该服务在哪些运行级别下启用和禁用 chkconfig foo –add systemctl daemon-reload 当您创建新服务文件或者变更设置时使用 telinit 3 systemctl isolate multi-user.target (OR systemctl isolate runlevel3.target OR telinit 3) 改变至多用户运行级别 systemd电源管理命令 命令 操作 systemctl reboot 重启机器 systemctl poweroff 关机 systemctl suspend 待机 systemctl hibernate 休眠 systemctl hybrid-sleep 混合休眠模式（同时休眠到硬盘并待机）","tags":[{"name":"Linux","slug":"Linux","permalink":"http://ruanxinyu.github.io/tags/Linux/"}]},{"title":"Ubuntu下KeepAlived的安装与配置","date":"2018-09-18T12:42:46.000Z","path":"2018/09/18/Ubuntu下KeepAlived的安装与配置/","text":"KeepAlived介绍Keepalived是一个基于VRRP协议来实现的服务高可用方案，可以利用其来避免IP单点故障，一般与其它负载均衡技术（如lvs、haproxy、nginx）一起工作来达到集群的高可用。 健康检查和失败切换是keepalived的两大核心功能。 keepalived的健康检查支持tcp三次握手、icmp请求、http请求、udp和echo请求等方式对负载均衡器后面的实际的服务器)进行保活，具体采用哪种检查方式可以根据自己的业务需要进行选择； 失败切换主要是应用于配置了主备模式的负载均衡器， 由VRRP(虚拟路由冗余协议）协议实现，对外提供一个VIP（虚拟IP），VIP在其中master机器上，当该机器出现故障时，VIP会自动漂移到slave的机器上，从而保证对外的功能是正常的。如果mastr机器功能正常之后，会自动加入到服务器集群中，无需人工干预，只需要人工做修复故障的服务器。 VRRP协议介绍VRRP（虚拟路由协议，virtual redundant routing protocol)是为消除网络设备单点故障而设计的主备模式的协议，使得在发生故障时，可以在不影响内外数据通信，不修改内部网络的网络参数的情况下切换设备。 VRRP协议通过配置虚拟路由ID(VRID)来将两台或多台设备虚拟成一个虚拟设备，对外提供一个或多个虚拟IP(VIP)和虚拟的MAC地址（VMC），通过该VIP和VMC对外提供服务，可以保证在设备切换时网络参数不变。所以当VIP在哪一台设备上，则该设备为master节点对外提供服务，其他的节点为backup节点不实际对外提供服务。 VRRP协议通过心跳算法自动选举哪个节点为master节点，默认使用多播数据来传输VRRP数据。通过配置文件可以指定每个设备的优先级，所以在初始状态时，优先级最大的为master节点。VRRP运行时只有MASTER路由器定时发送VRRP通告信息，表示master工作正常，backup只接收VRRP数据，不发送数据，如果一定时间内没有接收到master的通告信息，各backup将宣告自己成为master，发送通告信息，重新进行master选举状态。 KeepAlived的安装该教程使用的Ubuntu版本是18.04.1版本，Ubuntu的安装教程参考VirtualBox安装Ubuntu教程。KeepAlived可以直接通过apt-get安装，也可以通过源码编译安装。 apt-get安装Ubuntu下执行sudo apt-get install keepalived命令即可安装。 通过which keepalived可以看到KeepAlived是安装在/usr/sbin/keepalived下。 使用sudo service keepalived start即可启动KeepAlived。 源码编译安装首先安装编译工具和openssl，下载KeepAlived源码并解压，然后执行源码编译三件套（./configure &amp;&amp; make &amp;&amp; make install），我们安装的目录为/usr/local/keepalived： 1234567sudo apt-get install build-essential libssl-dev # 安装编译工具和openssl依赖wget http://www.keepalived.org/software/keepalived-2.0.7.tar.gz # 下载源码tar -zxvf keepalived-2.0.7.tar.gz # 解压源码cd keepalived-2.0.7/./configure --prefix=/usr/local/keepalived # 配置keepalived的安装目录make # 编译源码sudo make install # 安装到安装目录，需要使用root权限 可能遇到的问题 执行./configure时提示g++ is not found 源码安装需要安装编译器将源码转换为二进制可执行文件，因此执行sudo apt-get install build-essential安装编译器即可 执行./configure时提示OpenSSL is not properly installed on your system 你的系统没有安装openssl，执行sudo apt-get install libssl-dev即可 KeepAlive的配置守护进程和开机启动由于Ubunt 18.04.1默认使用Systemd作为init程序，因此设置守护进程也采用该方式，了解详细请参考Linux初始化init系统：Sysvinit、Upstart和Systemd 首先，创建相关文件的链接： 1234sudo mkdir -p /etc/keepalivedsudo ln -s /usr/local/keepalived/sbin/keepalived /usr/sbin/sudo ln -s /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/keepalived.confsudo ln -s /usr/local/keepalived/etc/sysconfig/keepalived /etc/default/keepalived 编辑文件，sudo vim /lib/systemd/system/keepalived.service文件，写入如下的内容，然后执行sudo ln -s /lib/systemd/system/keepalived.service /etc/systemd/system/multi-user.target.wants/keepalived.service 1234567891011121314151617[Unit]Description=Keepalive Daemon (LVS and VRRP)After=syslog.target network-online.targetWants=network-online.target# Only start if there is a configuration fileConditionFileNotEmpty=/etc/keepalived/keepalived.conf[Service]Type=forkingKillMode=process# Read configuration variable file if it is presentEnvironmentFile=-/etc/default/keepalivedExecStart=/usr/sbin/keepalived $KEEPALIVED_OPTIONSExecReload=/bin/kill -HUP $MAINPID[Install]WantedBy=multi-user.target 启动keepalived进程，并设置为开机启动，通过sudo systemctl status keepalived查看状态： 12sudo systemctl start keepalivedsudo systemctl enable keepalived keepalived.conf在keepalived的安装目录/usr/local/keepalived/etc/keepalived/samples/有很多样例配置，每一种配置对应的都是一种使用场景，后续会做详细说明，因此在此处不做过多的分析。 此处使用最简单的配置入门，假设我们以/tmp/目录下是否存在service_ok这个文件来判断服务是否可用。可参考样例/usr/local/keepalived/etc/keepalived/samples/keepalived.conf.vrrp.localcheck 12345678910111213141516171819vrrp_script chk_service_ok &#123; script \"ls /tmp/service_ok\" # 检查文件是否存在 interval 2 # 每两秒钟检查一次&#125;vrrp_instance VI_1 &#123; interface enp0s3 # 指定网卡 state MASTER # 角色，主机为MASTER，备机为BACKUP virtual_router_id 51 # 虚拟路由Id，相同的ID表示在相同的组 priority 100 # 优先级，MASTER的优先级要比BACKUP的大 virtual_ipaddress &#123; # 虚拟IP地址，即VIP 192.168.42.23/25 &#125; track_script &#123; # 设置vrrp检查脚本的名称 chk_service_ok &#125;&#125; KeepAlived的验证我们使用两台虚拟机，IP地址分别为主机vm01（192.168.42.21）和备机vm02（192.168.42.22）， VIP为192.168.42.23。安装好KeepAlived后, 编辑配置文件sudo vim /etc/keepalived/keepalived.conf 主机vm01（192.168.42.21）的配置如下： 12345678910111213141516171819vrrp_script chk_service_ok &#123; script \"ls /tmp/service_ok\" interval 2&#125;vrrp_instance VI_1 &#123; interface enp0s3 state MASTER virtual_router_id 51 priority 100 virtual_ipaddress &#123; 192.168.42.23/25 &#125; track_script &#123; chk_service_ok &#125;&#125; 备机vm02（192.168.42.22）的配置如下，相对于vm01，只修改state和priority: 12345678910111213141516171819vrrp_script chk_service_ok &#123; script \"ls /tmp/service_ok\" interval 2&#125;vrrp_instance VI_1 &#123; interface enp0s3 state BACKUP virtual_router_id 51 priority 80 virtual_ipaddress &#123; 192.168.42.23/25 &#125; track_script &#123; chk_service_ok &#125;&#125; 首先，我们在两台机器上都创建一个system_ok文件，表示机器是OK的，touch /tmp/service_ok。然后执行sudo systemctl restart keepalived重新启动两台机器的keepalived。 分别在两台机器上执行ip a查看机器的网络信息，可以发现VIP（192.168.42.23）已经在主机vm01上，我们通过ssh ruan@192.168.42.23登陆到的也是主机vm01。 我们删除主机vm01上的/tmp/service_ok文件，然后重新执行ip a，发现VIP（192.168.42.23）已经漂移到备机vm02上，此时我们通过ssh ruan@192.168.42.23登陆则是备机vm02。即当主机故障时，业务可以自动切换至备机。 我们重新创建主机vm01上的/tmp/service_ok文件，，然后重新执行ip a，发现VIP（192.168.42.23）已经重新漂移到备机vm01上，此时我们通过ssh ruan@192.168.42.23登陆重新回到主机vm01。即当主机恢复时，可以自动将该主机加入到服务器群提供服务。","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/tags/环境搭建/"}]},{"title":"VirtualBox安装Ubuntu教程","date":"2018-09-16T11:59:38.000Z","path":"2018/09/16/VirtualBox安装Ubuntu教程/","text":"基础准备工作本教程使用的VirtualBox版本为5.2.18，Ubuntu版本为server 18.04.1。 首先，下载Ubuntu Server镜像，本文以ubuntu-18.04.1为例，可以从华为开源镜像站提供加速下载，地址为： http://mirrors.huaweicloud.com/repository/ubuntu-releases/18.04.1/ubuntu-18.04.1-live-server-amd64.iso 下载并安装VirtualBox，下载地址为: https://download.virtualbox.org/virtualbox/5.2.18/VirtualBox-5.2.18-124319-Win.exe 创建虚拟机 打开VirtualBox，点击新建, 输入名称，比如叫做UbuntuTemplate，之所以叫这个名称是因为如果后续需要多个Ubuntu虚拟机的话，可以直接复制该虚拟机，这样每次都可以有一个全新的虚拟机。操作系统版本选择Ubuntu(64bit), 点击下一步，内存选择512M或者1024M都可以，因为我们下载的镜像是没有桌面的，因此对内存要求没有那么大。 选择现在创建虚拟磁盘，当然，如果也可以使用已经存在的磁盘，下一步，磁盘类型我更愿意用VMDK(虚拟机磁盘)，因此该磁盘VMWare也是可以使用的，磁盘大小选择动态分配大小。 此处有两个地方需要注意一下： 选择磁盘的保存位置默认为虚拟机名称，这个时候是保存在用户目录下的，也就是C盘，因此最好是自己选择路径保存到其他目录，以免占用过多的C盘空间。 此处设置的其实是磁盘的最大大小，默认的10G肯定是太小了，可以直接改成100G, 这个是最大值，不是立即分配这么大的磁盘空间。 设置虚拟机设置粘贴板 导入操作系统镜像从设置的系统标签页中可以看出系统的启动顺序是“软驱”-&gt;”光驱”-&gt;”硬盘”，因此只要在光驱中导入刚刚下载的操作系统镜像，启动的虚拟机的时候就会开始安装操作系统。 设置虚拟机网络虚拟机的网络连接方式有很多中，因为涉及到很多网络知识，总结起来就是一张表，如下所示： 因为在做实验的情况下，默认都是希望虚拟机能够访问外网，虚拟机与虚拟机之间，虚拟机与宿主机之间也是可以相互访问的，因此选择桥接模式，网卡选择你当前正在使用的网卡，这样你的虚拟机就相当于是另外与宿主机相同的电脑。 安装Ubuntu 通过方向键移动，回车确认，如果发现鼠标在虚拟机捕获出不来了，可以按键盘右边的CTRL键 启动虚拟机，语言选择英文，然后选择Install Ubuntu。 如果你的宿主机连接的是路由器，那么一般都是通过DHCP自动分配的IP地址，这样的话虚拟机也能通过DHCP自动获取IP地址，从下图中可以看出对应的IP。 如果你的宿主机能够正常上网就不需要配置proxy，直接回车确认下一步就可以。 配置Ubuntu的源，也就是安装软件的默认下载地址，为了提高下载速度，我一般使用华为开源镜像站的源：https://mirrors.huaweicloud.com/ubuntu/ 我们可以手动对磁盘进行分区，但是这个需要对Linux很熟悉，因此此处我们直接选择Use An Entre Disk，让操作系统自动分区。 接下来会让你确认磁盘和分区信息，我们继续就可以。 然后输入你的主机名和密码等信息，ssh identify是用于免密码登陆linux的，一般不需要设置。 接下来会让你安装一些默认的应用程序，也可以什么都不装，保持一个最纯净的系统。 等待安装完毕，就可以开开心心重启了， 重启的过程中VirtualBox会提示你是否将光驱中的镜像移除掉，直接回车就可以移除就剋有了，这样就可以直接从磁盘启动你刚刚安装的系统，否则还是会从光驱中启动。 启动后输入用户名密码，输入ip a命令可以看到虚拟机的IP地址: 由于Ubuntu自带的控制台使用不是很方便，因此可以直接通过xshell连接该虚拟机 VirtualBox的使用说明鼠标捕获如果发现鼠标在虚拟机捕获出不来了，可以按键盘右边的CTRL键 保存快照如下所示，一般第一次安装的时候都做一次快照，因此这样即使后续做了破坏性的操作也可以快速还原。 快速保存并恢复关闭虚拟机时可以选择快速休眠，下次启动的时候就可以快速从将虚拟机从当前状态恢复。 复制虚拟机在做实验的时候需要使用多个虚拟机，不用重新安装，直接复制虚拟机即可，在对应的虚拟机上右键就可以，需要在关机的状态下才能复制。但是在复制虚拟机之后最后刷新一下网卡的MAC地址，否则可能会出现相同MAC地址的情况。","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/tags/环境搭建/"}]},{"title":"每天学习一个Linux命令（3）：echo命令","date":"2018-05-02T11:20:58.000Z","path":"2018/05/02/每天学习一个Linux命令（3）：echo命令/","text":"echo命令用于输出字符串，可以通过参数和转义等来控制输出格式。 语法1echo [-neE] [arg ...] 参数 -n 打印不添加换行符 -e 使能转义字符 转义字符 \\b 退格键，即删除一个字符 \\c 抑制后续的输出 \\n 换行 \\t tab键 \\\\ 斜杠 使用小技巧 echo是shell的内部命令，因此查看帮助需要使用help echo echo后的字符串如果使用单引号括起来，则转义和变量都失效(重要) 通过-e参数和\\c转义可以控制换行的输出 常用范例范例1： 显示普通字符串命令： echo &quot;this is a text&quot; # 也可以不加引号输出：1this is a text 范例2： 显示转义字符命令： echo &quot;\\&quot;this is a text\\&quot;&quot;输出：1&quot;this is a text&quot; 范例3： 显示变量命令：12text=\"ffff\"echo \"this is a $&#123;text&#125;\" 输出：1this is a ffff 范例4： 输出换行命令：12echo -e \"this \\n\"echo \"is a text\" 输出：123this is a text 范例5： 不输出换行命令：12echo -e \"this \\c\"echo \"is a text\" 输出：1this is a text （注：相比于上面的命令，少了两个换行） 范例6： 禁止显示转义和变量（使用单引号）命令： echo &#39;$name\\&quot;&#39; # 这个很重要输出：1$name\\&quot; 范例7： 显示命令执行的结果命令：12echo `date`echo $(date) 输出：12Tue May 1 21:16:57 CST 2018Tue May 1 21:16:57 CST 2018","tags":[{"name":"Linux","slug":"Linux","permalink":"http://ruanxinyu.github.io/tags/Linux/"}]},{"title":"每天学习一个Linux命令（2）：cd命令","date":"2018-05-01T10:00:58.000Z","path":"2018/05/01/每天学习一个Linux命令（2）：cd命令/","text":"cd命令用于切换至目标目录，以/开头的则为绝对路径，否则为相对路径。 语法1cd [dir] 使用小技巧 切换至用户所示在的目录可以使用cd ~ 或者 cd(不带参数) &quot;.&quot; 则是表示目前所在的目录，&quot;..&quot; 则表示目前目录位置的上一层目录 通过pwd命令可以打印当前所在的目录 cd -表示切换至上一次所在的目录 常用范例范例1： 切换至根目录下的var目录下命令： cd /var(绝对路径) 范例2： 切换至当前目录下的var目录下命令： cd var(相对目录) 范例3： 切换至上两级的目录命令： cd ../../ 范例4： 切换至包含空格的目录命令： cd &#39;aa aa&#39;或者cd aa\\ aa 范例5： 切换至当前用户的home目录命令： cd ~或者cd 范例6： 打印当前所在的目录命令： pwd 范例7： 切换到上一次所在的目录命令： cd -","tags":[{"name":"Linux","slug":"Linux","permalink":"http://ruanxinyu.github.io/tags/Linux/"}]},{"title":"每天学习一个Linux命令（1）：ls命令","date":"2018-05-01T08:18:02.000Z","path":"2018/05/01/每天学习一个Linux命令（1）：ls命令/","text":"ls命令是linux下最常用的命令。ls命令就是list的缩写，用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。 语法1ls [OPTION]... [FILE]... 参数 -a 显示所有文件及目录，包括以.开头的隐藏文件 -A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录) -l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出 -h human-readable，默认-l参数显示出来的文件大小是字节大小，-h参数可以按照KB/MB/GB来显示 -r reverse，将文件以相反次序显示(原定依英文字母次序) -t 将文件依建立时间之先后次序列出 -F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“ -R recursive，若目录下有文件，则以下之文件亦皆依序列出 使用小技巧 一般Linux操作系统都会存在一个ll的命令，相当于ls -l --color=auto ls命令使支持*通配符的 常用范例范例1： 列出/var目录下的文件命令： ls /var结果： 范例2： 列出目前工作目录下所有名称是s开头的文件，越新的排越后面命令： ls -ltr s*结果： 范例3： 将/bin目录以下所有目录及文件详细资料列出命令： ls -lR /bin","tags":[{"name":"Linux","slug":"Linux","permalink":"http://ruanxinyu.github.io/tags/Linux/"}]},{"title":"如何使用GitHubPages搭建个人博客","date":"2018-04-30T12:07:11.000Z","path":"2018/04/30/如何使用GitHubPages搭建个人博客/","text":"我对个人博客的要求我对个人博客有如下几点要求，因此最终选定通过Hexo+GitHub Pages来搭建。 存在独立域名，别人能通过互联网访问 通过Git进行管理，支持MarkDown语法 不需要自己购买主机维护环境 支持评论分享等功能 配置GitHub Pages 前提： 您需要有一个GitHub的账号，请将下文中的ruanxinyu替换为您的用户名。 点击此处，创建一个仓库， 一般GitHub Pages对应的仓库名称规则为： 用户名.github.io， 如下图所示： 现在仓库有了，但是在推送内容之前还需要设置GitHub的SSH秘钥，通过如下命令生成并查看SSH秘钥，如果需要输入，一路回车就即可： 12ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; cat /c/Users/you/.ssh/id_rsa.pub 进入到GitHub的Setting页面，添加SSH秘钥，如下图所示： 下面，我们往仓库中推送一个index.html页面来充当我们的博客，可以参考如下命令：（Windows下可以使用git bash终端运行如下命令） 123456git clone git@github.com:RuanXinyu/ruanxinyu.github.io.gitcd ruanxinyu.github.ioecho \"Hello World\" &gt; index.htmlgit add --allgit commit -m \"Initial commit\"git push -u origin master 此时你的博客已经产生，网址为：https://ruanxinyu.github.io/, 点击即可访问: 安装并体验Hexo GitHub Pages相当于一个静态网站，您需要将您的博客全部转换为html页面才可以，当然，这个繁琐的过程不需要我们自己去完成，当前有两个框架可以做这个事情：Jekyll和Hexo，下面我就介绍一下如何通过Hexo快速的发表自己的文章。 Hexo是一个NodeJS实现的博客框架，官方文档地址为： https://hexo.io/zh-cn/docs/, 文档存在中文哦，给力吧！下面说一下使用过程： 执行npm install -g hexo-cli命令安装Hexo（在安装Hexo之前，请您自行安装NodeJS和NPM） 执行hexo init xxx创建一个博客 执行hexo generate渲染MarkDown博文，渲染出来的结果在public目录下 执行npm install hexo-server --save安装server工具，然后执行hexo server，访问http://localhost:4000/网址可在本地访问你的博客，该方式主要用于调试。 执行hexo new xxx创建一篇博文，博文的文件存放在source\\_posts目录下，编辑文档内容，hexo server会自动检测文章的变化并运行generate命令，因此刷新本地网址即可看到你更新的内容。 在将博文推送到GitHub Pages之前，执行npm install hexo-deployer-git --save安装部署工具，然后将根目录下的_config.yml文件中的如下内容更改为您的GitHub Pages的仓库地址，注意是git@开头的地址，否则在使用hexo deploy会报错 1234deploy: type: git repo: git@github.com:RuanXinyu/ruanxinyu.github.com.git branch: master 执行hexo deploy， Hexo将渲染后的页面放到.deploy_git目录，本地提交后，自动将您的博文推送到GitHub Pages所对应的仓库 此时，访问您的GitHubPages就可以看到你更新的文章内容。 切换到Indigo主题Hexo默认使用的是landscape主题，如果不符合自己的审美，可以在https://hexo.io/themes/查找自己喜欢的主题。我比较喜欢indigo主题，该主题有平铺和卡片两种显示方式，卡片模式的代码是在card分支下，下面以此主题为例。 克隆该主题的代码仓库，如下： 1git clone -b card https://github.com/yscoder/hexo-theme-indigo.git themes/indigo 安装Indigo主题依赖的插件 1234npm install hexo-renderer-less --savenpm install hexo-generator-feed --savenpm install hexo-generator-json-content --savenpm install hexo-helper-qrcode --save 修改顶层配置文件_config.yml中的theme: landscape为theme: indigo，刷新页面即可看到新的主题。 配置Hexo和Indigo主题Hexo的配置文件为_config.yml，Indigo主题的配置文件在themes/indigo/_config.yml。 Hexo的配置说明文档地址为： https://hexo.io/zh-cn/docs/configuration.htmlIndigo主题的配置说明文档地址为： https://github.com/yscoder/hexo-theme-indigo/wiki/%E9%85%8D%E7%BD%AE 官方文档已经描述很清楚，当然，最简单的方式是基于别人的进行修改，因此在此我贡献出我的配置，然后对几个点做一下说明。 Hexo配置文件样例 language: zh-CN: 语言的种类可以参考themes/indigo/languages目录下的文件 post_asset_folder: true: 在创建博文的时候自动生成对应的文件夹，以存放该博文对应的图片 配置文件末尾的feed和jsonContent两部分分别是hexo-generator-feed和hexo-generator-json-content两个插件的配置，该部分说明在Indigo的说明文章中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: RuanXinYu's Blogsubtitle: 路漫漫其修远兮，吾将上下而求索description: 阮新宇的成长记录keywords: Ruandyauthor: 阮新宇email: 1096421257@qq.comurl: http://ruanxinyu.github.io/language: zh-CNtimezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: true # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 20 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 20pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: indigo# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:RuanXinyu/ruanxinyu.github.com.git branch: masterfeed: type: atom path: atom.xml limit: 0jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true Indigo配置文件样例 该主题对应的图片在themes/indigo/source/img，请自行进行替换 样例内容配置了百度统计功能，下文有详细描述 样例内容配置了gitment的评论功能，下文有详细描述 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162# hexo-theme-indigo# https://github.com/yscoder/hexo-theme-indigo# 添加新菜单项遵循以下规则# menu:# link: fontawesome图标，省略前缀，本主题前缀为 icon-，必须# text: About 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写# url: /about 链接，绝对或相对路径，必须。# target: _blank 是否跳出，省略则在当前页面打开menu: home: text: 主页 url: / archives: text: 归档 url: /archives tags: text: 标签 url: /tags th-list: text: 分类 url: /categories github: url: https://github.com/RuanXinyu target: _blank# 你的头像urlavatar: /img/avatar.png# avatar linkavatar_link: /# 头像背景图brand: /img/brand.jpg# faviconfavicon: /favicon.ico# emailemail: 1096421257@qq.com# 设置 Android L Chrome 浏览器状态栏颜色color: '#3F51B5'# 页面标题tags_title: 标签archives_title: 归档categories_title: 分类# 文章截断excerpt_render: falseexcerpt_length: 200excerpt_link: 阅读全文...mathjax: falsearchive_yearly: true# 是否显示文章最后更新时间show_last_updated: true# 是否开启分享share: true# 是否开启打赏，关闭 reward: falsereward: title: 谢谢您的打赏 wechat: /img/wechat.png #微信，关闭设为 false alipay: /img/alipay.jpg #支付宝，关闭设为 false# 是否开启搜索search: true# 是否大屏幕下文章页隐藏导航hideMenu: false# 是否开启toc# toc: falsetoc: list_number: true # 是否显示数字排序# 文章页留言内容，hexo中所有变量及辅助函数等均可调用，具体请查阅 hexo.iopostMessage: 原始链接：&lt;a href=\"&lt;%- url_for(page.path).replace(/index\\.html$/, '') %&gt;\" target=\"_blank\" rel=\"external\"&gt;&lt;%- page.permalink.replace(/index\\.html$/, '') %&gt;&lt;/a&gt;# 站长统计，如要开启，输入CNZZ站点id，如 cnzz: 1255152447cnzz: false# 百度统计，如要开启，改为你的 keybaidu_tongji: b4c4998e548a16b827d4ffe9dbe2b47b# 腾讯分析，如要开启，输入站点idtajs: false# googlegoogle_analytics: falsegoogle_site_verification: false# sogou站长验证 http://zhanzhang.sogou.com/sogou_site_verification: false# lessless: compress: true paths: - source/css/style.less# 以下评论插件开启一个即可# 是否开启 disqusdisqus_shortname: false# 是否开启友言评论, 填写友言用户iduyan_uid: false# 是否使用 gitment，https://github.com/imsun/gitment#gitment: falsegitment: owner: RuanXinyu repo: ruanxinyu.github.com client_id: 2a6e23cf2e39e54ef316 client_secret: f237d3eb9fc94607a0454f894b143efe72eb8aca# Valine Comment system. https://valine.js.orgvaline: enable: false # 如果你想使用valine，请将值设置为 true appId: # your leancloud appId appKey: # your leancloud appKey notify: false # Mail notify verify: false # Verify code avatar: mm # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide placeholder: Just go go # Comment Box placeholder guest_info: nick,mail,link # Comment header info pageSize: 10 # comment list page size# 是否开启Hyper Comments，填写id则启用，false则禁用。http://hypercomments.com# Hyper Comments support. Write your id here, or false to disablehyper_id: false# 规范网址# 让搜索引擎重定向你的不同域名、不同子域、同域不同目录的站点到你期望的路径# https://support.google.com/webmasters/answer/139066# 假设配置为 canonical: http://imys.net，那么从搜索引擎中 www.imys.net 进入会重定向到 imys.netcanonical: false# 版权起始年份since_year: 2015# 用户页面中作者相关的描述性文字，如不需要设为 falseabout: 用户页面中作者相关的描述性文字，如不需要设为 false# “不蒜子”访问量统计，详见 http://ibruce.info/2015/04/04/busuanzi/visit_counter: site_uv: 站点总访客数： site_pv: 站点总访问量：# 动态定义titletitle_change: normal: 欢迎回来！ leave: 您还会回来吗？# 设置为 true 发布后将使用 unpkg cdn 最新的主题样式# 如果想让你的自定义样式生效，把此项设为 falsecdn: true# 设置为 true 将使用 lightbox render 图片lightbox: true# icp备案号 ICP_license: 京ICP备1234556号-1ICP_license: false 配置百度统计 百度统计是可以免费试用的，进入到百度统计注册账号，然后进入到管理页面添加你的网址，如下图所示： 添加完成之后，你就可以看到你的Key，如下图所示： 将你的key值添加到indigo主题的配置文件中即可，如下所示： 12# 百度统计，如要开启，改为你的 keybaidu_tongji: b4c4998e548a16b827d4ffe9dbe2b47b 访问百度统计查看你的网站访问情况等数据。 配置评论功能 友言评论功能已经关闭，因此采用的是gitment插件，该插件是依托于GitHub的Issue的功能的。采用npm install --save gitment命令安装gitment。 点击此处注册OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，比如： https://ruanxinyu.github.io ）。 你会得到一个client ID和一个client secret，将其配置到indigo的配置文件中： 1234567# 是否使用 gitment，https://github.com/imsun/gitment#gitment: falsegitment: owner: RuanXinyu repo: ruanxinyu.github.com client_id: 2a6e23cf2e29e54ef316 client_secret: f237d3eb9fc94607a0354f894b143efe52eb8aca 页面发布后，你需要访问页面并使用你的GitHub账号登录（请确保你的账号是第二步所填repo的owner），点击初始化按钮，之后其他用户即可在该页面发表评论。 如果初始化时出现Error：validation failed，则说明你的网址超过50个字符，这是由GitHub的Issue限制的，此时可以修改themes\\indigo\\layout\\_partial\\plugins\\gitment.ejs文件的如下内容，以时间为ID： 123456789var gitment = new Gitment(&#123; id: '&lt;%- page.date %&gt;', owner: '&lt;%- theme.gitment.owner %&gt;', repo: '&lt;%- theme.gitment.repo %&gt;', oauth: &#123; client_id: '&lt;%- theme.gitment.client_id %&gt;', client_secret: '&lt;%- theme.gitment.client_secret %&gt;', &#125;,&#125;) 现在在你的博文下就可以进行评论了： 在你所指定的GitHub仓库中的Issue中也会有你的评论信息： 如果出现其他问题，可以参考：https://imsun.net/posts/gitment-introduction/和https://www.jianshu.com/p/57afa4844aaa 使用个人独立域名经过上述的配置，我们的博客已经能够在公网访问，但是如果您还想需要自己的域名，而不是以github.io结尾的，比如我的域名为：blog.ruanxinyu.cn，那么您可以按照下面的说明进行配置。 配置域名解析DNS首先您需要购买自己的域名，比如通过阿里云进行购买https://wanwang.aliyun.com/?spm=5176.8142029.388261.275.a7236d3earZNnp，该过程比较繁琐，需要认证。 域名认证通过之后，需要在添在云解析DNS中加一项CNAME将你的独立域名指向你的GitHub Pages网址，如下图所示， 其中ruanxinyu.cn是我购买的域名；blog是我为我的博客分配的二级域名，二级域名是自己随意指定的；ruanxinyu.github.io是我的GitHub Pages地址。 配置GitHub仓库进入到你的GitHub Pages所在的代码仓库的配置中，将您的域名配置进去： 到此，您就可以通过您的独立域名访问您的博客内容，比如我的：https://blog.ruanxinyu.cn 还存在一个小问题，每次你通过hexo deploy -g将你的博客推送到你的GitHubPages的时候，域名配置就丢失了，为了解决此问题，我们可以在我的Hexo工程添加一个source/CNAME文件，在该文件中写入你的独立域名，比如blog.ruanxinyu.cn，这样每次推送，都会自动给您设置域名。 通过Git的子模块功能管理主题为什么要用Git的子模块功能呢？ 我们的博客代码是存在我们自己仓库中的，而主题是从别人的仓库中拉取的，并且我们会修改主题中的配置文件。如果我们将主题的内容全部存到我们的仓库中，那么如果主题的作者更新了内容，我们想同步下来就会很费劲。而Git的子模块功能就是为了解决这个问题的，允许你将一个Git仓库当作另外一个Git仓库的子目录，允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。 在华为DevCloud上建立私有代码仓因为敏感信息问题，我不想将hexo工程源码放和主题的源码放在gitHub上，因此我在华为软件开发云上建立了两个私有仓库: 一个用于存放我的hexo工程源码，地址为：1git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/Blog.git 一个用于存放我修改后的indigo主题，该仓库是从indigo的官方仓库导入进来的, 如下图所示, 地址为：1git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/hexo-theme-indigo.git 如何添加Git的子模块功能在第一次使用的时候，需要先添加子模块功能：1git submodule add -b card git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/hexo-theme-indigo.git themes/indigo 此时，会在你的代码目录下生成.gitmodules文件，该文件记录你的子模块信息：1234[submodule &quot;themes/indigo&quot;]truepath = themes/indigotrueurl = git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/hexo-theme-indigo.gittruebranch = card 然后执行git submodule init和git submodule update命令将远端的代码同步下来。 如何修改indigo主题的内容我们根据自己的需要修改主题文件夹中的文件，然后推送至我们的私有仓库即可，可以参考如下命令：1234cd themes/indigogit add .git commit -m '修改配置信息'git push origin card 如何同步indigo主题官方仓库的更新首先，我们将我们的仓库与官方的仓库进行一下关联，如下所示：1git remote add office -t card https://github.com/yscoder/hexo-theme-indigo.git 之后通过git pull office即可将官方的仓库合并到本地。 如何修改Hexo工程代码的内容Hexo工程就跟普通仓库一样维护即可，与子模块是相互独立的，当前两个仓库分开维护即可。Hexo工程代码并不会管理indigo主题的文件，而只是维护一个子模块的commit id。 克隆已经添加子模块功能的hexo工程使用子模块之后，克隆Hexo工程代码可以加上--recursive参数，将子模组的内容一起克隆下来，如果没有加该参数，则需要手动执行一下git submodule update：1git clone --recursive git@codehub.devcloud.huaweicloud.com:55d03e8e8ec445bfb3fffbc66b1001dd/Blog.git 你可能会遇到的坑 执行hexo deploy时报error deployer not found:github错误 您没有安装安装hexo-deployer-git造成的，通过 npm install hexo-deployer-git --save进行安装 执行hexo deploy时报Permission denied (publickey)错误 您的Github没有配置你的SSH key，配置方法参照上文的“配置GitHub Pages”章节 执行hexo deploy时报fatal: could not read Username for &#39;https://github.com&#39;: Invalid argument错误 在GitHub上设置SSH Key，同时将配置文件deploy配置下的git地址改为git@开头的ssh地址，如下所示： 1234deploy: type: git repo: git@github.com:RuanXinyu/ruanxinyu.github.com.git branch: master 百度统计没有数据 百度统计在初次添加后会有一定的延迟，可以手动检查是否添加成功，如下所示: gitment初始化评论时出现Error：validation failed 这是由于你的网址超过50个字符导致的，解决方式请参照上文“配置评论功能”中的第5条","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/tags/环境搭建/"}]},{"title":"JDK安装教程","date":"2018-04-15T06:53:32.000Z","path":"2018/04/15/JDK安装教程/","text":"学习Java，首先得安装JDK(Java Development Kit)，那么下面就说一下如何在Windows和Linux下安装并验证JDK。 JDK的下载JDK的官方下载地址为： http://www.oracle.com/technetwork/java/javase/downloads/index.html， 请根据需要下载对应操作系统的安装包。 官方下载速度比较慢，因此可以从华为开源镜像站下载，地址为：https://mirrors.huaweicloud.com/repository/toolkit/java/jdk/ Windows下安装JDK 以jdk-8u151为例，双击上一步下载下来的exe文件，默认安装即可。（备注：路径可以选择其他盘符，但是不建议路径中包含中文及特殊字符） 进入到系统环境变量的管理界面：右键计算机图标=&gt;属性=&gt;高级系统设置=&gt;环境变量 新建变量JAVA_HOME，值为：C:\\Program Files\\Java\\jdk1.8.0_151 编辑变量PATH，追加：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 新建变量CLASSPATH，值为：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar Linux下安装JDK 以jdk-8u151为例，下载JDK后，将压缩包解压至特定的目录，一般解压至/usr/local目录，下载和解压命令可以参考如下命令： 12wget https://mirrors.huaweicloud.com/repository/toolkit/java/jdk/8u151-b12/jdk-8u151-linux-x64.tar.gztar -zxvf -C /usr/local/ jdk-8u151-linux-x64.tar.gz 经JDK的路径加入到环境变量中，在命令行中输入vim /etc/profile，编辑文件，在文件末尾增加如下的内容，然后执行source /etc/profile使环境变量生效。 1234export JAVA_HOME=/usr/local/jdk-8u151export JRE_HOME=/usr/local/jdk-8u151/jreexport CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin JDK的验证windows打开CMD命令窗口，Linux打开终端端口，输入java -version命令，如果出现如下提示则Java安装成功。","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://ruanxinyu.github.io/tags/环境搭建/"},{"name":"Java","slug":"Java","permalink":"http://ruanxinyu.github.io/tags/Java/"}]}]